/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_aics_web_3d_viewer"] = self["webpackChunk_aics_web_3d_viewer"] || []).push([["vendors-node_modules_aics_volume-viewer_es_workers_FetchTiffWorker_js"],{

/***/ "./node_modules/@aics/volume-viewer/es/workers/FetchTiffWorker.js":
/*!************************************************************************!*\
  !*** ./node_modules/@aics/volume-viewer/es/workers/FetchTiffWorker.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! geotiff */ \"./node_modules/geotiff/dist-module/geotiff.js\");\n\n\n\n\nself.onmessage = /*#__PURE__*/function () {\n  var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(e) {\n    var channelIndex, tilesizex, tilesizey, sizez, sizec, dimensionOrder, bytesPerSample, tiff, u16, u8, startindex, incrementz, imageIndex, zslice, image, result, arrayresult, offset, chmin, chmax, j, val, _j, results;\n\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // TODO index images by time\n            // const time = e.data.time;\n            channelIndex = e.data.channel;\n            tilesizex = e.data.tilesizex;\n            tilesizey = e.data.tilesizey;\n            sizez = e.data.sizez;\n            sizec = e.data.sizec;\n            dimensionOrder = e.data.dimensionOrder;\n            bytesPerSample = e.data.bytesPerSample;\n            console.log(\"Begin fetching channel \", channelIndex);\n            _context.next = 10;\n            return (0,geotiff__WEBPACK_IMPORTED_MODULE_2__.fromUrl)(e.data.url);\n\n          case 10:\n            tiff = _context.sent;\n            u16 = new Uint16Array(tilesizex * tilesizey * sizez);\n            u8 = new Uint8Array(tilesizex * tilesizey * sizez); // load the images of this channel from the tiff\n            // today assume TCZYX so the slices are already in order.\n\n            startindex = 0;\n            incrementz = 1;\n\n            if (dimensionOrder === \"XYZCT\") {\n              // we have XYZCT which is the \"good\" case\n              // TCZYX\n              startindex = sizez * channelIndex;\n              incrementz = 1;\n            } else if (dimensionOrder === \"XYCZT\") {\n              // we have to loop differently to increment channels\n              // TZCYX\n              startindex = channelIndex;\n              incrementz = sizec;\n            }\n\n            imageIndex = startindex, zslice = 0;\n\n          case 17:\n            if (!(zslice < sizez)) {\n              _context.next = 30;\n              break;\n            }\n\n            _context.next = 20;\n            return tiff.getImage(imageIndex);\n\n          case 20:\n            image = _context.sent;\n            _context.next = 23;\n            return image.readRasters({\n              width: tilesizex,\n              height: tilesizey\n            });\n\n          case 23:\n            result = _context.sent;\n            arrayresult = Array.isArray(result) ? result[0] : result; // deposit in full channel array in the right place\n\n            offset = zslice * tilesizex * tilesizey;\n\n            if (arrayresult.BYTES_PER_ELEMENT === 2) {\n              u16.set(arrayresult, offset);\n            } else if (arrayresult.BYTES_PER_ELEMENT === 1) {\n              u8.set(arrayresult, offset);\n            } else {\n              console.log(\"byte size not supported yet\");\n            }\n\n          case 27:\n            imageIndex += incrementz, ++zslice;\n            _context.next = 17;\n            break;\n\n          case 30:\n            // all slices collected, now resample 16-to-8 bits\n            if (bytesPerSample === 2) {\n              chmin = 65535; //metadata.channels[i].window.min;\n\n              chmax = 0; //metadata.channels[i].window.max;\n              // find min and max (only of data we are sampling?)\n\n              for (j = 0; j < u16.length; ++j) {\n                val = u16[j];\n\n                if (val < chmin) {\n                  chmin = val;\n                }\n\n                if (val > chmax) {\n                  chmax = val;\n                }\n              }\n\n              for (_j = 0; _j < u16.length; ++_j) {\n                u8[_j] = (u16[_j] - chmin) / (chmax - chmin) * 255;\n              }\n            } else if (bytesPerSample === 1) {// no op; keep u8\n            } else {\n              console.log(\"byte size not supported yet\");\n            }\n\n            results = {\n              data: u8,\n              channel: channelIndex\n            };\n            postMessage(results, [results.data.buffer]);\n\n          case 33:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFpY3Mvdm9sdW1lLXZpZXdlci9lcy93b3JrZXJzL0ZldGNoVGlmZldvcmtlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RTtBQUNYO0FBQzNCOztBQUVsQztBQUNBLGFBQWEsbUZBQWlCLGVBQWUsc0VBQXdCO0FBQ3JFOztBQUVBLFdBQVcsc0VBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQU87O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3Qix5QkFBeUI7QUFDekI7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0MsVUFBVTtBQUN4RCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AYWljcy92b2x1bWUtdmlld2VyL2VzL3dvcmtlcnMvRmV0Y2hUaWZmV29ya2VyLmpzPzYwNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIjtcbmltcG9ydCBfcmVnZW5lcmF0b3JSdW50aW1lIGZyb20gXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiO1xuaW1wb3J0IHsgZnJvbVVybCB9IGZyb20gXCJnZW90aWZmXCI7XG5cbnNlbGYub25tZXNzYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGUpIHtcbiAgICB2YXIgY2hhbm5lbEluZGV4LCB0aWxlc2l6ZXgsIHRpbGVzaXpleSwgc2l6ZXosIHNpemVjLCBkaW1lbnNpb25PcmRlciwgYnl0ZXNQZXJTYW1wbGUsIHRpZmYsIHUxNiwgdTgsIHN0YXJ0aW5kZXgsIGluY3JlbWVudHosIGltYWdlSW5kZXgsIHpzbGljZSwgaW1hZ2UsIHJlc3VsdCwgYXJyYXlyZXN1bHQsIG9mZnNldCwgY2htaW4sIGNobWF4LCBqLCB2YWwsIF9qLCByZXN1bHRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIFRPRE8gaW5kZXggaW1hZ2VzIGJ5IHRpbWVcbiAgICAgICAgICAgIC8vIGNvbnN0IHRpbWUgPSBlLmRhdGEudGltZTtcbiAgICAgICAgICAgIGNoYW5uZWxJbmRleCA9IGUuZGF0YS5jaGFubmVsO1xuICAgICAgICAgICAgdGlsZXNpemV4ID0gZS5kYXRhLnRpbGVzaXpleDtcbiAgICAgICAgICAgIHRpbGVzaXpleSA9IGUuZGF0YS50aWxlc2l6ZXk7XG4gICAgICAgICAgICBzaXpleiA9IGUuZGF0YS5zaXplejtcbiAgICAgICAgICAgIHNpemVjID0gZS5kYXRhLnNpemVjO1xuICAgICAgICAgICAgZGltZW5zaW9uT3JkZXIgPSBlLmRhdGEuZGltZW5zaW9uT3JkZXI7XG4gICAgICAgICAgICBieXRlc1BlclNhbXBsZSA9IGUuZGF0YS5ieXRlc1BlclNhbXBsZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQmVnaW4gZmV0Y2hpbmcgY2hhbm5lbCBcIiwgY2hhbm5lbEluZGV4KTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBmcm9tVXJsKGUuZGF0YS51cmwpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHRpZmYgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgdTE2ID0gbmV3IFVpbnQxNkFycmF5KHRpbGVzaXpleCAqIHRpbGVzaXpleSAqIHNpemV6KTtcbiAgICAgICAgICAgIHU4ID0gbmV3IFVpbnQ4QXJyYXkodGlsZXNpemV4ICogdGlsZXNpemV5ICogc2l6ZXopOyAvLyBsb2FkIHRoZSBpbWFnZXMgb2YgdGhpcyBjaGFubmVsIGZyb20gdGhlIHRpZmZcbiAgICAgICAgICAgIC8vIHRvZGF5IGFzc3VtZSBUQ1pZWCBzbyB0aGUgc2xpY2VzIGFyZSBhbHJlYWR5IGluIG9yZGVyLlxuXG4gICAgICAgICAgICBzdGFydGluZGV4ID0gMDtcbiAgICAgICAgICAgIGluY3JlbWVudHogPSAxO1xuXG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uT3JkZXIgPT09IFwiWFlaQ1RcIikge1xuICAgICAgICAgICAgICAvLyB3ZSBoYXZlIFhZWkNUIHdoaWNoIGlzIHRoZSBcImdvb2RcIiBjYXNlXG4gICAgICAgICAgICAgIC8vIFRDWllYXG4gICAgICAgICAgICAgIHN0YXJ0aW5kZXggPSBzaXpleiAqIGNoYW5uZWxJbmRleDtcbiAgICAgICAgICAgICAgaW5jcmVtZW50eiA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpbWVuc2lvbk9yZGVyID09PSBcIlhZQ1pUXCIpIHtcbiAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBsb29wIGRpZmZlcmVudGx5IHRvIGluY3JlbWVudCBjaGFubmVsc1xuICAgICAgICAgICAgICAvLyBUWkNZWFxuICAgICAgICAgICAgICBzdGFydGluZGV4ID0gY2hhbm5lbEluZGV4O1xuICAgICAgICAgICAgICBpbmNyZW1lbnR6ID0gc2l6ZWM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGltYWdlSW5kZXggPSBzdGFydGluZGV4LCB6c2xpY2UgPSAwO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGlmICghKHpzbGljZSA8IHNpemV6KSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICByZXR1cm4gdGlmZi5nZXRJbWFnZShpbWFnZUluZGV4KTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBpbWFnZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2UucmVhZFJhc3RlcnMoe1xuICAgICAgICAgICAgICB3aWR0aDogdGlsZXNpemV4LFxuICAgICAgICAgICAgICBoZWlnaHQ6IHRpbGVzaXpleVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGFycmF5cmVzdWx0ID0gQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0WzBdIDogcmVzdWx0OyAvLyBkZXBvc2l0IGluIGZ1bGwgY2hhbm5lbCBhcnJheSBpbiB0aGUgcmlnaHQgcGxhY2VcblxuICAgICAgICAgICAgb2Zmc2V0ID0genNsaWNlICogdGlsZXNpemV4ICogdGlsZXNpemV5O1xuXG4gICAgICAgICAgICBpZiAoYXJyYXlyZXN1bHQuQllURVNfUEVSX0VMRU1FTlQgPT09IDIpIHtcbiAgICAgICAgICAgICAgdTE2LnNldChhcnJheXJlc3VsdCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyYXlyZXN1bHQuQllURVNfUEVSX0VMRU1FTlQgPT09IDEpIHtcbiAgICAgICAgICAgICAgdTguc2V0KGFycmF5cmVzdWx0LCBvZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJieXRlIHNpemUgbm90IHN1cHBvcnRlZCB5ZXRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgaW1hZ2VJbmRleCArPSBpbmNyZW1lbnR6LCArK3pzbGljZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgIC8vIGFsbCBzbGljZXMgY29sbGVjdGVkLCBub3cgcmVzYW1wbGUgMTYtdG8tOCBiaXRzXG4gICAgICAgICAgICBpZiAoYnl0ZXNQZXJTYW1wbGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgY2htaW4gPSA2NTUzNTsgLy9tZXRhZGF0YS5jaGFubmVsc1tpXS53aW5kb3cubWluO1xuXG4gICAgICAgICAgICAgIGNobWF4ID0gMDsgLy9tZXRhZGF0YS5jaGFubmVsc1tpXS53aW5kb3cubWF4O1xuICAgICAgICAgICAgICAvLyBmaW5kIG1pbiBhbmQgbWF4IChvbmx5IG9mIGRhdGEgd2UgYXJlIHNhbXBsaW5nPylcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdTE2Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdTE2W2pdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IGNobWluKSB7XG4gICAgICAgICAgICAgICAgICBjaG1pbiA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsID4gY2htYXgpIHtcbiAgICAgICAgICAgICAgICAgIGNobWF4ID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoX2ogPSAwOyBfaiA8IHUxNi5sZW5ndGg7ICsrX2opIHtcbiAgICAgICAgICAgICAgICB1OFtfal0gPSAodTE2W19qXSAtIGNobWluKSAvIChjaG1heCAtIGNobWluKSAqIDI1NTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChieXRlc1BlclNhbXBsZSA9PT0gMSkgey8vIG5vIG9wOyBrZWVwIHU4XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImJ5dGUgc2l6ZSBub3Qgc3VwcG9ydGVkIHlldFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0cyA9IHtcbiAgICAgICAgICAgICAgZGF0YTogdTgsXG4gICAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWxJbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHJlc3VsdHMsIFtyZXN1bHRzLmRhdGEuYnVmZmVyXSk7XG5cbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoX3gpIHtcbiAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@aics/volume-viewer/es/workers/FetchTiffWorker.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/find-tag-by-name.js":
/*!****************************************************!*\
  !*** ./node_modules/xml-utils/find-tag-by-name.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const indexOfMatch = __webpack_require__(/*! ./index-of-match.js */ \"./node_modules/xml-utils/index-of-match.js\");\nconst indexOfMatchEnd = __webpack_require__(/*! ./index-of-match-end.js */ \"./node_modules/xml-utils/index-of-match-end.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\>]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFnLWJ5LW5hbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsdUVBQXFCO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLCtFQUF5Qjs7QUFFekQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFnLWJ5LW5hbWUuanM/ZWJlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbmRleE9mTWF0Y2ggPSByZXF1aXJlKFwiLi9pbmRleC1vZi1tYXRjaC5qc1wiKTtcbmNvbnN0IGluZGV4T2ZNYXRjaEVuZCA9IHJlcXVpcmUoXCIuL2luZGV4LW9mLW1hdGNoLWVuZC5qc1wiKTtcblxuZnVuY3Rpb24gZmluZFRhZ0J5TmFtZSh4bWwsIHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVidWcgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKSB8fCBmYWxzZTtcblxuICBjb25zdCBzdGFydEluZGV4ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGFydEluZGV4KSB8fCAwO1xuXG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBzdGFydGluZyBmaW5kVGFnQnlOYW1lIHdpdGhcIiwgdGFnTmFtZSwgXCIgYW5kIFwiLCBvcHRpb25zKTtcblxuICBjb25zdCBzdGFydCA9IGluZGV4T2ZNYXRjaCh4bWwsIGBcXDwke3RhZ05hbWV9WyBcXD5dYCwgc3RhcnRJbmRleCk7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBzdGFydDpcIiwgc3RhcnQpO1xuICBpZiAoc3RhcnQgPT09IC0xKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGFmdGVyU3RhcnQgPSB4bWwuc2xpY2Uoc3RhcnQgKyB0YWdOYW1lLmxlbmd0aCk7XG5cbiAgbGV0IHJlbGF0aXZlRW5kID0gaW5kZXhPZk1hdGNoRW5kKGFmdGVyU3RhcnQsIFwiXltePF0qWyAvXT5cIiwgMCk7XG5cbiAgY29uc3Qgc2VsZkNsb3NpbmcgPSByZWxhdGl2ZUVuZCAhPT0gLTEgJiYgYWZ0ZXJTdGFydFtyZWxhdGl2ZUVuZCAtIDFdID09PSBcIi9cIjtcbiAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt4bWwtdXRpbHNdIHNlbGZDbG9zaW5nOlwiLCBzZWxmQ2xvc2luZyk7XG5cbiAgaWYgKHNlbGZDbG9zaW5nID09PSBmYWxzZSkge1xuICAgIHJlbGF0aXZlRW5kID0gaW5kZXhPZk1hdGNoRW5kKGFmdGVyU3RhcnQsIFwiWyAvXVwiICsgdGFnTmFtZSArIFwiPlwiLCAwKTtcbiAgfVxuXG4gIGNvbnN0IGVuZCA9IHN0YXJ0ICsgdGFnTmFtZS5sZW5ndGggKyByZWxhdGl2ZUVuZCArIDE7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBlbmQ6XCIsIGVuZCk7XG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IG91dGVyID0geG1sLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAvLyB0YWcgaXMgbGlrZSA8Z21sOmlkZW50aWZpZXIgY29kZVNwYWNlPVwiT0dQXCI+dXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjMyNjE3PC9nbWw6aWRlbnRpZmllcj5cblxuICBsZXQgaW5uZXI7XG4gIGlmIChzZWxmQ2xvc2luZykge1xuICAgIGlubmVyID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBpbm5lciA9IG91dGVyLnNsaWNlKG91dGVyLmluZGV4T2YoXCI+XCIpICsgMSwgb3V0ZXIubGFzdEluZGV4T2YoXCI8XCIpKTtcbiAgfVxuXG4gIHJldHVybiB7IGlubmVyLCBvdXRlciwgc3RhcnQsIGVuZCB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRUYWdCeU5hbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/find-tag-by-name.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/find-tags-by-name.js":
/*!*****************************************************!*\
  !*** ./node_modules/xml-utils/find-tags-by-name.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const findTagByName = __webpack_require__(/*! ./find-tag-by-name.js */ \"./node_modules/xml-utils/find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    startIndex = tag.end;\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFncy1ieS1uYW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNCQUFzQixtQkFBTyxDQUFDLDJFQUF1Qjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxtQkFBbUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvZmluZC10YWdzLWJ5LW5hbWUuanM/NWVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmaW5kVGFnQnlOYW1lID0gcmVxdWlyZShcIi4vZmluZC10YWctYnktbmFtZS5qc1wiKTtcblxuZnVuY3Rpb24gZmluZFRhZ3NCeU5hbWUoeG1sLCB0YWdOYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgY29uc3QgZGVidWcgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKSB8fCBmYWxzZTtcbiAgbGV0IHN0YXJ0SW5kZXggPSAob3B0aW9ucyAmJiBvcHRpb25zLnN0YXJ0SW5kZXgpIHx8IDA7XG4gIGxldCB0YWc7XG4gIHdoaWxlICgodGFnID0gZmluZFRhZ0J5TmFtZSh4bWwsIHRhZ05hbWUsIHsgZGVidWcsIHN0YXJ0SW5kZXggfSkpKSB7XG4gICAgc3RhcnRJbmRleCA9IHRhZy5lbmQ7XG4gICAgdGFncy5wdXNoKHRhZyk7XG4gIH1cbiAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcImZpbmRUYWdzQnlOYW1lIGZvdW5kXCIsIHRhZ3MubGVuZ3RoLCBcInRhZ3NcIik7XG4gIHJldHVybiB0YWdzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRUYWdzQnlOYW1lO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/find-tags-by-name.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/get-attribute.js":
/*!*************************************************!*\
  !*** ./node_modules/xml-utils/get-attribute.js ***!
  \*************************************************/
/***/ ((module) => {

eval("function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  const pattern = `${attributeName}\\\\=\"\\([^\"]*\\)\"`;\n  if (debug) console.log(\"pattern:\", pattern);\n\n  const re = new RegExp(pattern);\n  const match = re.exec(xml);\n  if (debug) console.log(\"match:\", match);\n  if (match) return match[1];\n}\n\nmodule.exports = getAttribute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2dldC1hdHRyaWJ1dGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixjQUFjO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9nZXQtYXR0cmlidXRlLmpzPzk0ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0QXR0cmlidXRlKHRhZywgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGZhbHNlO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiZ2V0dGluZyBcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIiBpbiBcIiArIHRhZyk7XG5cbiAgY29uc3QgeG1sID0gdHlwZW9mIHRhZyA9PT0gXCJvYmplY3RcIiA/IHRhZy5vdXRlciA6IHRhZztcblxuICBjb25zdCBwYXR0ZXJuID0gYCR7YXR0cmlidXRlTmFtZX1cXFxcPVwiXFwoW15cIl0qXFwpXCJgO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwicGF0dGVybjpcIiwgcGF0dGVybik7XG5cbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICBjb25zdCBtYXRjaCA9IHJlLmV4ZWMoeG1sKTtcbiAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIm1hdGNoOlwiLCBtYXRjaCk7XG4gIGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEF0dHJpYnV0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/get-attribute.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/index-of-match-end.js":
/*!******************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match-end.js ***!
  \******************************************************/
/***/ ((module) => {

eval("function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLWVuZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9pbmRleC1vZi1tYXRjaC1lbmQuanM/NjU4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpbmRleE9mTWF0Y2hFbmQoeG1sLCBwYXR0ZXJuLCBzdGFydEluZGV4KSB7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgY29uc3QgbWF0Y2ggPSByZS5leGVjKHhtbC5zbGljZShzdGFydEluZGV4KSk7XG4gIGlmIChtYXRjaCkgcmV0dXJuIHN0YXJ0SW5kZXggKyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAtIDE7XG4gIGVsc2UgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluZGV4T2ZNYXRjaEVuZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/index-of-match-end.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/index-of-match.js":
/*!**************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match.js ***!
  \**************************************************/
/***/ ((module) => {

eval("function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLmpzP2Y0NjAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaW5kZXhPZk1hdGNoKHhtbCwgcGF0dGVybiwgc3RhcnRJbmRleCkge1xuICBjb25zdCByZSA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gIGNvbnN0IG1hdGNoID0gcmUuZXhlYyh4bWwuc2xpY2Uoc3RhcnRJbmRleCkpO1xuICBpZiAobWF0Y2gpIHJldHVybiBzdGFydEluZGV4ICsgbWF0Y2guaW5kZXg7XG4gIGVsc2UgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluZGV4T2ZNYXRjaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/index-of-match.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n\nfunction _regeneratorRuntime() {\n  \"use strict\";\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var exports = {},\n      Op = Object.prototype,\n      hasOwn = Op.hasOwnProperty,\n      $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n      iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n      asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n      toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n        generator = Object.create(protoGenerator.prototype),\n        context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n      NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n            value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n\n      reject(record.arg);\n    }\n\n    var previousPromise;\n\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          for (; ++i < iterable.length;) {\n            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n          }\n\n          return next.value = undefined, next.done = !0, next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n            record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n              hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\n\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxzR0FBaUM7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLHlCQUF5QixTQUFTLHlCQUF5QjtBQUNoRSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsc0NBQXNDLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWUuanM/YWNmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB2YXIgZXhwb3J0cyA9IHt9LFxuICAgICAgT3AgPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksXG4gICAgICAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICAgIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICAgIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIixcbiAgICAgIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSksIG9ialtrZXldO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLFxuICAgICAgICBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksXG4gICAgICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvci5faW52b2tlID0gZnVuY3Rpb24gKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuXG4gICAgICAgIGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkge1xuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnO1xuICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgICBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KGlubmVyRm4sIHNlbGYsIGNvbnRleHQpLCBnZW5lcmF0b3I7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7XG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgIGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnLFxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICB0aGlzLl9pbnZva2UgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSB7XG4gICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkpIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcbiAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdHJ5TG9jOiBsb2NzWzBdXG4gICAgfTtcbiAgICAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlO1xuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6ICEwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTtcbiAgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuO1xuICB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiBhcmdcbiAgICB9O1xuICB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgIH0pO1xuICB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgZm9yICg7IGtleXMubGVuZ3RoOykge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgIH07XG4gIH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgIHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247XG4gICAgICBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLFxuICAgICAgICAgICAgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSxcbiAgICAgICAgICAgICAgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpO1xuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH0sIGV4cG9ydHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yUnVudGltZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRyxFQUFFLHlCQUF5QixTQUFTLHlCQUF5QjtBQUNoRTs7QUFFQSwwQkFBMEIseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcz8xMzNlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gKG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpLCBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// TODO(Babel 8): Remove this file.\n\nvar runtime = __webpack_require__(/*! ../helpers/regeneratorRuntime */ \"./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\")();\nmodule.exports = runtime;\n\n// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLGtHQUErQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzPzViYTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyhCYWJlbCA4KTogUmVtb3ZlIHRoaXMgZmlsZS5cblxudmFyIHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWVcIikoKTtcbm1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9wYWNrYWdlcy9ydW50aW1lL3J1bnRpbWUuanMjTDczNj1cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _asyncToGenerator)\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanM/YjlmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/DataView.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/DataView.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getFloat16\": () => (/* binding */ getFloat16),\n/* harmony export */   \"setFloat16\": () => (/* binding */ setFloat16)\n/* harmony export */ });\n/* harmony import */ var _util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_util/arrayIterator.mjs */ \"./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs\");\n/* harmony import */ var _util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_util/converter.mjs */ \"./node_modules/@petamoriken/float16/src/_util/converter.mjs\");\n/* harmony import */ var _util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_util/primordials.mjs */ \"./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\n\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n *\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nfunction getFloat16(dataView, byteOffset, ...opts) {\n  return (0,_util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToNumber)(\n    (0,_util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__.DataViewPrototypeGetUint16)(dataView, byteOffset, ...(0,_util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__.safeIfNeeded)(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n *\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nfunction setFloat16(dataView, byteOffset, value, ...opts) {\n  return (0,_util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__.DataViewPrototypeSetUint16)(\n    dataView,\n    byteOffset,\n    (0,_util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__.roundToFloat16Bits)(value),\n    ...(0,_util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__.safeIfNeeded)(opts)\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL0RhdGFWaWV3Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5RDtBQUNtQjtBQUkzQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsYUFBYTtBQUNiO0FBQ087QUFDUCxTQUFTLG9FQUFlO0FBQ3hCLElBQUksaUZBQTBCLDBCQUEwQixxRUFBWTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QjtBQUNPO0FBQ1AsU0FBUyxpRkFBMEI7QUFDbkM7QUFDQTtBQUNBLElBQUksdUVBQWtCO0FBQ3RCLE9BQU8scUVBQVk7QUFDbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL0RhdGFWaWV3Lm1qcz8xNjk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNhZmVJZk5lZWRlZCB9IGZyb20gXCIuL191dGlsL2FycmF5SXRlcmF0b3IubWpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0VG9OdW1iZXIsIHJvdW5kVG9GbG9hdDE2Qml0cyB9IGZyb20gXCIuL191dGlsL2NvbnZlcnRlci5tanNcIjtcbmltcG9ydCB7XG4gIERhdGFWaWV3UHJvdG90eXBlR2V0VWludDE2LFxuICBEYXRhVmlld1Byb3RvdHlwZVNldFVpbnQxNixcbn0gZnJvbSBcIi4vX3V0aWwvcHJpbW9yZGlhbHMubWpzXCI7XG5cbi8qKlxuICogcmV0dXJucyBhbiB1bnNpZ25lZCAxNi1iaXQgZmxvYXQgYXQgdGhlIHNwZWNpZmllZCBieXRlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgRGF0YVZpZXdcbiAqXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXRcbiAqIEBwYXJhbSB7W2Jvb2xlYW5dfSBvcHRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmxvYXQxNihkYXRhVmlldywgYnl0ZU9mZnNldCwgLi4ub3B0cykge1xuICByZXR1cm4gY29udmVydFRvTnVtYmVyKFxuICAgIERhdGFWaWV3UHJvdG90eXBlR2V0VWludDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCAuLi5zYWZlSWZOZWVkZWQob3B0cykpXG4gICk7XG59XG5cbi8qKlxuICogc3RvcmVzIGFuIHVuc2lnbmVkIDE2LWJpdCBmbG9hdCB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGJ5dGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBEYXRhVmlld1xuICpcbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3XG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge1tib29sZWFuXX0gb3B0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmxvYXQxNihkYXRhVmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIC4uLm9wdHMpIHtcbiAgcmV0dXJuIERhdGFWaWV3UHJvdG90eXBlU2V0VWludDE2KFxuICAgIGRhdGFWaWV3LFxuICAgIGJ5dGVPZmZzZXQsXG4gICAgcm91bmRUb0Zsb2F0MTZCaXRzKHZhbHVlKSxcbiAgICAuLi5zYWZlSWZOZWVkZWQob3B0cylcbiAgKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/DataView.mjs\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"safeIfNeeded\": () => (/* binding */ safeIfNeeded),\n/* harmony export */   \"wrap\": () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primordials.mjs */ \"./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeWeakMap();\n\nconst SafeIteratorPrototype = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeGet)(arrayIterators, this);\n      return (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototypeNext)(arrayIterator);\n    },\n  },\n\n  [_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n *\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nfunction safeIfNeeded(array) {\n  if (array[_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.SymbolIterator] === _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeArrayPrototypeSymbolIterator) {\n    return array;\n  }\n\n  const safe = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(SafeIteratorPrototype);\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeSet)(arrayIterators, safe, (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayPrototypeSymbolIterator)(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeGet)(generators, this);\n      return (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.GeneratorPrototypeNext)(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ReflectOwnKeys)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectDefineProperty)(DummyArrayIteratorPrototype, key, (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ReflectGetOwnPropertyDescriptor)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n *\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nfunction wrap(generator) {\n  const dummy = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(DummyArrayIteratorPrototype);\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeSet)(generators, dummy, generator);\n  return dummy;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL2FycmF5SXRlcmF0b3IubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQWUyQjs7QUFFM0IsV0FBVyxVQUFVLDBCQUEwQjtBQUMvQywyQkFBMkIsMkRBQWE7O0FBRXhDLDhCQUE4Qiw4REFBWTtBQUMxQztBQUNBO0FBQ0EsNEJBQTRCLHFFQUFtQjtBQUMvQyxhQUFhLDRFQUEwQjtBQUN2QyxLQUFLO0FBQ0wsR0FBRzs7QUFFSCxHQUFHLDREQUFjO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUCxZQUFZLDREQUFjLE1BQU0sZ0ZBQWtDO0FBQ2xFO0FBQ0E7O0FBRUEsZUFBZSw4REFBWTtBQUMzQixFQUFFLHFFQUFtQix1QkFBdUIsOEVBQTRCO0FBQ3hFO0FBQ0E7O0FBRUEsV0FBVyxVQUFVLG1CQUFtQjtBQUN4Qyx1QkFBdUIsMkRBQWE7O0FBRXBDO0FBQ0Esb0NBQW9DLDhEQUFZLENBQUMsK0RBQWlCO0FBQ2xFO0FBQ0E7QUFDQSx3QkFBd0IscUVBQW1CO0FBQzNDLGFBQWEsd0VBQXNCO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQsa0JBQWtCLGdFQUFjLENBQUMsb0VBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxzRUFBb0IsbUNBQW1DLGlGQUErQixDQUFDLG9FQUFzQjtBQUMvRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQLGdCQUFnQiw4REFBWTtBQUM1QixFQUFFLHFFQUFtQjtBQUNyQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvYXJyYXlJdGVyYXRvci5tanM/MmNkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBcnJheUl0ZXJhdG9yUHJvdG90eXBlLFxuICBBcnJheUl0ZXJhdG9yUHJvdG90eXBlTmV4dCxcbiAgQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcixcbiAgR2VuZXJhdG9yUHJvdG90eXBlTmV4dCxcbiAgSXRlcmF0b3JQcm90b3R5cGUsXG4gIE5hdGl2ZUFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IsXG4gIE5hdGl2ZVdlYWtNYXAsXG4gIE9iamVjdENyZWF0ZSxcbiAgT2JqZWN0RGVmaW5lUHJvcGVydHksXG4gIFJlZmxlY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIFJlZmxlY3RPd25LZXlzLFxuICBTeW1ib2xJdGVyYXRvcixcbiAgV2Vha01hcFByb3RvdHlwZUdldCxcbiAgV2Vha01hcFByb3RvdHlwZVNldCxcbn0gZnJvbSBcIi4vcHJpbW9yZGlhbHMubWpzXCI7XG5cbi8qKiBAdHlwZSB7V2Vha01hcDx7fSwgSXRlcmFibGVJdGVyYXRvcjxhbnk+Pn0gKi9cbmNvbnN0IGFycmF5SXRlcmF0b3JzID0gbmV3IE5hdGl2ZVdlYWtNYXAoKTtcblxuY29uc3QgU2FmZUl0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0Q3JlYXRlKG51bGwsIHtcbiAgbmV4dDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgY29uc3QgYXJyYXlJdGVyYXRvciA9IFdlYWtNYXBQcm90b3R5cGVHZXQoYXJyYXlJdGVyYXRvcnMsIHRoaXMpO1xuICAgICAgcmV0dXJuIEFycmF5SXRlcmF0b3JQcm90b3R5cGVOZXh0KGFycmF5SXRlcmF0b3IpO1xuICAgIH0sXG4gIH0sXG5cbiAgW1N5bWJvbEl0ZXJhdG9yXToge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICB9LFxufSk7XG5cbi8qKlxuICogV3JhcCB0aGUgQXJyYXkgYXJvdW5kIHRoZSBTYWZlSXRlcmF0b3IgSWYgQXJyYXkucHJvdG90eXBlIFtAQGl0ZXJhdG9yXSBoYXMgYmVlbiBtb2RpZmllZFxuICpcbiAqIEB0eXBlIHs8VD4oYXJyYXk6IFRbXSkgPT4gSXRlcmFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlSWZOZWVkZWQoYXJyYXkpIHtcbiAgaWYgKGFycmF5W1N5bWJvbEl0ZXJhdG9yXSA9PT0gTmF0aXZlQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcikge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIGNvbnN0IHNhZmUgPSBPYmplY3RDcmVhdGUoU2FmZUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgV2Vha01hcFByb3RvdHlwZVNldChhcnJheUl0ZXJhdG9ycywgc2FmZSwgQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcihhcnJheSkpO1xuICByZXR1cm4gc2FmZTtcbn1cblxuLyoqIEB0eXBlIHtXZWFrTWFwPHt9LCBHZW5lcmF0b3I8YW55Pj59ICovXG5jb25zdCBnZW5lcmF0b3JzID0gbmV3IE5hdGl2ZVdlYWtNYXAoKTtcblxuLyoqIEBzZWUgaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0ICovXG5jb25zdCBEdW1teUFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3RDcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtcbiAgbmV4dDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gV2Vha01hcFByb3RvdHlwZUdldChnZW5lcmF0b3JzLCB0aGlzKTtcbiAgICAgIHJldHVybiBHZW5lcmF0b3JQcm90b3R5cGVOZXh0KGdlbmVyYXRvcik7XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gIH0sXG59KTtcblxuZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdE93bktleXMoQXJyYXlJdGVyYXRvclByb3RvdHlwZSkpIHtcbiAgLy8gbmV4dCBtZXRob2QgaGFzIGFscmVhZHkgZGVmaW5lZFxuICBpZiAoa2V5ID09PSBcIm5leHRcIikge1xuICAgIGNvbnRpbnVlO1xuICB9XG5cbiAgLy8gQ29weSBBcnJheUl0ZXJhdG9yUHJvdG90eXBlIGRlc2NyaXB0b3JzIHRvIER1bW15QXJyYXlJdGVyYXRvclByb3RvdHlwZVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShEdW1teUFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGtleSwgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBrZXkpKTtcbn1cblxuLyoqXG4gKiBXcmFwIHRoZSBHZW5lcmF0b3IgYXJvdW5kIHRoZSBkdW1teSBBcnJheUl0ZXJhdG9yXG4gKlxuICogQHR5cGUgezxUPihnZW5lcmF0b3I6IEdlbmVyYXRvcjxUPikgPT4gSXRlcmFibGVJdGVyYXRvcjxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXAoZ2VuZXJhdG9yKSB7XG4gIGNvbnN0IGR1bW15ID0gT2JqZWN0Q3JlYXRlKER1bW15QXJyYXlJdGVyYXRvclByb3RvdHlwZSk7XG4gIFdlYWtNYXBQcm90b3R5cGVTZXQoZ2VuZXJhdG9ycywgZHVtbXksIGdlbmVyYXRvcik7XG4gIHJldHVybiBkdW1teTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/_util/converter.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/converter.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertToNumber\": () => (/* binding */ convertToNumber),\n/* harmony export */   \"roundToFloat16Bits\": () => (/* binding */ roundToFloat16Bits)\n/* harmony export */ });\n/* harmony import */ var _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primordials.mjs */ \"./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n// algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\n\n\nconst buffer = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeArrayBuffer(4);\nconst floatView = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeFloat32Array(buffer);\nconst uint32View = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(buffer);\n\nconst baseTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(512);\nconst shiftTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -27) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n *\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nfunction roundToFloat16Bits(num) {\n  floatView[0] = /** @type {any} */ (num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(2048);\nconst exponentTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(64);\nconst offsetTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(64);\n\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13;    // zero pad mantissa bits\n  let e = 0;          // zero exponent\n\n  // normalized\n  while((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000;  // decrement exponent\n  }\n\n  m &= ~0x00800000;   // clear leading 1 bit\n  e += 0x38800000;    // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n *\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nfunction convertToNumber(float16bits) {\n  const m = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];\n  return floatView[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL2NvbnZlcnRlci5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBTTJCOztBQUUzQixtQkFBbUIsK0RBQWlCO0FBQ3BDLHNCQUFzQixnRUFBa0I7QUFDeEMsdUJBQXVCLCtEQUFpQjs7QUFFeEMsc0JBQXNCLCtEQUFpQjtBQUN2Qyx1QkFBdUIsK0RBQWlCOztBQUV4QyxnQkFBZ0IsU0FBUztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiwrREFBaUI7QUFDM0MsMEJBQTBCLCtEQUFpQjtBQUMzQyx3QkFBd0IsK0RBQWlCOztBQUV6QyxnQkFBZ0IsVUFBVTtBQUMxQixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L3NyYy9fdXRpbC9jb252ZXJ0ZXIubWpzPzU4MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYWxnb3JpdGhtOiBodHRwOi8vZm94LXRvb2xraXQub3JnL2Z0cC9mYXN0aGFsZmZsb2F0Y29udmVyc2lvbi5wZGZcblxuaW1wb3J0IHtcbiAgTmF0aXZlQXJyYXlCdWZmZXIsXG4gIE5hdGl2ZUZsb2F0MzJBcnJheSxcbiAgTmF0aXZlVWludDMyQXJyYXksXG59IGZyb20gXCIuL3ByaW1vcmRpYWxzLm1qc1wiO1xuXG5jb25zdCBidWZmZXIgPSBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoNCk7XG5jb25zdCBmbG9hdFZpZXcgPSBuZXcgTmF0aXZlRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG5jb25zdCB1aW50MzJWaWV3ID0gbmV3IE5hdGl2ZVVpbnQzMkFycmF5KGJ1ZmZlcik7XG5cbmNvbnN0IGJhc2VUYWJsZSA9IG5ldyBOYXRpdmVVaW50MzJBcnJheSg1MTIpO1xuY29uc3Qgc2hpZnRUYWJsZSA9IG5ldyBOYXRpdmVVaW50MzJBcnJheSg1MTIpO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGNvbnN0IGUgPSBpIC0gMTI3O1xuXG4gIC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcbiAgaWYgKGUgPCAtMjcpIHtcbiAgICBiYXNlVGFibGVbaV0gICAgICAgICA9IDB4MDAwMDtcbiAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4ODAwMDtcbiAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAyNDtcbiAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAyNDtcblxuICAvLyBzbWFsbCBudW1iZXIgKGRlbm9ybSlcbiAgfSBlbHNlIGlmIChlIDwgLTE0KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAgMHgwNDAwID4+ICgtZSAtIDE0KTtcbiAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9ICgweDA0MDAgPj4gKC1lIC0gMTQpKSB8IDB4ODAwMDtcbiAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAtZSAtIDE7XG4gICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gLWUgLSAxO1xuXG4gIC8vIG5vcm1hbCBudW1iZXJcbiAgfSBlbHNlIGlmIChlIDw9IDE1KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAgKGUgKyAxNSkgPDwgMTA7XG4gICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAoKGUgKyAxNSkgPDwgMTApIHwgMHg4MDAwO1xuICAgIHNoaWZ0VGFibGVbaV0gICAgICAgICA9IDEzO1xuICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDEzO1xuXG4gIC8vIGxhcmdlIG51bWJlciAoSW5maW5pdHksIC1JbmZpbml0eSlcbiAgfSBlbHNlIGlmIChlIDwgMTI4KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAweDdjMDA7XG4gICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweGZjMDA7XG4gICAgc2hpZnRUYWJsZVtpXSAgICAgICAgID0gMjQ7XG4gICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gMjQ7XG5cbiAgLy8gc3RheSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gMHg3YzAwO1xuICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgIHNoaWZ0VGFibGVbaV0gICAgICAgICA9IDEzO1xuICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDEzO1xuICB9XG59XG5cbi8qKlxuICogcm91bmQgYSBudW1iZXIgdG8gYSBoYWxmIGZsb2F0IG51bWJlciBiaXRzXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBudW0gLSBkb3VibGUgZmxvYXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGhhbGYgZmxvYXQgbnVtYmVyIGJpdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG9GbG9hdDE2Qml0cyhudW0pIHtcbiAgZmxvYXRWaWV3WzBdID0gLyoqIEB0eXBlIHthbnl9ICovIChudW0pO1xuICBjb25zdCBmID0gdWludDMyVmlld1swXTtcbiAgY29uc3QgZSA9IChmID4+IDIzKSAmIDB4MWZmO1xuICByZXR1cm4gYmFzZVRhYmxlW2VdICsgKChmICYgMHgwMDdmZmZmZikgPj4gc2hpZnRUYWJsZVtlXSk7XG59XG5cbmNvbnN0IG1hbnRpc3NhVGFibGUgPSBuZXcgTmF0aXZlVWludDMyQXJyYXkoMjA0OCk7XG5jb25zdCBleHBvbmVudFRhYmxlID0gbmV3IE5hdGl2ZVVpbnQzMkFycmF5KDY0KTtcbmNvbnN0IG9mZnNldFRhYmxlID0gbmV3IE5hdGl2ZVVpbnQzMkFycmF5KDY0KTtcblxuZm9yIChsZXQgaSA9IDE7IGkgPCAxMDI0OyArK2kpIHtcbiAgbGV0IG0gPSBpIDw8IDEzOyAgICAvLyB6ZXJvIHBhZCBtYW50aXNzYSBiaXRzXG4gIGxldCBlID0gMDsgICAgICAgICAgLy8gemVybyBleHBvbmVudFxuXG4gIC8vIG5vcm1hbGl6ZWRcbiAgd2hpbGUoKG0gJiAweDAwODAwMDAwKSA9PT0gMCkge1xuICAgIG0gPDw9IDE7XG4gICAgZSAtPSAweDAwODAwMDAwOyAgLy8gZGVjcmVtZW50IGV4cG9uZW50XG4gIH1cblxuICBtICY9IH4weDAwODAwMDAwOyAgIC8vIGNsZWFyIGxlYWRpbmcgMSBiaXRcbiAgZSArPSAweDM4ODAwMDAwOyAgICAvLyBhZGp1c3QgYmlhc1xuXG4gIG1hbnRpc3NhVGFibGVbaV0gPSBtIHwgZTtcbn1cbmZvciAobGV0IGkgPSAxMDI0OyBpIDwgMjA0ODsgKytpKSB7XG4gIG1hbnRpc3NhVGFibGVbaV0gPSAweDM4MDAwMDAwICsgKChpIC0gMTAyNCkgPDwgMTMpO1xufVxuXG5mb3IgKGxldCBpID0gMTsgaSA8IDMxOyArK2kpIHtcbiAgZXhwb25lbnRUYWJsZVtpXSA9IGkgPDwgMjM7XG59XG5leHBvbmVudFRhYmxlWzMxXSA9IDB4NDc4MDAwMDA7XG5leHBvbmVudFRhYmxlWzMyXSA9IDB4ODAwMDAwMDA7XG5mb3IgKGxldCBpID0gMzM7IGkgPCA2MzsgKytpKSB7XG4gIGV4cG9uZW50VGFibGVbaV0gPSAweDgwMDAwMDAwICsgKChpIC0gMzIpIDw8IDIzKTtcbn1cbmV4cG9uZW50VGFibGVbNjNdID0gMHhjNzgwMDAwMDtcblxuZm9yIChsZXQgaSA9IDE7IGkgPCA2NDsgKytpKSB7XG4gIGlmIChpICE9PSAzMikge1xuICAgIG9mZnNldFRhYmxlW2ldID0gMTAyNDtcbiAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYSBoYWxmIGZsb2F0IG51bWJlciBiaXRzIHRvIGEgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZsb2F0MTZiaXRzIC0gaGFsZiBmbG9hdCBudW1iZXIgYml0c1xuICogQHJldHVybnMge251bWJlcn0gZG91YmxlIGZsb2F0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9OdW1iZXIoZmxvYXQxNmJpdHMpIHtcbiAgY29uc3QgbSA9IGZsb2F0MTZiaXRzID4+IDEwO1xuICB1aW50MzJWaWV3WzBdID0gbWFudGlzc2FUYWJsZVtvZmZzZXRUYWJsZVttXSArIChmbG9hdDE2Yml0cyAmIDB4M2ZmKV0gKyBleHBvbmVudFRhYmxlW21dO1xuICByZXR1cm4gZmxvYXRWaWV3WzBdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/_util/converter.mjs\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/_util/messages.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/messages.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER\": () => (/* binding */ ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER),\n/* harmony export */   \"CANNOT_CONVERT_A_BIGINT_VALUE_TO_A_NUMBER\": () => (/* binding */ CANNOT_CONVERT_A_BIGINT_VALUE_TO_A_NUMBER),\n/* harmony export */   \"CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\": () => (/* binding */ CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT),\n/* harmony export */   \"CANNOT_MIX_BIGINT_AND_OTHER_TYPES\": () => (/* binding */ CANNOT_MIX_BIGINT_AND_OTHER_TYPES),\n/* harmony export */   \"DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH\": () => (/* binding */ DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH),\n/* harmony export */   \"ITERATOR_PROPERTY_IS_NOT_CALLABLE\": () => (/* binding */ ITERATOR_PROPERTY_IS_NOT_CALLABLE),\n/* harmony export */   \"OFFSET_IS_OUT_OF_BOUNDS\": () => (/* binding */ OFFSET_IS_OUT_OF_BOUNDS),\n/* harmony export */   \"REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE\": () => (/* binding */ REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE),\n/* harmony export */   \"SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT\": () => (/* binding */ SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT),\n/* harmony export */   \"THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT\": () => (/* binding */ THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT),\n/* harmony export */   \"THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY\": () => (/* binding */ THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY),\n/* harmony export */   \"THIS_IS_NOT_AN_OBJECT\": () => (/* binding */ THIS_IS_NOT_AN_OBJECT),\n/* harmony export */   \"THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT\": () => (/* binding */ THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT)\n/* harmony export */ });\nconst THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\nconst THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\nconst THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n  \"This constructor is not a subclass of Float16Array\";\nconst THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n  \"The constructor property value is not an object\";\nconst SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n  \"Species constructor didn't return TypedArray object\";\nconst DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n  \"Derived constructor created TypedArray object which was too small length\";\nconst ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n  \"Attempting to access detached ArrayBuffer\";\nconst CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n  \"Cannot convert undefined or null to object\";\nconst CANNOT_CONVERT_A_BIGINT_VALUE_TO_A_NUMBER =\n  \"Cannot convert a BigInt value to a number\";\nconst CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n  \"Cannot mix BigInt and other types, use explicit conversions\";\nconst ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\nconst REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n  \"Reduce of empty array with no initial value\";\nconst OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL21lc3NhZ2VzLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDQTtBQUNQO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L3NyYy9fdXRpbC9tZXNzYWdlcy5tanM/YjA2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVEhJU19JU19OT1RfQU5fT0JKRUNUID0gXCJUaGlzIGlzIG5vdCBhbiBvYmplY3RcIjtcbmV4cG9ydCBjb25zdCBUSElTX0lTX05PVF9BX0ZMT0FUMTZBUlJBWV9PQkpFQ1QgPSBcIlRoaXMgaXMgbm90IGEgRmxvYXQxNkFycmF5IG9iamVjdFwiO1xuZXhwb3J0IGNvbnN0IFRISVNfQ09OU1RSVUNUT1JfSVNfTk9UX0FfU1VCQ0xBU1NfT0ZfRkxPQVQxNkFSUkFZID1cbiAgXCJUaGlzIGNvbnN0cnVjdG9yIGlzIG5vdCBhIHN1YmNsYXNzIG9mIEZsb2F0MTZBcnJheVwiO1xuZXhwb3J0IGNvbnN0IFRIRV9DT05TVFJVQ1RPUl9QUk9QRVJUWV9WQUxVRV9JU19OT1RfQU5fT0JKRUNUID1cbiAgXCJUaGUgY29uc3RydWN0b3IgcHJvcGVydHkgdmFsdWUgaXMgbm90IGFuIG9iamVjdFwiO1xuZXhwb3J0IGNvbnN0IFNQRUNJRVNfQ09OU1RSVUNUT1JfRElETlRfUkVUVVJOX1RZUEVEQVJSQVlfT0JKRUNUID1cbiAgXCJTcGVjaWVzIGNvbnN0cnVjdG9yIGRpZG4ndCByZXR1cm4gVHlwZWRBcnJheSBvYmplY3RcIjtcbmV4cG9ydCBjb25zdCBERVJJVkVEX0NPTlNUUlVDVE9SX0NSRUFURURfVFlQRURBUlJBWV9PQkpFQ1RfV0hJQ0hfV0FTX1RPT19TTUFMTF9MRU5HVEggPVxuICBcIkRlcml2ZWQgY29uc3RydWN0b3IgY3JlYXRlZCBUeXBlZEFycmF5IG9iamVjdCB3aGljaCB3YXMgdG9vIHNtYWxsIGxlbmd0aFwiO1xuZXhwb3J0IGNvbnN0IEFUVEVNUFRJTkdfVE9fQUNDRVNTX0RFVEFDSEVEX0FSUkFZQlVGRkVSID1cbiAgXCJBdHRlbXB0aW5nIHRvIGFjY2VzcyBkZXRhY2hlZCBBcnJheUJ1ZmZlclwiO1xuZXhwb3J0IGNvbnN0IENBTk5PVF9DT05WRVJUX1VOREVGSU5FRF9PUl9OVUxMX1RPX09CSkVDVCA9XG4gIFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCI7XG5leHBvcnQgY29uc3QgQ0FOTk9UX0NPTlZFUlRfQV9CSUdJTlRfVkFMVUVfVE9fQV9OVU1CRVIgPVxuICBcIkNhbm5vdCBjb252ZXJ0IGEgQmlnSW50IHZhbHVlIHRvIGEgbnVtYmVyXCI7XG5leHBvcnQgY29uc3QgQ0FOTk9UX01JWF9CSUdJTlRfQU5EX09USEVSX1RZUEVTID1cbiAgXCJDYW5ub3QgbWl4IEJpZ0ludCBhbmQgb3RoZXIgdHlwZXMsIHVzZSBleHBsaWNpdCBjb252ZXJzaW9uc1wiO1xuZXhwb3J0IGNvbnN0IElURVJBVE9SX1BST1BFUlRZX0lTX05PVF9DQUxMQUJMRSA9IFwiQEBpdGVyYXRvciBwcm9wZXJ0eSBpcyBub3QgY2FsbGFibGVcIjtcbmV4cG9ydCBjb25zdCBSRURVQ0VfT0ZfRU1QVFlfQVJSQVlfV0lUSF9OT19JTklUSUFMX1ZBTFVFID1cbiAgXCJSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXCI7XG5leHBvcnQgY29uc3QgT0ZGU0VUX0lTX09VVF9PRl9CT1VORFMgPSBcIk9mZnNldCBpcyBvdXQgb2YgYm91bmRzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/_util/messages.mjs\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/_util/primordials.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/primordials.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrayBufferIsView\": () => (/* binding */ ArrayBufferIsView),\n/* harmony export */   \"ArrayBufferPrototypeGetByteLength\": () => (/* binding */ ArrayBufferPrototypeGetByteLength),\n/* harmony export */   \"ArrayBufferPrototypeSlice\": () => (/* binding */ ArrayBufferPrototypeSlice),\n/* harmony export */   \"ArrayIsArray\": () => (/* binding */ ArrayIsArray),\n/* harmony export */   \"ArrayIteratorPrototype\": () => (/* binding */ ArrayIteratorPrototype),\n/* harmony export */   \"ArrayIteratorPrototypeNext\": () => (/* binding */ ArrayIteratorPrototypeNext),\n/* harmony export */   \"ArrayPrototypeJoin\": () => (/* binding */ ArrayPrototypeJoin),\n/* harmony export */   \"ArrayPrototypePush\": () => (/* binding */ ArrayPrototypePush),\n/* harmony export */   \"ArrayPrototypeSymbolIterator\": () => (/* binding */ ArrayPrototypeSymbolIterator),\n/* harmony export */   \"ArrayPrototypeToLocaleString\": () => (/* binding */ ArrayPrototypeToLocaleString),\n/* harmony export */   \"DataViewPrototypeGetUint16\": () => (/* binding */ DataViewPrototypeGetUint16),\n/* harmony export */   \"DataViewPrototypeSetUint16\": () => (/* binding */ DataViewPrototypeSetUint16),\n/* harmony export */   \"GeneratorPrototypeNext\": () => (/* binding */ GeneratorPrototypeNext),\n/* harmony export */   \"IteratorPrototype\": () => (/* binding */ IteratorPrototype),\n/* harmony export */   \"MathTrunc\": () => (/* binding */ MathTrunc),\n/* harmony export */   \"NativeArrayBuffer\": () => (/* binding */ NativeArrayBuffer),\n/* harmony export */   \"NativeArrayPrototypeSymbolIterator\": () => (/* binding */ NativeArrayPrototypeSymbolIterator),\n/* harmony export */   \"NativeFloat32Array\": () => (/* binding */ NativeFloat32Array),\n/* harmony export */   \"NativeNumber\": () => (/* binding */ NativeNumber),\n/* harmony export */   \"NativeObject\": () => (/* binding */ NativeObject),\n/* harmony export */   \"NativeProxy\": () => (/* binding */ NativeProxy),\n/* harmony export */   \"NativeRangeError\": () => (/* binding */ NativeRangeError),\n/* harmony export */   \"NativeSharedArrayBuffer\": () => (/* binding */ NativeSharedArrayBuffer),\n/* harmony export */   \"NativeTypeError\": () => (/* binding */ NativeTypeError),\n/* harmony export */   \"NativeTypedArrayPrototypeSymbolIterator\": () => (/* binding */ NativeTypedArrayPrototypeSymbolIterator),\n/* harmony export */   \"NativeUint16Array\": () => (/* binding */ NativeUint16Array),\n/* harmony export */   \"NativeUint32Array\": () => (/* binding */ NativeUint32Array),\n/* harmony export */   \"NativeWeakMap\": () => (/* binding */ NativeWeakMap),\n/* harmony export */   \"NativeWeakSet\": () => (/* binding */ NativeWeakSet),\n/* harmony export */   \"NumberIsFinite\": () => (/* binding */ NumberIsFinite),\n/* harmony export */   \"NumberIsNaN\": () => (/* binding */ NumberIsNaN),\n/* harmony export */   \"ObjectCreate\": () => (/* binding */ ObjectCreate),\n/* harmony export */   \"ObjectDefineProperty\": () => (/* binding */ ObjectDefineProperty),\n/* harmony export */   \"ObjectFreeze\": () => (/* binding */ ObjectFreeze),\n/* harmony export */   \"ObjectHasOwn\": () => (/* binding */ ObjectHasOwn),\n/* harmony export */   \"ObjectIs\": () => (/* binding */ ObjectIs),\n/* harmony export */   \"ObjectPrototype__lookupGetter__\": () => (/* binding */ ObjectPrototype__lookupGetter__),\n/* harmony export */   \"ReflectApply\": () => (/* binding */ ReflectApply),\n/* harmony export */   \"ReflectConstruct\": () => (/* binding */ ReflectConstruct),\n/* harmony export */   \"ReflectDefineProperty\": () => (/* binding */ ReflectDefineProperty),\n/* harmony export */   \"ReflectGet\": () => (/* binding */ ReflectGet),\n/* harmony export */   \"ReflectGetOwnPropertyDescriptor\": () => (/* binding */ ReflectGetOwnPropertyDescriptor),\n/* harmony export */   \"ReflectGetPrototypeOf\": () => (/* binding */ ReflectGetPrototypeOf),\n/* harmony export */   \"ReflectHas\": () => (/* binding */ ReflectHas),\n/* harmony export */   \"ReflectOwnKeys\": () => (/* binding */ ReflectOwnKeys),\n/* harmony export */   \"ReflectSet\": () => (/* binding */ ReflectSet),\n/* harmony export */   \"ReflectSetPrototypeOf\": () => (/* binding */ ReflectSetPrototypeOf),\n/* harmony export */   \"SharedArrayBufferPrototypeGetByteLength\": () => (/* binding */ SharedArrayBufferPrototypeGetByteLength),\n/* harmony export */   \"SymbolFor\": () => (/* binding */ SymbolFor),\n/* harmony export */   \"SymbolIterator\": () => (/* binding */ SymbolIterator),\n/* harmony export */   \"SymbolSpecies\": () => (/* binding */ SymbolSpecies),\n/* harmony export */   \"SymbolToStringTag\": () => (/* binding */ SymbolToStringTag),\n/* harmony export */   \"TypedArray\": () => (/* binding */ TypedArray),\n/* harmony export */   \"TypedArrayPrototype\": () => (/* binding */ TypedArrayPrototype),\n/* harmony export */   \"TypedArrayPrototypeCopyWithin\": () => (/* binding */ TypedArrayPrototypeCopyWithin),\n/* harmony export */   \"TypedArrayPrototypeEntries\": () => (/* binding */ TypedArrayPrototypeEntries),\n/* harmony export */   \"TypedArrayPrototypeFill\": () => (/* binding */ TypedArrayPrototypeFill),\n/* harmony export */   \"TypedArrayPrototypeGetBuffer\": () => (/* binding */ TypedArrayPrototypeGetBuffer),\n/* harmony export */   \"TypedArrayPrototypeGetByteOffset\": () => (/* binding */ TypedArrayPrototypeGetByteOffset),\n/* harmony export */   \"TypedArrayPrototypeGetLength\": () => (/* binding */ TypedArrayPrototypeGetLength),\n/* harmony export */   \"TypedArrayPrototypeGetSymbolToStringTag\": () => (/* binding */ TypedArrayPrototypeGetSymbolToStringTag),\n/* harmony export */   \"TypedArrayPrototypeKeys\": () => (/* binding */ TypedArrayPrototypeKeys),\n/* harmony export */   \"TypedArrayPrototypeReverse\": () => (/* binding */ TypedArrayPrototypeReverse),\n/* harmony export */   \"TypedArrayPrototypeSet\": () => (/* binding */ TypedArrayPrototypeSet),\n/* harmony export */   \"TypedArrayPrototypeSlice\": () => (/* binding */ TypedArrayPrototypeSlice),\n/* harmony export */   \"TypedArrayPrototypeSort\": () => (/* binding */ TypedArrayPrototypeSort),\n/* harmony export */   \"TypedArrayPrototypeSubarray\": () => (/* binding */ TypedArrayPrototypeSubarray),\n/* harmony export */   \"TypedArrayPrototypeValues\": () => (/* binding */ TypedArrayPrototypeValues),\n/* harmony export */   \"Uint16ArrayFrom\": () => (/* binding */ Uint16ArrayFrom),\n/* harmony export */   \"WeakMapPrototypeGet\": () => (/* binding */ WeakMapPrototypeGet),\n/* harmony export */   \"WeakMapPrototypeHas\": () => (/* binding */ WeakMapPrototypeHas),\n/* harmony export */   \"WeakMapPrototypeSet\": () => (/* binding */ WeakMapPrototypeSet),\n/* harmony export */   \"WeakSetPrototypeAdd\": () => (/* binding */ WeakSetPrototypeAdd),\n/* harmony export */   \"WeakSetPrototypeHas\": () => (/* binding */ WeakSetPrototypeHas)\n/* harmony export */ });\n/* harmony import */ var _messages_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.mjs */ \"./node_modules/@petamoriken/float16/src/_util/messages.mjs\");\n/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\n\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nconst {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nconst NativeProxy = Proxy;\n\n// Number\nconst NativeNumber = Number;\nconst {\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = NativeNumber;\n\n// Symbol\nconst {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nconst NativeObject = Object;\nconst {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nconst ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        _messages_mjs__WEBPACK_IMPORTED_MODULE_0__.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nconst ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nconst ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nconst ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nconst ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nconst ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nconst NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nconst ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nconst MathTrunc = Math.trunc;\n\n// ArrayBuffer\nconst NativeArrayBuffer = ArrayBuffer;\nconst ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nconst ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nconst ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nconst NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nconst SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nconst TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nconst TypedArrayPrototype = TypedArray.prototype;\nconst NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nconst TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nconst TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nconst TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nconst TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nconst TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nconst TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nconst TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nconst TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nconst TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nconst TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nconst TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint16Array\nconst NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nconst Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nconst NativeUint32Array = Uint32Array;\n\n// Float32Array\nconst NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nconst ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nconst ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nconst GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nconst IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nconst DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nconst DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nconst NativeTypeError = TypeError;\nconst NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n *\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nconst NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nconst WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nconst WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n *\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nconst NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nconst WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nconst WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nconst WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL3ByaW1vcmRpYWxzLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUU0RTs7QUFFNUUsV0FBVywrRkFBK0Y7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDhFQUE4RTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDTzs7QUFFUDtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsV0FBVyw0REFBNEQ7QUFDaEUsbURBQW1ELEtBQUs7QUFDL0QsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxRkFBMEM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsV0FBVywrQ0FBK0M7QUFDbkQsZ0NBQWdDLEtBQUs7QUFDNUM7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQSxXQUFXLDJEQUEyRDtBQUMvRDtBQUNQLFdBQVcsMENBQTBDO0FBQzlDO0FBQ1AsV0FBVyx1REFBdUQ7QUFDM0Q7QUFDUDtBQUNBO0FBQ087QUFDUCxXQUFXLHdDQUF3QztBQUM1Qzs7QUFFUDtBQUNPOztBQUVQO0FBQ087QUFDQTtBQUNQO0FBQ0EsV0FBVywrREFBK0Q7QUFDbkU7QUFDUCxXQUFXLHNDQUFzQztBQUMxQzs7QUFFUDtBQUNPO0FBQ1AsV0FBVyxrREFBa0Q7QUFDdEQ7QUFDUDs7QUFFQTtBQUNBLGNBQWMsNklBQTZJO0FBQzNKLFdBQVcsS0FBSztBQUNUO0FBQ1A7QUFDTztBQUNBO0FBQ1AsV0FBVyxzREFBc0Q7QUFDMUQ7QUFDUCxXQUFXLHNEQUFzRDtBQUMxRDtBQUNQO0FBQ0E7QUFDQSxXQUFXLGdFQUFnRTtBQUNwRTtBQUNQO0FBQ0E7QUFDQSxXQUFXLDZFQUE2RTtBQUNqRjtBQUNQLFdBQVcsNENBQTRDO0FBQ2hEO0FBQ1A7QUFDQTtBQUNBLFdBQVcseUZBQXlGO0FBQzdGO0FBQ1AsV0FBVyx5RkFBeUY7QUFDN0Y7QUFDUDtBQUNBO0FBQ0EsV0FBVywwRkFBMEY7QUFDOUY7QUFDUCxXQUFXLDBFQUEwRTtBQUM5RTtBQUNQLFdBQVcsMEVBQTBFO0FBQzlFO0FBQ1A7QUFDQTtBQUNBLFdBQVcsMkNBQTJDO0FBQy9DO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ2pDO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUCxXQUFXLGdDQUFnQztBQUNwQztBQUNQO0FBQ0E7O0FBRUE7QUFDTzs7QUFFUDtBQUNPOztBQUVQO0FBQ0EsV0FBVyxLQUFLO0FBQ1Q7QUFDUCxXQUFXLDhEQUE4RDtBQUNsRTs7QUFFUDtBQUNBLFdBQVcsNEdBQTRHO0FBQ2hILDJEQUEyRDs7QUFFbEU7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyw0RUFBNEU7QUFDaEY7QUFDUDtBQUNBO0FBQ0EsV0FBVyx5RkFBeUY7QUFDN0Y7QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ087QUFDUDtBQUNBLFdBQVcsYUFBYSx3Q0FBd0M7QUFDekQ7QUFDUCxXQUFXLGFBQWEseUNBQXlDO0FBQzFEOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDTztBQUNQO0FBQ0EsV0FBVyxhQUFhLDJDQUEyQztBQUM1RDtBQUNQLFdBQVcsYUFBYSxpREFBaUQ7QUFDbEU7QUFDUCxXQUFXLGFBQWEsMkRBQTJEO0FBQzVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvcHJpbW9yZGlhbHMubWpzP2I2ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzLCBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuLyogZ2xvYmFsIFNoYXJlZEFycmF5QnVmZmVyICovXG5cbmltcG9ydCB7IENBTk5PVF9DT05WRVJUX1VOREVGSU5FRF9PUl9OVUxMX1RPX09CSkVDVCB9IGZyb20gXCIuL21lc3NhZ2VzLm1qc1wiO1xuXG4vKiogQHR5cGUgezxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueSkgPT4gYW55Pih0YXJnZXQ6IFQpID0+ICh0aGlzQXJnOiBUaGlzVHlwZTxUPiwgLi4uYXJnczogYW55W10pID0+IGFueX0gKi9cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKHRhcmdldCkge1xuICByZXR1cm4gKHRoaXNBcmcsIC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gUmVmbGVjdEFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJncyk7XG4gIH07XG59XG5cbi8qKiBAdHlwZSB7KHRhcmdldDogYW55LCBrZXk6IHN0cmluZyB8IHN5bWJvbCkgPT4gKHRoaXNBcmc6IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueX0gKi9cbmZ1bmN0aW9uIHVuY3VycnlUaGlzR2V0dGVyKHRhcmdldCwga2V5KSB7XG4gIHJldHVybiB1bmN1cnJ5VGhpcyhcbiAgICBSZWZsZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgKS5nZXRcbiAgKTtcbn1cblxuLy8gUmVmbGVjdFxuZXhwb3J0IGNvbnN0IHtcbiAgYXBwbHk6IFJlZmxlY3RBcHBseSxcbiAgY29uc3RydWN0OiBSZWZsZWN0Q29uc3RydWN0LFxuICBkZWZpbmVQcm9wZXJ0eTogUmVmbGVjdERlZmluZVByb3BlcnR5LFxuICBnZXQ6IFJlZmxlY3RHZXQsXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgZ2V0UHJvdG90eXBlT2Y6IFJlZmxlY3RHZXRQcm90b3R5cGVPZixcbiAgaGFzOiBSZWZsZWN0SGFzLFxuICBvd25LZXlzOiBSZWZsZWN0T3duS2V5cyxcbiAgc2V0OiBSZWZsZWN0U2V0LFxuICBzZXRQcm90b3R5cGVPZjogUmVmbGVjdFNldFByb3RvdHlwZU9mLFxufSA9IFJlZmxlY3Q7XG5cbi8vIFByb3h5XG5leHBvcnQgY29uc3QgTmF0aXZlUHJveHkgPSBQcm94eTtcblxuLy8gTnVtYmVyXG5leHBvcnQgY29uc3QgTmF0aXZlTnVtYmVyID0gTnVtYmVyO1xuZXhwb3J0IGNvbnN0IHtcbiAgaXNGaW5pdGU6IE51bWJlcklzRmluaXRlLFxuICBpc05hTjogTnVtYmVySXNOYU4sXG59ID0gTmF0aXZlTnVtYmVyO1xuXG4vLyBTeW1ib2xcbmV4cG9ydCBjb25zdCB7XG4gIGl0ZXJhdG9yOiBTeW1ib2xJdGVyYXRvcixcbiAgc3BlY2llczogU3ltYm9sU3BlY2llcyxcbiAgdG9TdHJpbmdUYWc6IFN5bWJvbFRvU3RyaW5nVGFnLFxuICBmb3I6IFN5bWJvbEZvcixcbn0gPSBTeW1ib2w7XG5cbi8vIE9iamVjdFxuZXhwb3J0IGNvbnN0IE5hdGl2ZU9iamVjdCA9IE9iamVjdDtcbmV4cG9ydCBjb25zdCB7XG4gIGNyZWF0ZTogT2JqZWN0Q3JlYXRlLFxuICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0RGVmaW5lUHJvcGVydHksXG4gIGZyZWV6ZTogT2JqZWN0RnJlZXplLFxuICBpczogT2JqZWN0SXMsXG59ID0gTmF0aXZlT2JqZWN0O1xuY29uc3QgT2JqZWN0UHJvdG90eXBlID0gTmF0aXZlT2JqZWN0LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KG9iamVjdDogb2JqZWN0LCBrZXk6IFByb3BlcnR5S2V5KSA9PiBGdW5jdGlvbiB8IHVuZGVmaW5lZH0gKi9cbmV4cG9ydCBjb25zdCBPYmplY3RQcm90b3R5cGVfX2xvb2t1cEdldHRlcl9fID0gLyoqIEB0eXBlIHthbnl9ICovIChPYmplY3RQcm90b3R5cGUpLl9fbG9va3VwR2V0dGVyX19cbiAgPyB1bmN1cnJ5VGhpcygvKiogQHR5cGUge2FueX0gKi8gKE9iamVjdFByb3RvdHlwZSkuX19sb29rdXBHZXR0ZXJfXylcbiAgOiAob2JqZWN0LCBrZXkpID0+IHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihcbiAgICAgICAgQ0FOTk9UX0NPTlZFUlRfVU5ERUZJTkVEX09SX05VTExfVE9fT0JKRUNUXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB0YXJnZXQgPSBOYXRpdmVPYmplY3Qob2JqZWN0KTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChPYmplY3RIYXNPd24oZGVzY3JpcHRvciwgXCJnZXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAoKHRhcmdldCA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZih0YXJnZXQpKSAhPT0gbnVsbCk7XG4gIH07XG4vKiogQHR5cGUgeyhvYmplY3Q6IG9iamVjdCwga2V5OiBQcm9wZXJ0eUtleSkgPT4gYm9vbGVhbn0gKi9cbmV4cG9ydCBjb25zdCBPYmplY3RIYXNPd24gPSAvKiogQHR5cGUge2FueX0gKi8gKE5hdGl2ZU9iamVjdCkuaGFzT3duIHx8XG4gIHVuY3VycnlUaGlzKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIEFycmF5XG5jb25zdCBOYXRpdmVBcnJheSA9IEFycmF5O1xuZXhwb3J0IGNvbnN0IEFycmF5SXNBcnJheSA9IE5hdGl2ZUFycmF5LmlzQXJyYXk7XG5jb25zdCBBcnJheVByb3RvdHlwZSA9IE5hdGl2ZUFycmF5LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KGFycmF5OiBBcnJheUxpa2U8dW5rbm93bj4sIHNlcGFyYXRvcj86IHN0cmluZykgPT4gc3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlSm9pbiA9IHVuY3VycnlUaGlzKEFycmF5UHJvdG90eXBlLmpvaW4pO1xuLyoqIEB0eXBlIHs8VD4oYXJyYXk6IFRbXSwgLi4uaXRlbXM6IFRbXSkgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlUHVzaCA9IHVuY3VycnlUaGlzKEFycmF5UHJvdG90eXBlLnB1c2gpO1xuLyoqIEB0eXBlIHsoYXJyYXk6IEFycmF5TGlrZTx1bmtub3duPiwgLi4ub3B0czogYW55W10pID0+IHN0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBBcnJheVByb3RvdHlwZVRvTG9jYWxlU3RyaW5nID0gdW5jdXJyeVRoaXMoXG4gIEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nXG4pO1xuZXhwb3J0IGNvbnN0IE5hdGl2ZUFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSBBcnJheVByb3RvdHlwZVtTeW1ib2xJdGVyYXRvcl07XG4vKiogQHR5cGUgezxUPihhcnJheTogVFtdKSA9PiBJdGVyYWJsZUl0ZXJhdG9yPFQ+fSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSB1bmN1cnJ5VGhpcyhOYXRpdmVBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yKTtcblxuLy8gTWF0aFxuZXhwb3J0IGNvbnN0IE1hdGhUcnVuYyA9IE1hdGgudHJ1bmM7XG5cbi8vIEFycmF5QnVmZmVyXG5leHBvcnQgY29uc3QgTmF0aXZlQXJyYXlCdWZmZXIgPSBBcnJheUJ1ZmZlcjtcbmV4cG9ydCBjb25zdCBBcnJheUJ1ZmZlcklzVmlldyA9IE5hdGl2ZUFycmF5QnVmZmVyLmlzVmlldztcbmNvbnN0IEFycmF5QnVmZmVyUHJvdG90eXBlID0gTmF0aXZlQXJyYXlCdWZmZXIucHJvdG90eXBlO1xuLyoqIEB0eXBlIHsoYnVmZmVyOiBBcnJheUJ1ZmZlciwgYmVnaW4/OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5QnVmZmVyUHJvdG90eXBlU2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheUJ1ZmZlclByb3RvdHlwZS5zbGljZSk7XG4vKiogQHR5cGUgeyhidWZmZXI6IEFycmF5QnVmZmVyKSA9PiBBcnJheUJ1ZmZlcn0gKi9cbmV4cG9ydCBjb25zdCBBcnJheUJ1ZmZlclByb3RvdHlwZUdldEJ5dGVMZW5ndGggPSB1bmN1cnJ5VGhpc0dldHRlcihBcnJheUJ1ZmZlclByb3RvdHlwZSwgXCJieXRlTGVuZ3RoXCIpO1xuXG4vLyBTaGFyZWRBcnJheUJ1ZmZlclxuZXhwb3J0IGNvbnN0IE5hdGl2ZVNoYXJlZEFycmF5QnVmZmVyID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBudWxsO1xuLyoqIEB0eXBlIHsoYnVmZmVyOiBTaGFyZWRBcnJheUJ1ZmZlcikgPT4gU2hhcmVkQXJyYXlCdWZmZXJ9ICovXG5leHBvcnQgY29uc3QgU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGVHZXRCeXRlTGVuZ3RoID0gTmF0aXZlU2hhcmVkQXJyYXlCdWZmZXJcbiAgJiYgdW5jdXJyeVRoaXNHZXR0ZXIoTmF0aXZlU2hhcmVkQXJyYXlCdWZmZXIucHJvdG90eXBlLCBcImJ5dGVMZW5ndGhcIik7XG5cbi8vIFR5cGVkQXJyYXlcbi8qKiBAdHlwZWRlZiB7VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheXxVaW50MTZBcnJheXxVaW50MzJBcnJheXxJbnQ4QXJyYXl8SW50MTZBcnJheXxJbnQzMkFycmF5fEZsb2F0MzJBcnJheXxGbG9hdDY0QXJyYXl8QmlnVWludDY0QXJyYXl8QmlnSW50NjRBcnJheX0gVHlwZWRBcnJheSAqL1xuLyoqIEB0eXBlIHthbnl9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheSA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZihVaW50OEFycmF5KTtcbmNvbnN0IFR5cGVkQXJyYXlGcm9tID0gVHlwZWRBcnJheS5mcm9tO1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5LnByb3RvdHlwZTtcbmV4cG9ydCBjb25zdCBOYXRpdmVUeXBlZEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW1N5bWJvbEl0ZXJhdG9yXTtcbi8qKiBAdHlwZSB7KHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEl0ZXJhYmxlSXRlcmF0b3I8bnVtYmVyPn0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlS2V5cyA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUua2V5cyk7XG4vKiogQHR5cGUgeyh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPG51bWJlcj59ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVZhbHVlcyA9IHVuY3VycnlUaGlzKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLnZhbHVlc1xuKTtcbi8qKiBAdHlwZSB7KHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEl0ZXJhYmxlSXRlcmF0b3I8W251bWJlciwgbnVtYmVyXT59ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZUVudHJpZXMgPSB1bmN1cnJ5VGhpcyhcbiAgVHlwZWRBcnJheVByb3RvdHlwZS5lbnRyaWVzXG4pO1xuLyoqIEB0eXBlIHsodHlwZWRBcnJheTogVHlwZWRBcnJheSwgYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+LCBvZmZzZXQ/OiBudW1iZXIpID0+IHZvaWR9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVNldCA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUuc2V0KTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBUKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVSZXZlcnNlID0gdW5jdXJyeVRoaXMoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUucmV2ZXJzZVxuKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCB2YWx1ZTogbnVtYmVyLCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVGaWxsID0gdW5jdXJyeVRoaXMoVHlwZWRBcnJheVByb3RvdHlwZS5maWxsKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCB0YXJnZXQ6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVDb3B5V2l0aGluID0gdW5jdXJyeVRoaXMoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUuY29weVdpdGhpblxuKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCBjb21wYXJlRm4/OiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlU29ydCA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUuc29ydCk7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMgVHlwZWRBcnJheT4odHlwZWRBcnJheTogVCwgc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlU2xpY2UgPSB1bmN1cnJ5VGhpcyhUeXBlZEFycmF5UHJvdG90eXBlLnNsaWNlKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVTdWJhcnJheSA9IHVuY3VycnlUaGlzKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLnN1YmFycmF5XG4pO1xuLyoqIEB0eXBlIHsoKHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEFycmF5QnVmZmVyKX0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0QnVmZmVyID0gdW5jdXJyeVRoaXNHZXR0ZXIoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUsXG4gIFwiYnVmZmVyXCJcbik7XG4vKiogQHR5cGUgeygodHlwZWRBcnJheTogVHlwZWRBcnJheSkgPT4gbnVtYmVyKX0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0Qnl0ZU9mZnNldCA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLFxuICBcImJ5dGVPZmZzZXRcIlxuKTtcbi8qKiBAdHlwZSB7KCh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBudW1iZXIpfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGggPSB1bmN1cnJ5VGhpc0dldHRlcihcbiAgVHlwZWRBcnJheVByb3RvdHlwZSxcbiAgXCJsZW5ndGhcIlxuKTtcbi8qKiBAdHlwZSB7KHRhcmdldDogdW5rbm93bikgPT4gc3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLFxuICBTeW1ib2xUb1N0cmluZ1RhZ1xuKTtcblxuLy8gVWludDE2QXJyYXlcbmV4cG9ydCBjb25zdCBOYXRpdmVVaW50MTZBcnJheSA9IFVpbnQxNkFycmF5O1xuLyoqIEB0eXBlIHtVaW50MTZBcnJheUNvbnN0cnVjdG9yW1wiZnJvbVwiXX0gKi9cbmV4cG9ydCBjb25zdCBVaW50MTZBcnJheUZyb20gPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gUmVmbGVjdEFwcGx5KFR5cGVkQXJyYXlGcm9tLCBOYXRpdmVVaW50MTZBcnJheSwgYXJncyk7XG59O1xuXG4vLyBVaW50MzJBcnJheVxuZXhwb3J0IGNvbnN0IE5hdGl2ZVVpbnQzMkFycmF5ID0gVWludDMyQXJyYXk7XG5cbi8vIEZsb2F0MzJBcnJheVxuZXhwb3J0IGNvbnN0IE5hdGl2ZUZsb2F0MzJBcnJheSA9IEZsb2F0MzJBcnJheTtcblxuLy8gQXJyYXlJdGVyYXRvclxuLyoqIEB0eXBlIHthbnl9ICovXG5leHBvcnQgY29uc3QgQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZihbXVtTeW1ib2xJdGVyYXRvcl0oKSk7XG4vKiogQHR5cGUgezxUPihhcnJheUl0ZXJhdG9yOiBJdGVyYWJsZUl0ZXJhdG9yPFQ+KSA9PiBJdGVyYXRvclJlc3VsdDxUPn0gKi9cbmV4cG9ydCBjb25zdCBBcnJheUl0ZXJhdG9yUHJvdG90eXBlTmV4dCA9IHVuY3VycnlUaGlzKEFycmF5SXRlcmF0b3JQcm90b3R5cGUubmV4dCk7XG5cbi8vIEdlbmVyYXRvclxuLyoqIEB0eXBlIHs8VCA9IHVua25vd24sIFRSZXR1cm4gPSBhbnksIFROZXh0ID0gdW5rbm93bj4oZ2VuZXJhdG9yOiBHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+LCB2YWx1ZT86IFROZXh0KSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IEdlbmVyYXRvclByb3RvdHlwZU5leHQgPSB1bmN1cnJ5VGhpcygoZnVuY3Rpb24qICgpIHt9KSgpLm5leHQpO1xuXG4vLyBJdGVyYXRvclxuZXhwb3J0IGNvbnN0IEl0ZXJhdG9yUHJvdG90eXBlID0gUmVmbGVjdEdldFByb3RvdHlwZU9mKEFycmF5SXRlcmF0b3JQcm90b3R5cGUpO1xuXG4vLyBEYXRhVmlld1xuY29uc3QgRGF0YVZpZXdQcm90b3R5cGUgPSBEYXRhVmlldy5wcm90b3R5cGU7XG4vKiogQHR5cGUgeyhkYXRhVmlldzogRGF0YVZpZXcsIGJ5dGVPZmZzZXQ6IG51bWJlciwgbGl0dGxlRW5kaWFuPzogYm9vbGVhbikgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IERhdGFWaWV3UHJvdG90eXBlR2V0VWludDE2ID0gdW5jdXJyeVRoaXMoXG4gIERhdGFWaWV3UHJvdG90eXBlLmdldFVpbnQxNlxuKTtcbi8qKiBAdHlwZSB7KGRhdGFWaWV3OiBEYXRhVmlldywgYnl0ZU9mZnNldDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyLCBsaXR0bGVFbmRpYW4/OiBib29sZWFuKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGNvbnN0IERhdGFWaWV3UHJvdG90eXBlU2V0VWludDE2ID0gdW5jdXJyeVRoaXMoXG4gIERhdGFWaWV3UHJvdG90eXBlLnNldFVpbnQxNlxuKTtcblxuLy8gRXJyb3JcbmV4cG9ydCBjb25zdCBOYXRpdmVUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5leHBvcnQgY29uc3QgTmF0aXZlUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbi8vIFdlYWtTZXRcbi8qKlxuICogRG8gbm90IGNvbnN0cnVjdCB3aXRoIGFyZ3VtZW50cyB0byBhdm9pZCBjYWxsaW5nIHRoZSBcImFkZFwiIG1ldGhvZFxuICpcbiAqIEB0eXBlIHt7bmV3IDxUIGV4dGVuZHMge30+KCk6IFdlYWtTZXQ8VD59fVxuICovXG5leHBvcnQgY29uc3QgTmF0aXZlV2Vha1NldCA9IFdlYWtTZXQ7XG5jb25zdCBXZWFrU2V0UHJvdG90eXBlID0gTmF0aXZlV2Vha1NldC5wcm90b3R5cGU7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMge30+KHNldDogV2Vha1NldDxUPiwgdmFsdWU6IFQpID0+IFNldDxUPn0gKi9cbmV4cG9ydCBjb25zdCBXZWFrU2V0UHJvdG90eXBlQWRkID0gdW5jdXJyeVRoaXMoV2Vha1NldFByb3RvdHlwZS5hZGQpO1xuLyoqIEB0eXBlIHs8VCBleHRlbmRzIHt9PihzZXQ6IFdlYWtTZXQ8VD4sIHZhbHVlOiBUKSA9PiBib29sZWFufSAqL1xuZXhwb3J0IGNvbnN0IFdlYWtTZXRQcm90b3R5cGVIYXMgPSB1bmN1cnJ5VGhpcyhXZWFrU2V0UHJvdG90eXBlLmhhcyk7XG5cbi8vIFdlYWtNYXBcbi8qKlxuICogRG8gbm90IGNvbnN0cnVjdCB3aXRoIGFyZ3VtZW50cyB0byBhdm9pZCBjYWxsaW5nIHRoZSBcInNldFwiIG1ldGhvZFxuICpcbiAqIEB0eXBlIHt7bmV3IDxLIGV4dGVuZHMge30sIFY+KCk6IFdlYWtNYXA8SywgVj59fVxuICovXG5leHBvcnQgY29uc3QgTmF0aXZlV2Vha01hcCA9IFdlYWtNYXA7XG5jb25zdCBXZWFrTWFwUHJvdG90eXBlID0gTmF0aXZlV2Vha01hcC5wcm90b3R5cGU7XG4vKiogQHR5cGUgezxLIGV4dGVuZHMge30sIFY+KHdlYWtNYXA6IFdlYWtNYXA8SywgVj4sIGtleTogSykgPT4gVn0gKi9cbmV4cG9ydCBjb25zdCBXZWFrTWFwUHJvdG90eXBlR2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5nZXQpO1xuLyoqIEB0eXBlIHs8SyBleHRlbmRzIHt9LCBWPih3ZWFrTWFwOiBXZWFrTWFwPEssIFY+LCBrZXk6IEspID0+IGJvb2xlYW59ICovXG5leHBvcnQgY29uc3QgV2Vha01hcFByb3RvdHlwZUhhcyA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuaGFzKTtcbi8qKiBAdHlwZSB7PEsgZXh0ZW5kcyB7fSwgVj4od2Vha01hcDogV2Vha01hcDxLLCBWPiwga2V5OiBLLCB2YWx1ZTogVikgPT4gV2Vha01hcH0gKi9cbmV4cG9ydCBjb25zdCBXZWFrTWFwUHJvdG90eXBlU2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5zZXQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/_util/primordials.mjs\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/basedecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/basedecoder.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BaseDecoder)\n/* harmony export */ });\n/* harmony import */ var _predictor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor.js */ \"./node_modules/geotiff/dist-module/predictor.js\");\n\n\nclass BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return (0,_predictor_js__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRDs7QUFFbEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2Jhc2VkZWNvZGVyLmpzP2QwZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwbHlQcmVkaWN0b3IgfSBmcm9tICcuLi9wcmVkaWN0b3IuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRGVjb2RlciB7XG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgdGhpcy5kZWNvZGVCbG9jayhidWZmZXIpO1xuICAgIGNvbnN0IHByZWRpY3RvciA9IGZpbGVEaXJlY3RvcnkuUHJlZGljdG9yIHx8IDE7XG4gICAgaWYgKHByZWRpY3RvciAhPT0gMSkge1xuICAgICAgY29uc3QgaXNUaWxlZCA9ICFmaWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0cztcbiAgICAgIGNvbnN0IHRpbGVXaWR0aCA9IGlzVGlsZWQgPyBmaWxlRGlyZWN0b3J5LlRpbGVXaWR0aCA6IGZpbGVEaXJlY3RvcnkuSW1hZ2VXaWR0aDtcbiAgICAgIGNvbnN0IHRpbGVIZWlnaHQgPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlTGVuZ3RoIDogKFxuICAgICAgICBmaWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCB8fCBmaWxlRGlyZWN0b3J5LkltYWdlTGVuZ3RoXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFwcGx5UHJlZGljdG9yKFxuICAgICAgICBkZWNvZGVkLCBwcmVkaWN0b3IsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLFxuICAgICAgICBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/compression/basedecoder.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addDecoder\": () => (/* binding */ addDecoder),\n/* harmony export */   \"getDecoder\": () => (/* binding */ getDecoder)\n/* harmony export */ });\nconst registry = new Map();\n\nfunction addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nasync function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => __webpack_require__.e(/*! import() */ \"node_modules_geotiff_dist-module_compression_raw_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./raw.js */ \"./node_modules/geotiff/dist-module/compression/raw.js\")).then((m) => m.default));\naddDecoder(5, () => __webpack_require__.e(/*! import() */ \"node_modules_geotiff_dist-module_compression_lzw_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./lzw.js */ \"./node_modules/geotiff/dist-module/compression/lzw.js\")).then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => __webpack_require__.e(/*! import() */ \"vendors-node_modules_geotiff_dist-module_compression_jpeg_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./jpeg.js */ \"./node_modules/geotiff/dist-module/compression/jpeg.js\")).then((m) => m.default));\naddDecoder([8, 32946], () => Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_pako_dist_pako_esm_mjs\"), __webpack_require__.e(\"node_modules_geotiff_dist-module_compression_deflate_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./deflate.js */ \"./node_modules/geotiff/dist-module/compression/deflate.js\")).then((m) => m.default));\naddDecoder(32773, () => __webpack_require__.e(/*! import() */ \"node_modules_geotiff_dist-module_compression_packbits_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./packbits.js */ \"./node_modules/geotiff/dist-module/compression/packbits.js\")).then((m) => m.default));\naddDecoder(34887, () => Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_pako_dist_pako_esm_mjs\"), __webpack_require__.e(\"vendors-node_modules_geotiff_dist-module_compression_lerc_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./lerc.js */ \"./node_modules/geotiff/dist-module/compression/lerc.js\")).then((m) => m.default));\naddDecoder(50001, () => __webpack_require__.e(/*! import() */ \"node_modules_geotiff_dist-module_compression_webimage_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./webimage.js */ \"./node_modules/geotiff/dist-module/compression/webimage.js\")).then((m) => m.default));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVPO0FBQ1A7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMseU5BQWtCO0FBQ25ELG9CQUFvQix5TkFBa0I7QUFDdEM7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0Isb09BQW1CO0FBQ3ZDLDZCQUE2Qix5VEFBc0I7QUFDbkQsd0JBQXdCLHdPQUF1QjtBQUMvQyx3QkFBd0Isd1RBQW1CO0FBQzNDLHdCQUF3Qix3T0FBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vaW5kZXguanM/ZjMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZWdpc3RyeSA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERlY29kZXIoY2FzZXMsIGltcG9ydEZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjYXNlcykpIHtcbiAgICBjYXNlcyA9IFtjYXNlc107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgfVxuICBjYXNlcy5mb3JFYWNoKChjKSA9PiByZWdpc3RyeS5zZXQoYywgaW1wb3J0Rm4pKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlY29kZXIoZmlsZURpcmVjdG9yeSkge1xuICBjb25zdCBpbXBvcnRGbiA9IHJlZ2lzdHJ5LmdldChmaWxlRGlyZWN0b3J5LkNvbXByZXNzaW9uKTtcbiAgaWYgKCFpbXBvcnRGbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QgaWRlbnRpZmllcjogJHtmaWxlRGlyZWN0b3J5LkNvbXByZXNzaW9ufWApO1xuICB9XG4gIGNvbnN0IERlY29kZXIgPSBhd2FpdCBpbXBvcnRGbigpO1xuICByZXR1cm4gbmV3IERlY29kZXIoZmlsZURpcmVjdG9yeSk7XG59XG5cbi8vIEFkZCBkZWZhdWx0IGRlY29kZXJzIHRvIHJlZ2lzdHJ5IChlbmQtdXNlciBtYXkgb3ZlcnJpZGUgd2l0aCBvdGhlciBpbXBsZW1lbnRhdGlvbnMpXG5hZGREZWNvZGVyKFt1bmRlZmluZWQsIDFdLCAoKSA9PiBpbXBvcnQoJy4vcmF3LmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDUsICgpID0+IGltcG9ydCgnLi9sencuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoNiwgKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ29sZCBzdHlsZSBKUEVHIGNvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG59KTtcbmFkZERlY29kZXIoNywgKCkgPT4gaW1wb3J0KCcuL2pwZWcuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoWzgsIDMyOTQ2XSwgKCkgPT4gaW1wb3J0KCcuL2RlZmxhdGUuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoMzI3NzMsICgpID0+IGltcG9ydCgnLi9wYWNrYml0cy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2RlcigzNDg4NywgKCkgPT4gaW1wb3J0KCcuL2xlcmMuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoNTAwMDEsICgpID0+IGltcG9ydCgnLi93ZWJpbWFnZS5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/compression/index.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/dataslice.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataslice.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataSlice)\n/* harmony export */ });\nclass DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhc2xpY2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2RhdGFzbGljZS5qcz9iNzNkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFTbGljZSB7XG4gIGNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLCBzbGljZU9mZnNldCwgbGl0dGxlRW5kaWFuLCBiaWdUaWZmKSB7XG4gICAgdGhpcy5fZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgIHRoaXMuX3NsaWNlT2Zmc2V0ID0gc2xpY2VPZmZzZXQ7XG4gICAgdGhpcy5fbGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuO1xuICAgIHRoaXMuX2JpZ1RpZmYgPSBiaWdUaWZmO1xuICB9XG5cbiAgZ2V0IHNsaWNlT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9zbGljZU9mZnNldDtcbiAgfVxuXG4gIGdldCBzbGljZVRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpY2VPZmZzZXQgKyB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgZ2V0IGxpdHRsZUVuZGlhbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGl0dGxlRW5kaWFuO1xuICB9XG5cbiAgZ2V0IGJpZ1RpZmYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpZ1RpZmY7XG4gIH1cblxuICBnZXQgYnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5idWZmZXI7XG4gIH1cblxuICBjb3ZlcnMob2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZU9mZnNldCA8PSBvZmZzZXQgJiYgdGhpcy5zbGljZVRvcCA+PSBvZmZzZXQgKyBsZW5ndGg7XG4gIH1cblxuICByZWFkVWludDgob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEludDgob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDgoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkVWludDE2KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MTYoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkSW50MTYob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDE2KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZFVpbnQzMihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDMyKFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEludDMyKG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQzMihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRGbG9hdDMyKG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDMyKFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEZsb2F0NjQob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0NjQoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkVWludDY0KG9mZnNldCkge1xuICAgIGNvbnN0IGxlZnQgPSB0aGlzLnJlYWRVaW50MzIob2Zmc2V0KTtcbiAgICBjb25zdCByaWdodCA9IHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KTtcbiAgICBsZXQgY29tYmluZWQ7XG4gICAgaWYgKHRoaXMuX2xpdHRsZUVuZGlhbikge1xuICAgICAgY29tYmluZWQgPSBsZWZ0ICsgKCgyICoqIDMyKSAqIHJpZ2h0KTtcbiAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoY29tYmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtjb21iaW5lZH0gZXhjZWVkcyBNQVhfU0FGRV9JTlRFR0VSLiBgXG4gICAgICAgICAgKyAnUHJlY2lzaW9uIG1heSBiZSBsb3N0LiBQbGVhc2UgcmVwb3J0IGlmIHlvdSBnZXQgdGhpcyBtZXNzYWdlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9nZW90aWZmanMvZ2VvdGlmZi5qcy9pc3N1ZXMnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH1cbiAgICBjb21iaW5lZCA9ICgoMiAqKiAzMikgKiBsZWZ0KSArIHJpZ2h0O1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoY29tYmluZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgKyAnUHJlY2lzaW9uIG1heSBiZSBsb3N0LiBQbGVhc2UgcmVwb3J0IGlmIHlvdSBnZXQgdGhpcyBtZXNzYWdlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9nZW90aWZmanMvZ2VvdGlmZi5qcy9pc3N1ZXMnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tYmluZWQ7XG4gIH1cblxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU1MzM4Mzg0LzgwNjA1OTFcbiAgcmVhZEludDY0KG9mZnNldCkge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9ICh0aGlzLl9kYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAodGhpcy5fbGl0dGxlRW5kaWFuID8gNyA6IDApKSAmIDB4ODApXG4gICAgICA+IDA7XG4gICAgbGV0IGNhcnJ5aW5nID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgbGV0IGJ5dGUgPSB0aGlzLl9kYXRhVmlldy5nZXRVaW50OChcbiAgICAgICAgb2Zmc2V0ICsgKHRoaXMuX2xpdHRsZUVuZGlhbiA/IGkgOiA3IC0gaSksXG4gICAgICApO1xuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgaWYgKGNhcnJ5aW5nKSB7XG4gICAgICAgICAgaWYgKGJ5dGUgIT09IDB4MDApIHtcbiAgICAgICAgICAgIGJ5dGUgPSB+KGJ5dGUgLSAxKSAmIDB4ZmY7XG4gICAgICAgICAgICBjYXJyeWluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBieXRlID0gfmJ5dGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSBieXRlICogKDI1NiAqKiBpKTtcbiAgICB9XG4gICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZWFkT2Zmc2V0KG9mZnNldCkge1xuICAgIGlmICh0aGlzLl9iaWdUaWZmKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkVWludDY0KG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlYWRVaW50MzIob2Zmc2V0KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/dataslice.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/dataview64.js":
/*!********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataview64.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataView64)\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ \"./node_modules/@petamoriken/float16/src/DataView.mjs\");\n\n\nclass DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__.getFloat16)(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhdmlldzY0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtEOztBQUVuQztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0VBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2RhdGF2aWV3NjQuanM/MjI2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRGbG9hdDE2IH0gZnJvbSAnQHBldGFtb3Jpa2VuL2Zsb2F0MTYnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhVmlldzY0IHtcbiAgY29uc3RydWN0b3IoYXJyYXlCdWZmZXIpIHtcbiAgICB0aGlzLl9kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIH1cblxuICBnZXQgYnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5idWZmZXI7XG4gIH1cblxuICBnZXRVaW50NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5nZXRVaW50MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5nZXRVaW50MzIob2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuKTtcbiAgICBsZXQgY29tYmluZWQ7XG4gICAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgICAgY29tYmluZWQgPSBsZWZ0ICsgKCgyICoqIDMyKSAqIHJpZ2h0KTtcbiAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoY29tYmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtjb21iaW5lZH0gZXhjZWVkcyBNQVhfU0FGRV9JTlRFR0VSLiBgXG4gICAgICAgICAgKyAnUHJlY2lzaW9uIG1heSBiZSBsb3N0LiBQbGVhc2UgcmVwb3J0IGlmIHlvdSBnZXQgdGhpcyBtZXNzYWdlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9nZW90aWZmanMvZ2VvdGlmZi5qcy9pc3N1ZXMnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH1cbiAgICBjb21iaW5lZCA9ICgoMiAqKiAzMikgKiBsZWZ0KSArIHJpZ2h0O1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoY29tYmluZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgKyAnUHJlY2lzaW9uIG1heSBiZSBsb3N0LiBQbGVhc2UgcmVwb3J0IGlmIHlvdSBnZXQgdGhpcyBtZXNzYWdlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9nZW90aWZmanMvZ2VvdGlmZi5qcy9pc3N1ZXMnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tYmluZWQ7XG4gIH1cblxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU1MzM4Mzg0LzgwNjA1OTFcbiAgZ2V0SW50NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAodGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgKGxpdHRsZUVuZGlhbiA/IDcgOiAwKSkgJiAweDgwKSA+IDA7XG4gICAgbGV0IGNhcnJ5aW5nID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgbGV0IGJ5dGUgPSB0aGlzLl9kYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAobGl0dGxlRW5kaWFuID8gaSA6IDcgLSBpKSk7XG4gICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICBpZiAoY2FycnlpbmcpIHtcbiAgICAgICAgICBpZiAoYnl0ZSAhPT0gMHgwMCkge1xuICAgICAgICAgICAgYnl0ZSA9IH4oYnl0ZSAtIDEpICYgMHhmZjtcbiAgICAgICAgICAgIGNhcnJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGUgPSB+Ynl0ZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IGJ5dGUgKiAoMjU2ICoqIGkpO1xuICAgIH1cbiAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGdldFVpbnQ4KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRVaW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEludDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0RmxvYXQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiBnZXRGbG9hdDE2KHRoaXMuX2RhdGFWaWV3LCBvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0RmxvYXQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/dataview64.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiff.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiff.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseDecoder\": () => (/* reexport safe */ _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"GeoTIFF\": () => (/* binding */ GeoTIFF),\n/* harmony export */   \"GeoTIFFImage\": () => (/* reexport safe */ _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   \"MultiGeoTIFF\": () => (/* binding */ MultiGeoTIFF),\n/* harmony export */   \"Pool\": () => (/* reexport safe */ _pool_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]),\n/* harmony export */   \"addDecoder\": () => (/* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.addDecoder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"fromArrayBuffer\": () => (/* binding */ fromArrayBuffer),\n/* harmony export */   \"fromBlob\": () => (/* binding */ fromBlob),\n/* harmony export */   \"fromFile\": () => (/* binding */ fromFile),\n/* harmony export */   \"fromUrl\": () => (/* binding */ fromUrl),\n/* harmony export */   \"fromUrls\": () => (/* binding */ fromUrls),\n/* harmony export */   \"getDecoder\": () => (/* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.getDecoder),\n/* harmony export */   \"globals\": () => (/* reexport module object */ _globals_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"rgb\": () => (/* reexport module object */ _rgb_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   \"setLogger\": () => (/* reexport safe */ _logging_js__WEBPACK_IMPORTED_MODULE_4__.setLogger),\n/* harmony export */   \"writeArrayBuffer\": () => (/* binding */ writeArrayBuffer)\n/* harmony export */ });\n/* harmony import */ var _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geotiffimage.js */ \"./node_modules/geotiff/dist-module/geotiffimage.js\");\n/* harmony import */ var _dataview64_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataview64.js */ \"./node_modules/geotiff/dist-module/dataview64.js\");\n/* harmony import */ var _dataslice_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataslice.js */ \"./node_modules/geotiff/dist-module/dataslice.js\");\n/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pool.js */ \"./node_modules/geotiff/dist-module/pool.js\");\n/* harmony import */ var _source_remote_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/remote.js */ \"./node_modules/geotiff/dist-module/source/remote.js\");\n/* harmony import */ var _source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/arraybuffer.js */ \"./node_modules/geotiff/dist-module/source/arraybuffer.js\");\n/* harmony import */ var _source_filereader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./source/filereader.js */ \"./node_modules/geotiff/dist-module/source/filereader.js\");\n/* harmony import */ var _source_file_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/file.js */ \"./node_modules/geotiff/dist-module/source/file.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./geotiffwriter.js */ \"./node_modules/geotiff/dist-module/geotiffwriter.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ \"./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging.js */ \"./node_modules/geotiff/dist-module/logging.js\");\n/* harmony import */ var _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression/basedecoder.js */ \"./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/** @module geotiff */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      return 1;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      return 2;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      return 4;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = _globals_js__WEBPACK_IMPORTED_MODULE_0__.geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new _dataslice_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && _globals_js__WEBPACK_IMPORTED_MODULE_0__.arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new _dataview64_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoTIFF);\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\n\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource((0,_source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__.makeBufferSource)(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromFile(path, signal) {\n  return GeoTIFF.fromSource((0,_source_file_js__WEBPACK_IMPORTED_MODULE_10__.makeFileSource)(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource((0,_source_filereader_js__WEBPACK_IMPORTED_MODULE_11__.makeFileReaderSource)(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nasync function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction writeArrayBuffer(values, metadata) {\n  return (0,_geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__.writeGeotiff)(values, metadata);\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM2QztBQUNKO0FBQ0Y7QUFDVjs7QUFFeUI7QUFDSztBQUNHO0FBQ1o7O0FBRWlDO0FBQ2pDO0FBQ1Y7QUFDUjtBQUNnQztBQUN2Qjs7QUFFdEI7QUFDSjtBQUN1RDtBQUNwQztBQUNiOztBQUVyQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHdEQUFlLE9BQU8seURBQWdCLE9BQU8seURBQWdCLE9BQU8sNkRBQW9CO0FBQ2pHO0FBQ0EsU0FBUyx5REFBZ0IsT0FBTywwREFBaUI7QUFDakQ7QUFDQSxTQUFTLHdEQUFlLE9BQU8seURBQWdCLE9BQU8seURBQWdCLE9BQU8sdURBQWM7QUFDM0Y7QUFDQSxTQUFTLDREQUFtQixPQUFPLDZEQUFvQixPQUFPLDBEQUFpQjtBQUMvRSxTQUFTLHlEQUFnQixPQUFPLDBEQUFpQixPQUFPLHdEQUFlO0FBQ3ZFO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xELGdCQUFnQixvREFBVztBQUMzQjtBQUNBLFNBQVMsc0RBQWE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBEQUEwRCxJQUFJO0FBQzlELFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsd0RBQWUsT0FBTyx5REFBZ0IsT0FBTyw2REFBb0I7QUFDMUUsc0NBQXNDO0FBQ3RDO0FBQ0EsU0FBUyx5REFBZ0I7QUFDekIscUNBQXFDO0FBQ3JDO0FBQ0EsU0FBUyx5REFBZ0I7QUFDekIsdUNBQXVDO0FBQ3ZDO0FBQ0EsU0FBUywwREFBaUI7QUFDMUIsc0NBQXNDO0FBQ3RDO0FBQ0EsU0FBUyx3REFBZSxPQUFPLHVEQUFjO0FBQzdDLHVDQUF1QztBQUN2QztBQUNBLFNBQVMseURBQWdCO0FBQ3pCLHNDQUFzQztBQUN0QztBQUNBLFNBQVMseURBQWdCLE9BQU8sd0RBQWU7QUFDL0MsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUywwREFBaUI7QUFDMUIsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUyw0REFBbUI7QUFDNUIsMkNBQTJDO0FBQzNDO0FBQ0EsU0FBUyw2REFBb0I7QUFDN0IsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUyx5REFBZ0I7QUFDekIsd0NBQXdDO0FBQ3hDO0FBQ0EsU0FBUywwREFBaUI7QUFDMUIsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDs7QUFFQTtBQUNBLHNCQUFzQiw0REFBbUIsa0JBQWtCLDZEQUFvQjtBQUMvRSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHlEQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBLGFBQWEsNENBQTRDLFdBQVc7QUFDcEUsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQSxnQ0FBZ0M7QUFDaEMsWUFBWSxxQ0FBcUM7QUFDakQsVUFBVSxtQkFBbUI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0EsZ0JBQWdCLDJEQUEyRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsNERBQW1CO0FBQ2hELDJCQUEyQiw0REFBbUIsa0JBQWtCLDZEQUFvQjtBQUNwRjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlEQUFnQjtBQUM3RCw0Q0FBNEMseURBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseURBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkUseUJBQXlCLHNEQUFVOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUI7QUFDbkIsaUVBQWUsT0FBTyxFQUFDOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3Qjs7QUFFeEI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsa0NBQWtDLHdCQUF3QjtBQUMxRCxXQUFXLGFBQWE7QUFDeEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPLHdDQUF3QztBQUMvQyw0QkFBNEIsbUVBQWdCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUdBQW1HO0FBQ3BILFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPO0FBQ1AsNEJBQTRCLHdFQUFnQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPO0FBQ1AsNEJBQTRCLGdFQUFjO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDZEQUE2RDtBQUN2RSxVQUFVO0FBQ1Y7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDTztBQUNQLDRCQUE0Qiw0RUFBb0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLG9EQUFvRDtBQUNwRDtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ08sZ0VBQWdFO0FBQ3ZFLDRDQUE0QyxtRUFBZ0I7QUFDNUQ7QUFDQSxpREFBaUQsbUVBQWdCO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFVBQVU7QUFDdkI7QUFDTztBQUNQLFNBQVMsZ0VBQVk7QUFDckI7O0FBRWdCO0FBQ1EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZi5qcz84MjdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbW9kdWxlIGdlb3RpZmYgKi9cbmltcG9ydCBHZW9USUZGSW1hZ2UgZnJvbSAnLi9nZW90aWZmaW1hZ2UuanMnO1xuaW1wb3J0IERhdGFWaWV3NjQgZnJvbSAnLi9kYXRhdmlldzY0LmpzJztcbmltcG9ydCBEYXRhU2xpY2UgZnJvbSAnLi9kYXRhc2xpY2UuanMnO1xuaW1wb3J0IFBvb2wgZnJvbSAnLi9wb29sLmpzJztcblxuaW1wb3J0IHsgbWFrZVJlbW90ZVNvdXJjZSB9IGZyb20gJy4vc291cmNlL3JlbW90ZS5qcyc7XG5pbXBvcnQgeyBtYWtlQnVmZmVyU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvYXJyYXlidWZmZXIuanMnO1xuaW1wb3J0IHsgbWFrZUZpbGVSZWFkZXJTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9maWxlcmVhZGVyLmpzJztcbmltcG9ydCB7IG1ha2VGaWxlU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvZmlsZS5qcyc7XG5cbmltcG9ydCB7IGZpZWxkVHlwZXMsIGZpZWxkVGFnTmFtZXMsIGFycmF5RmllbGRzLCBnZW9LZXlOYW1lcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyB3cml0ZUdlb3RpZmYgfSBmcm9tICcuL2dlb3RpZmZ3cml0ZXIuanMnO1xuaW1wb3J0ICogYXMgZ2xvYmFscyBmcm9tICcuL2dsb2JhbHMuanMnO1xuaW1wb3J0ICogYXMgcmdiIGZyb20gJy4vcmdiLmpzJztcbmltcG9ydCB7IGdldERlY29kZXIsIGFkZERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcbmltcG9ydCB7IHNldExvZ2dlciB9IGZyb20gJy4vbG9nZ2luZy5qcyc7XG5cbmV4cG9ydCB7IGdsb2JhbHMgfTtcbmV4cG9ydCB7IHJnYiB9O1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXNlRGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vYmFzZWRlY29kZXIuanMnO1xuZXhwb3J0IHsgZ2V0RGVjb2RlciwgYWRkRGVjb2RlciB9O1xuZXhwb3J0IHsgc2V0TG9nZ2VyIH07XG5cbi8qKlxuICogQHR5cGVkZWYge1VpbnQ4QXJyYXkgfCBJbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDMyQXJyYXkgfCBGbG9hdDMyQXJyYXkgfCBGbG9hdDY0QXJyYXl9XG4gKiBUeXBlZEFycmF5XG4gKi9cblxuZnVuY3Rpb24gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSkge1xuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgIGNhc2UgZmllbGRUeXBlcy5CWVRFOiBjYXNlIGZpZWxkVHlwZXMuQVNDSUk6IGNhc2UgZmllbGRUeXBlcy5TQllURTogY2FzZSBmaWVsZFR5cGVzLlVOREVGSU5FRDpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TSE9SVDogY2FzZSBmaWVsZFR5cGVzLlNTSE9SVDpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgZmllbGRUeXBlcy5MT05HOiBjYXNlIGZpZWxkVHlwZXMuU0xPTkc6IGNhc2UgZmllbGRUeXBlcy5GTE9BVDogY2FzZSBmaWVsZFR5cGVzLklGRDpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgZmllbGRUeXBlcy5SQVRJT05BTDogY2FzZSBmaWVsZFR5cGVzLlNSQVRJT05BTDogY2FzZSBmaWVsZFR5cGVzLkRPVUJMRTpcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5TTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5JRkQ4OlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGZpZWxkIHR5cGU6ICR7ZmllbGRUeXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlR2VvS2V5RGlyZWN0b3J5KGZpbGVEaXJlY3RvcnkpIHtcbiAgY29uc3QgcmF3R2VvS2V5RGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeS5HZW9LZXlEaXJlY3Rvcnk7XG4gIGlmICghcmF3R2VvS2V5RGlyZWN0b3J5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBnZW9LZXlEaXJlY3RvcnkgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDQ7IGkgPD0gcmF3R2VvS2V5RGlyZWN0b3J5WzNdICogNDsgaSArPSA0KSB7XG4gICAgY29uc3Qga2V5ID0gZ2VvS2V5TmFtZXNbcmF3R2VvS2V5RGlyZWN0b3J5W2ldXTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IChyYXdHZW9LZXlEaXJlY3RvcnlbaSArIDFdKVxuICAgICAgPyAoZmllbGRUYWdOYW1lc1tyYXdHZW9LZXlEaXJlY3RvcnlbaSArIDFdXSkgOiBudWxsO1xuICAgIGNvbnN0IGNvdW50ID0gcmF3R2VvS2V5RGlyZWN0b3J5W2kgKyAyXTtcbiAgICBjb25zdCBvZmZzZXQgPSByYXdHZW9LZXlEaXJlY3RvcnlbaSArIDNdO1xuXG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICB2YWx1ZSA9IG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBmaWxlRGlyZWN0b3J5W2xvY2F0aW9uXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCB2YWx1ZSBvZiBnZW9LZXkgJyR7a2V5fScuYCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCAtIDEpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5zdWJhcnJheSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgY291bnQpO1xuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdlb0tleURpcmVjdG9yeVtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdlb0tleURpcmVjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCBjb3VudCwgb2Zmc2V0KSB7XG4gIGxldCB2YWx1ZXMgPSBudWxsO1xuICBsZXQgcmVhZE1ldGhvZCA9IG51bGw7XG4gIGNvbnN0IGZpZWxkVHlwZUxlbmd0aCA9IGdldEZpZWxkVHlwZUxlbmd0aChmaWVsZFR5cGUpO1xuXG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkJZVEU6IGNhc2UgZmllbGRUeXBlcy5BU0NJSTogY2FzZSBmaWVsZFR5cGVzLlVOREVGSU5FRDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU0JZVEU6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50OEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TSE9SVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MTZBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQxNjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TU0hPUlQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MTZBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDE2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc6IGNhc2UgZmllbGRUeXBlcy5JRkQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU0xPTkc6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc4OiBjYXNlIGZpZWxkVHlwZXMuSUZEODpcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TTE9ORzg6XG4gICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5SQVRJT05BTDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShjb3VudCAqIDIpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU1JBVElPTkFMOlxuICAgICAgdmFsdWVzID0gbmV3IEludDMyQXJyYXkoY291bnQgKiAyKTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuRkxPQVQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkRmxvYXQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5ET1VCTEU6XG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQ2NEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkRmxvYXQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBmaWVsZCB0eXBlOiAke2ZpZWxkVHlwZX1gKTtcbiAgfVxuXG4gIC8vIG5vcm1hbCBmaWVsZHNcbiAgaWYgKCEoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlJBVElPTkFMIHx8IGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5TUkFUSU9OQUwpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKGkgKiBmaWVsZFR5cGVMZW5ndGgpLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIFJBVElPTkFMIG9yIFNSQVRJT05BTFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMikge1xuICAgICAgdmFsdWVzW2ldID0gcmVhZE1ldGhvZC5jYWxsKFxuICAgICAgICBkYXRhU2xpY2UsIG9mZnNldCArIChpICogZmllbGRUeXBlTGVuZ3RoKSxcbiAgICAgICk7XG4gICAgICB2YWx1ZXNbaSArIDFdID0gcmVhZE1ldGhvZC5jYWxsKFxuICAgICAgICBkYXRhU2xpY2UsIG9mZnNldCArICgoaSAqIGZpZWxkVHlwZUxlbmd0aCkgKyA0KSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5BU0NJSSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JykuZGVjb2RlKHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBEYXRhIGNsYXNzIHRvIHN0b3JlIHRoZSBwYXJzZWQgZmlsZSBkaXJlY3RvcnksIGdlbyBrZXkgZGlyZWN0b3J5IGFuZFxuICogb2Zmc2V0IHRvIHRoZSBuZXh0IElGRFxuICovXG5jbGFzcyBJbWFnZUZpbGVEaXJlY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5LCBnZW9LZXlEaXJlY3RvcnksIG5leHRJRkRCeXRlT2Zmc2V0KSB7XG4gICAgdGhpcy5maWxlRGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeTtcbiAgICB0aGlzLmdlb0tleURpcmVjdG9yeSA9IGdlb0tleURpcmVjdG9yeTtcbiAgICB0aGlzLm5leHRJRkRCeXRlT2Zmc2V0ID0gbmV4dElGREJ5dGVPZmZzZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciBjbGFzcyBmb3IgY2FzZXMgd2hlbiBhbiBJRkQgaW5kZXggd2FzIHJlcXVlc3RlZCwgdGhhdCBkb2VzIG5vdCBleGlzdFxuICogaW4gdGhlIGZpbGUuXG4gKi9cbmNsYXNzIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZGV4KSB7XG4gICAgc3VwZXIoYE5vIGltYWdlIGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59XG5cbmNsYXNzIEdlb1RJRkZCYXNlIHtcbiAgLyoqXG4gICAqIChleHBlcmltZW50YWwpIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGJlc3QgZml0dGluZyBpbWFnZS4gVGhpcyBmdW5jdGlvbiB1c2VzXG4gICAqIHRoZSBpbWFnZSB3aXRoIHRoZSBsb3dlc3QgcmVzb2x1dGlvbiB0aGF0IGlzIHN0aWxsIGEgaGlnaGVyIHJlc29sdXRpb24gdGhhbiB0aGVcbiAgICogcmVxdWVzdGVkIHJlc29sdXRpb24uXG4gICAqIFdoZW4gc3BlY2lmaWVkLCB0aGUgYGJib3hgIG9wdGlvbiBpcyB0cmFuc2xhdGVkIHRvIHRoZSBgd2luZG93YCBvcHRpb24gYW5kIHRoZVxuICAgKiBgcmVzWGAgYW5kIGByZXNZYCB0byBgd2lkdGhgIGFuZCBgaGVpZ2h0YCByZXNwZWN0aXZlbHkuXG4gICAqIFRoZW4sIHRoZSBbcmVhZFJhc3RlcnNde0BsaW5rIEdlb1RJRkZJbWFnZSNyZWFkUmFzdGVyc30gbWV0aG9kIG9mIHRoZSBzZWxlY3RlZFxuICAgKiBpbWFnZSBpcyBjYWxsZWQgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXG4gICAqIEBzZWUgR2VvVElGRkltYWdlLnJlYWRSYXN0ZXJzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2dlb3RpZmZpbWFnZScpLlJlYWRSYXN0ZXJPcHRpb25zfSBbb3B0aW9ucz17fV0gb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTwoVHlwZWRBcnJheXxUeXBlZEFycmF5W10pPn0gdGhlIGRlY29kZWQgYXJyYXlzIGFzIGEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVhZFJhc3RlcnMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyB3aW5kb3c6IGltYWdlV2luZG93LCB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zO1xuICAgIGxldCB7IHJlc1gsIHJlc1ksIGJib3ggfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBmaXJzdEltYWdlID0gYXdhaXQgdGhpcy5nZXRJbWFnZSgpO1xuICAgIGxldCB1c2VkSW1hZ2UgPSBmaXJzdEltYWdlO1xuICAgIGNvbnN0IGltYWdlQ291bnQgPSBhd2FpdCB0aGlzLmdldEltYWdlQ291bnQoKTtcbiAgICBjb25zdCBpbWdCQm94ID0gZmlyc3RJbWFnZS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgaWYgKGltYWdlV2luZG93ICYmIGJib3gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBcImJib3hcIiBhbmQgXCJ3aW5kb3dcIiBwYXNzZWQuJyk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2lkdGgvaGVpZ2h0IGlzIHBhc3NlZCwgdHJhbnNmb3JtIGl0IHRvIHJlc29sdXRpb25cbiAgICBpZiAod2lkdGggfHwgaGVpZ2h0KSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGFuIGltYWdlIHdpbmRvdyAocGl4ZWwgY29vcmRpbmF0ZXMpLCB0cmFuc2Zvcm0gaXQgdG8gYSBCQm94XG4gICAgICAvLyB1c2luZyB0aGUgb3JpZ2luL3Jlc29sdXRpb24gb2YgdGhlIGZpcnN0IGltYWdlLlxuICAgICAgaWYgKGltYWdlV2luZG93KSB7XG4gICAgICAgIGNvbnN0IFtvWCwgb1ldID0gZmlyc3RJbWFnZS5nZXRPcmlnaW4oKTtcbiAgICAgICAgY29uc3QgW3JYLCByWV0gPSBmaXJzdEltYWdlLmdldFJlc29sdXRpb24oKTtcblxuICAgICAgICBiYm94ID0gW1xuICAgICAgICAgIG9YICsgKGltYWdlV2luZG93WzBdICogclgpLFxuICAgICAgICAgIG9ZICsgKGltYWdlV2luZG93WzFdICogclkpLFxuICAgICAgICAgIG9YICsgKGltYWdlV2luZG93WzJdICogclgpLFxuICAgICAgICAgIG9ZICsgKGltYWdlV2luZG93WzNdICogclkpLFxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgYmJveCAob3IgY2FsY3VsYXRlZCBvbmUpXG5cbiAgICAgIGNvbnN0IHVzZWRCQm94ID0gYmJveCB8fCBpbWdCQm94O1xuXG4gICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgaWYgKHJlc1gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggd2lkdGggYW5kIHJlc1ggcGFzc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzWCA9ICh1c2VkQkJveFsyXSAtIHVzZWRCQm94WzBdKSAvIHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICBpZiAocmVzWSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCB3aWR0aCBhbmQgcmVzWSBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNZID0gKHVzZWRCQm94WzNdIC0gdXNlZEJCb3hbMV0pIC8gaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHJlc29sdXRpb24gaXMgc2V0IG9yIGNhbGN1bGF0ZWQsIHRyeSB0byBnZXQgdGhlIGltYWdlIHdpdGggdGhlIHdvcnN0IGFjY2VwdGFibGUgcmVzb2x1dGlvblxuICAgIGlmIChyZXNYIHx8IHJlc1kpIHtcbiAgICAgIGNvbnN0IGFsbEltYWdlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZUNvdW50OyArK2kpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLmdldEltYWdlKGkpO1xuICAgICAgICBjb25zdCB7IFN1YmZpbGVUeXBlOiBzdWJmaWxlVHlwZSwgTmV3U3ViZmlsZVR5cGU6IG5ld1N1YmZpbGVUeXBlIH0gPSBpbWFnZS5maWxlRGlyZWN0b3J5O1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCBzdWJmaWxlVHlwZSA9PT0gMiB8fCBuZXdTdWJmaWxlVHlwZSAmIDEpIHtcbiAgICAgICAgICBhbGxJbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWxsSW1hZ2VzLnNvcnQoKGEsIGIpID0+IGEuZ2V0V2lkdGgoKSAtIGIuZ2V0V2lkdGgoKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEltYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGFsbEltYWdlc1tpXTtcbiAgICAgICAgY29uc3QgaW1nUmVzWCA9IChpbWdCQm94WzJdIC0gaW1nQkJveFswXSkgLyBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICBjb25zdCBpbWdSZXNZID0gKGltZ0JCb3hbM10gLSBpbWdCQm94WzFdKSAvIGltYWdlLmdldEhlaWdodCgpO1xuXG4gICAgICAgIHVzZWRJbWFnZSA9IGltYWdlO1xuICAgICAgICBpZiAoKHJlc1ggJiYgcmVzWCA+IGltZ1Jlc1gpIHx8IChyZXNZICYmIHJlc1kgPiBpbWdSZXNZKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHduZCA9IGltYWdlV2luZG93O1xuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCBbb1gsIG9ZXSA9IGZpcnN0SW1hZ2UuZ2V0T3JpZ2luKCk7XG4gICAgICBjb25zdCBbaW1hZ2VSZXNYLCBpbWFnZVJlc1ldID0gdXNlZEltYWdlLmdldFJlc29sdXRpb24oZmlyc3RJbWFnZSk7XG5cbiAgICAgIHduZCA9IFtcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFswXSAtIG9YKSAvIGltYWdlUmVzWCksXG4gICAgICAgIE1hdGgucm91bmQoKGJib3hbMV0gLSBvWSkgLyBpbWFnZVJlc1kpLFxuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzJdIC0gb1gpIC8gaW1hZ2VSZXNYKSxcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFszXSAtIG9ZKSAvIGltYWdlUmVzWSksXG4gICAgICBdO1xuICAgICAgd25kID0gW1xuICAgICAgICBNYXRoLm1pbih3bmRbMF0sIHduZFsyXSksXG4gICAgICAgIE1hdGgubWluKHduZFsxXSwgd25kWzNdKSxcbiAgICAgICAgTWF0aC5tYXgod25kWzBdLCB3bmRbMl0pLFxuICAgICAgICBNYXRoLm1heCh3bmRbMV0sIHduZFszXSksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB1c2VkSW1hZ2UucmVhZFJhc3RlcnMoeyAuLi5vcHRpb25zLCB3aW5kb3c6IHduZCB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdlb1RJRkZPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjYWNoZT1mYWxzZV0gd2hldGhlciBvciBub3QgZGVjb2RlZCB0aWxlcyBzaGFsbCBiZSBjYWNoZWQuXG4gKi9cblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Rpb24gZm9yIGEgd2hvbGUgR2VvVElGRiBmaWxlLlxuICogQGF1Z21lbnRzIEdlb1RJRkZCYXNlXG4gKi9cbmNsYXNzIEdlb1RJRkYgZXh0ZW5kcyBHZW9USUZGQmFzZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgVGhlIGRhdGFzb3VyY2UgdG8gcmVhZCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRoZSBpbWFnZSB1c2VzIGxpdHRsZSBlbmRpYW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmlnVGlmZiBXaGV0aGVyIHRoZSBpbWFnZSB1c2VzIGJpZ1RJRkYgY29udmVudGlvbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdElGRE9mZnNldCBUaGUgbnVtZXJpYyBieXRlLW9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgaW1hZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBmaXJzdCBJRkQuXG4gICAqIEBwYXJhbSB7R2VvVElGRk9wdGlvbnN9IFtvcHRpb25zXSBmdXJ0aGVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZiwgZmlyc3RJRkRPZmZzZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XG4gICAgdGhpcy5iaWdUaWZmID0gYmlnVGlmZjtcbiAgICB0aGlzLmZpcnN0SUZET2Zmc2V0ID0gZmlyc3RJRkRPZmZzZXQ7XG4gICAgdGhpcy5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgZmFsc2U7XG4gICAgdGhpcy5pZmRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuZ2hvc3RWYWx1ZXMgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0U2xpY2Uob2Zmc2V0LCBzaXplKSB7XG4gICAgY29uc3QgZmFsbGJhY2tTaXplID0gdGhpcy5iaWdUaWZmID8gNDA0OCA6IDEwMjQ7XG4gICAgcmV0dXJuIG5ldyBEYXRhU2xpY2UoXG4gICAgICAoYXdhaXQgdGhpcy5zb3VyY2UuZmV0Y2goW3tcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsZW5ndGg6IHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJyA/IHNpemUgOiBmYWxsYmFja1NpemUsXG4gICAgICB9XSkpWzBdLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGhpcy5saXR0bGVFbmRpYW4sXG4gICAgICB0aGlzLmJpZ1RpZmYsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0cnVjdHMgdG8gcGFyc2UgYW4gaW1hZ2UgZmlsZSBkaXJlY3RvcnkgYXQgdGhlIGdpdmVuIGZpbGUgb2Zmc2V0LlxuICAgKiBBcyB0aGVyZSBpcyBubyB3YXkgdG8gZW5zdXJlIHRoYXQgYSBsb2NhdGlvbiBpcyBpbmRlZWQgdGhlIHN0YXJ0IG9mIGFuIElGRCxcbiAgICogdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCB3aXRoIGNhdXRpb24gKGUuZyBvbmx5IHVzaW5nIHRoZSBJRkQgb2Zmc2V0cyBmcm9tXG4gICAqIHRoZSBoZWFkZXJzIG9yIG90aGVyIElGRHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgdG8gcGFyc2UgdGhlIElGRCBhdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbWFnZUZpbGVEaXJlY3Rvcnk+fSB0aGUgcGFyc2VkIElGRFxuICAgKi9cbiAgYXN5bmMgcGFyc2VGaWxlRGlyZWN0b3J5QXQob2Zmc2V0KSB7XG4gICAgY29uc3QgZW50cnlTaXplID0gdGhpcy5iaWdUaWZmID8gMjAgOiAxMjtcbiAgICBjb25zdCBvZmZzZXRTaXplID0gdGhpcy5iaWdUaWZmID8gOCA6IDI7XG5cbiAgICBsZXQgZGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IG51bURpckVudHJpZXMgPSB0aGlzLmJpZ1RpZmZcbiAgICAgID8gZGF0YVNsaWNlLnJlYWRVaW50NjQob2Zmc2V0KVxuICAgICAgOiBkYXRhU2xpY2UucmVhZFVpbnQxNihvZmZzZXQpO1xuXG4gICAgLy8gaWYgdGhlIHNsaWNlIGRvZXMgbm90IGNvdmVyIHRoZSB3aG9sZSBJRkQsIHJlcXVlc3QgYSBiaWdnZXIgc2xpY2UsIHdoZXJlIHRoZVxuICAgIC8vIHdob2xlIElGRCBmaXRzOiBudW0gb2YgZW50cmllcyArIG4geCB0YWcgbGVuZ3RoICsgb2Zmc2V0IHRvIG5leHQgSUZEXG4gICAgY29uc3QgYnl0ZVNpemUgPSAobnVtRGlyRW50cmllcyAqIGVudHJ5U2l6ZSkgKyAodGhpcy5iaWdUaWZmID8gMTYgOiA2KTtcbiAgICBpZiAoIWRhdGFTbGljZS5jb3ZlcnMob2Zmc2V0LCBieXRlU2l6ZSkpIHtcbiAgICAgIGRhdGFTbGljZSA9IGF3YWl0IHRoaXMuZ2V0U2xpY2Uob2Zmc2V0LCBieXRlU2l6ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZURpcmVjdG9yeSA9IHt9O1xuXG4gICAgLy8gbG9vcCBvdmVyIHRoZSBJRkQgYW5kIGNyZWF0ZSBhIGZpbGUgZGlyZWN0b3J5IG9iamVjdFxuICAgIGxldCBpID0gb2Zmc2V0ICsgKHRoaXMuYmlnVGlmZiA/IDggOiAyKTtcbiAgICBmb3IgKGxldCBlbnRyeUNvdW50ID0gMDsgZW50cnlDb3VudCA8IG51bURpckVudHJpZXM7IGkgKz0gZW50cnlTaXplLCArK2VudHJ5Q291bnQpIHtcbiAgICAgIGNvbnN0IGZpZWxkVGFnID0gZGF0YVNsaWNlLnJlYWRVaW50MTYoaSk7XG4gICAgICBjb25zdCBmaWVsZFR5cGUgPSBkYXRhU2xpY2UucmVhZFVpbnQxNihpICsgMik7XG4gICAgICBjb25zdCB0eXBlQ291bnQgPSB0aGlzLmJpZ1RpZmZcbiAgICAgICAgPyBkYXRhU2xpY2UucmVhZFVpbnQ2NChpICsgNClcbiAgICAgICAgOiBkYXRhU2xpY2UucmVhZFVpbnQzMihpICsgNCk7XG5cbiAgICAgIGxldCBmaWVsZFZhbHVlcztcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZUxlbmd0aCA9IGdldEZpZWxkVHlwZUxlbmd0aChmaWVsZFR5cGUpO1xuICAgICAgY29uc3QgdmFsdWVPZmZzZXQgPSBpICsgKHRoaXMuYmlnVGlmZiA/IDEyIDogOCk7XG5cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGRpcmVjdGx5IGVuY29kZWQgaW4gdGhlIHRhZyBvciByZWZlcnMgdG8gYVxuICAgICAgLy8gZGlmZmVyZW50IGV4dGVybmFsIGJ5dGUgcmFuZ2VcbiAgICAgIGlmIChmaWVsZFR5cGVMZW5ndGggKiB0eXBlQ291bnQgPD0gKHRoaXMuYmlnVGlmZiA/IDggOiA0KSkge1xuICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhkYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCB2YWx1ZU9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXNvbHZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCBieXRlIHJhbmdlXG4gICAgICAgIGNvbnN0IGFjdHVhbE9mZnNldCA9IGRhdGFTbGljZS5yZWFkT2Zmc2V0KHZhbHVlT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSkgKiB0eXBlQ291bnQ7XG5cbiAgICAgICAgLy8gY2hlY2ssIHdoZXRoZXIgd2UgYWN0dWFsbHkgY292ZXIgdGhlIHJlZmVyZW5jZWQgYnl0ZSByYW5nZTsgaWYgbm90LFxuICAgICAgICAvLyByZXF1ZXN0IGEgbmV3IHNsaWNlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBpdFxuICAgICAgICBpZiAoZGF0YVNsaWNlLmNvdmVycyhhY3R1YWxPZmZzZXQsIGxlbmd0aCkpIHtcbiAgICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhkYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCBhY3R1YWxPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpZWxkRGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShhY3R1YWxPZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgZmllbGRWYWx1ZXMgPSBnZXRWYWx1ZXMoZmllbGREYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCBhY3R1YWxPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVucGFjayBzaW5nbGUgdmFsdWVzIGZyb20gdGhlIGFycmF5XG4gICAgICBpZiAodHlwZUNvdW50ID09PSAxICYmIGFycmF5RmllbGRzLmluZGV4T2YoZmllbGRUYWcpID09PSAtMVxuICAgICAgICAmJiAhKGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5SQVRJT05BTCB8fCBmaWVsZFR5cGUgPT09IGZpZWxkVHlwZXMuU1JBVElPTkFMKSkge1xuICAgICAgICB2YWx1ZSA9IGZpZWxkVmFsdWVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmaWVsZFZhbHVlcztcbiAgICAgIH1cblxuICAgICAgLy8gd3JpdGUgdGhlIHRhZ3MgdmFsdWUgdG8gdGhlIGZpbGUgZGlyZWN0bHlcbiAgICAgIGZpbGVEaXJlY3RvcnlbZmllbGRUYWdOYW1lc1tmaWVsZFRhZ11dID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGdlb0tleURpcmVjdG9yeSA9IHBhcnNlR2VvS2V5RGlyZWN0b3J5KGZpbGVEaXJlY3RvcnkpO1xuICAgIGNvbnN0IG5leHRJRkRCeXRlT2Zmc2V0ID0gZGF0YVNsaWNlLnJlYWRPZmZzZXQoXG4gICAgICBvZmZzZXQgKyBvZmZzZXRTaXplICsgKGVudHJ5U2l6ZSAqIG51bURpckVudHJpZXMpLFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IEltYWdlRmlsZURpcmVjdG9yeShcbiAgICAgIGZpbGVEaXJlY3RvcnksXG4gICAgICBnZW9LZXlEaXJlY3RvcnksXG4gICAgICBuZXh0SUZEQnl0ZU9mZnNldCxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdElGRChpbmRleCkge1xuICAgIC8vIHNlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhhdCBJRkQgaW5kZXggcmVxdWVzdGVkLlxuICAgIGlmICh0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSkge1xuICAgICAgLy8gYXR0YWNoIHRvIGFuIGFscmVhZHkgcmVxdWVzdGVkIElGRFxuICAgICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgaW5kZXggMFxuICAgICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gPSB0aGlzLnBhcnNlRmlsZURpcmVjdG9yeUF0KHRoaXMuZmlyc3RJRkRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWZkUmVxdWVzdHNbaW5kZXggLSAxXSkge1xuICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIElGRCB3YXMgbm90IHlldCBsb2FkZWQsIGxvYWQgdGhhdCBvbmUgZmlyc3RcbiAgICAgIC8vIHRoaXMgaXMgdGhlIHJlY3Vyc2l2ZSBjYWxsLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdID0gdGhpcy5yZXF1ZXN0SUZEKGluZGV4IC0gMSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyBvbmUgYWxyZWFkeSB3YXMgYW4gaW5kZXggZXJyb3IsIHJldGhyb3dcbiAgICAgICAgLy8gd2l0aCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR2VvVElGRkltYWdlSW5kZXhFcnJvcihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0aHJvdyBhbnl0aGluZyBlbHNlXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHRoZSBwcmV2aW91cyBJRkQgd2FzIGxvYWRlZCwgd2UgY2FuIGZpbmFsbHkgZmV0Y2ggdGhlIG9uZSB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhbiBJSUZFLCBvdGhlcndpc2UgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gd291bGQgYmUgZGVsYXllZFxuICAgIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzSWZkID0gYXdhaXQgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdO1xuICAgICAgaWYgKHByZXZpb3VzSWZkLm5leHRJRkRCeXRlT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBHZW9USUZGSW1hZ2VJbmRleEVycm9yKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRmlsZURpcmVjdG9yeUF0KHByZXZpb3VzSWZkLm5leHRJRkRCeXRlT2Zmc2V0KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG4tdGggaW50ZXJuYWwgc3ViZmlsZSBvZiBhbiBpbWFnZS4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdIHRoZSBpbmRleCBvZiB0aGUgaW1hZ2UgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGSW1hZ2U+fSB0aGUgaW1hZ2UgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqL1xuICBhc3luYyBnZXRJbWFnZShpbmRleCA9IDApIHtcbiAgICBjb25zdCBpZmQgPSBhd2FpdCB0aGlzLnJlcXVlc3RJRkQoaW5kZXgpO1xuICAgIHJldHVybiBuZXcgR2VvVElGRkltYWdlKFxuICAgICAgaWZkLmZpbGVEaXJlY3RvcnksIGlmZC5nZW9LZXlEaXJlY3RvcnksXG4gICAgICB0aGlzLmRhdGFWaWV3LCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5jYWNoZSwgdGhpcy5zb3VyY2UsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiB0aGUgaW50ZXJuYWwgc3ViZmlsZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IHRoZSBudW1iZXIgb2YgaW50ZXJuYWwgc3ViZmlsZSBpbWFnZXNcbiAgICovXG4gIGFzeW5jIGdldEltYWdlQ291bnQoKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICAvLyBsb29wIHVudGlsIHdlIHJ1biBvdXQgb2YgSUZEc1xuICAgIGxldCBoYXNOZXh0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoaGFzTmV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0SUZEKGluZGV4KTtcbiAgICAgICAgKytpbmRleDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBHZW9USUZGSW1hZ2VJbmRleEVycm9yKSB7XG4gICAgICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWVzIG9mIHRoZSBDT0cgZ2hvc3QgYXJlYSBhcyBhIHBhcnNlZCBtYXAuXG4gICAqIFNlZSBodHRwczovL2dkYWwub3JnL2RyaXZlcnMvcmFzdGVyL2NvZy5odG1sI2hlYWRlci1naG9zdC1hcmVhIGZvciByZWZlcmVuY2VcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gdGhlIHBhcnNlZCBnaG9zdCBhcmVhIG9yIG51bGwsIGlmIG5vIHN1Y2ggYXJlYSB3YXMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEdob3N0VmFsdWVzKCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmlnVGlmZiA/IDE2IDogODtcbiAgICBpZiAodGhpcy5naG9zdFZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2hvc3RWYWx1ZXM7XG4gICAgfVxuICAgIGNvbnN0IGRldGVjdGlvblN0cmluZyA9ICdHREFMX1NUUlVDVFVSQUxfTUVUQURBVEFfU0laRT0nO1xuICAgIGNvbnN0IGhldXJpc3RpY0FyZWFTaXplID0gZGV0ZWN0aW9uU3RyaW5nLmxlbmd0aCArIDEwMDtcbiAgICBsZXQgc2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCwgaGV1cmlzdGljQXJlYVNpemUpO1xuICAgIGlmIChkZXRlY3Rpb25TdHJpbmcgPT09IGdldFZhbHVlcyhzbGljZSwgZmllbGRUeXBlcy5BU0NJSSwgZGV0ZWN0aW9uU3RyaW5nLmxlbmd0aCwgb2Zmc2V0KSkge1xuICAgICAgY29uc3QgdmFsdWVzU3RyaW5nID0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBoZXVyaXN0aWNBcmVhU2l6ZSwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGZpcnN0TGluZSA9IHZhbHVlc1N0cmluZy5zcGxpdCgnXFxuJylbMF07XG4gICAgICBjb25zdCBtZXRhZGF0YVNpemUgPSBOdW1iZXIoZmlyc3RMaW5lLnNwbGl0KCc9JylbMV0uc3BsaXQoJyAnKVswXSkgKyBmaXJzdExpbmUubGVuZ3RoO1xuICAgICAgaWYgKG1ldGFkYXRhU2l6ZSA+IGhldXJpc3RpY0FyZWFTaXplKSB7XG4gICAgICAgIHNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQsIG1ldGFkYXRhU2l6ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmdWxsU3RyaW5nID0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBtZXRhZGF0YVNpemUsIG9mZnNldCk7XG4gICAgICB0aGlzLmdob3N0VmFsdWVzID0ge307XG4gICAgICBmdWxsU3RyaW5nXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLmZpbHRlcigobGluZSkgPT4gbGluZS5sZW5ndGggPiAwKVxuICAgICAgICAubWFwKChsaW5lKSA9PiBsaW5lLnNwbGl0KCc9JykpXG4gICAgICAgIC5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB0aGlzLmdob3N0VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdob3N0VmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgKEdlbylUSUZGIGZpbGUgZnJvbSB0aGUgZ2l2ZW4gc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSBUaGUgc291cmNlIG9mIGRhdGEgdG8gcGFyc2UgZnJvbS5cbiAgICogQHBhcmFtIHtHZW9USUZGT3B0aW9uc30gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tU291cmNlKHNvdXJjZSwgb3B0aW9ucywgc2lnbmFsKSB7XG4gICAgY29uc3QgaGVhZGVyRGF0YSA9IChhd2FpdCBzb3VyY2UuZmV0Y2goW3sgb2Zmc2V0OiAwLCBsZW5ndGg6IDEwMjQgfV0sIHNpZ25hbCkpWzBdO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3NjQoaGVhZGVyRGF0YSk7XG5cbiAgICBjb25zdCBCT00gPSBkYXRhVmlldy5nZXRVaW50MTYoMCwgMCk7XG4gICAgbGV0IGxpdHRsZUVuZGlhbjtcbiAgICBpZiAoQk9NID09PSAweDQ5NDkpIHtcbiAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChCT00gPT09IDB4NEQ0RCkge1xuICAgICAgbGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYnl0ZSBvcmRlciB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYWdpY051bWJlciA9IGRhdGFWaWV3LmdldFVpbnQxNigyLCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBiaWdUaWZmO1xuICAgIGlmIChtYWdpY051bWJlciA9PT0gNDIpIHtcbiAgICAgIGJpZ1RpZmYgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG1hZ2ljTnVtYmVyID09PSA0Mykge1xuICAgICAgYmlnVGlmZiA9IHRydWU7XG4gICAgICBjb25zdCBvZmZzZXRCeXRlU2l6ZSA9IGRhdGFWaWV3LmdldFVpbnQxNig0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgaWYgKG9mZnNldEJ5dGVTaXplICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb2Zmc2V0IGJ5dGUtc2l6ZS4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWdpYyBudW1iZXIuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBiaWdUaWZmXG4gICAgICA/IGRhdGFWaWV3LmdldFVpbnQ2NCg4LCBsaXR0bGVFbmRpYW4pXG4gICAgICA6IGRhdGFWaWV3LmdldFVpbnQzMig0LCBsaXR0bGVFbmRpYW4pO1xuICAgIHJldHVybiBuZXcgR2VvVElGRihzb3VyY2UsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZiwgZmlyc3RJRkRPZmZzZXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyBmaWxlIGJ1ZmZlclxuICAgKiBOLkIuIEFmdGVyIHRoZSBHZW9USUZGIGhhcyBiZWVuIGNvbXBsZXRlbHkgcHJvY2Vzc2VkIGl0IG5lZWRzXG4gICAqIHRvIGJlIGNsb3NlZCBidXQgb25seSBpZiBpdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBmcm9tIGEgZmlsZS5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UuY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jbG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvVElGRiB9O1xuZXhwb3J0IGRlZmF1bHQgR2VvVElGRjtcblxuLyoqXG4gKiBXcmFwcGVyIGZvciBHZW9USUZGIGZpbGVzIHRoYXQgaGF2ZSBleHRlcm5hbCBvdmVydmlld3MuXG4gKiBAYXVnbWVudHMgR2VvVElGRkJhc2VcbiAqL1xuY2xhc3MgTXVsdGlHZW9USUZGIGV4dGVuZHMgR2VvVElGRkJhc2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IE11bHRpR2VvVElGRiBmcm9tIGEgbWFpbiBhbmQgc2V2ZXJhbCBvdmVydmlldyBmaWxlcy5cbiAgICogQHBhcmFtIHtHZW9USUZGfSBtYWluRmlsZSBUaGUgbWFpbiBHZW9USUZGIGZpbGUuXG4gICAqIEBwYXJhbSB7R2VvVElGRltdfSBvdmVydmlld0ZpbGVzIEFuIGFycmF5IG9mIG92ZXJ2aWV3IGZpbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFpbkZpbGUsIG92ZXJ2aWV3RmlsZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWFpbkZpbGUgPSBtYWluRmlsZTtcbiAgICB0aGlzLm92ZXJ2aWV3RmlsZXMgPSBvdmVydmlld0ZpbGVzO1xuICAgIHRoaXMuaW1hZ2VGaWxlcyA9IFttYWluRmlsZV0uY29uY2F0KG92ZXJ2aWV3RmlsZXMpO1xuXG4gICAgdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlID0gbnVsbDtcbiAgICB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGVQYXJzaW5nID0gbnVsbDtcbiAgICB0aGlzLmltYWdlQ291bnQgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VGaWxlRGlyZWN0b3JpZXNQZXJGaWxlKCkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gW3RoaXMubWFpbkZpbGUucGFyc2VGaWxlRGlyZWN0b3J5QXQodGhpcy5tYWluRmlsZS5maXJzdElGRE9mZnNldCldXG4gICAgICAuY29uY2F0KHRoaXMub3ZlcnZpZXdGaWxlcy5tYXAoKGZpbGUpID0+IGZpbGUucGFyc2VGaWxlRGlyZWN0b3J5QXQoZmlsZS5maXJzdElGRE9mZnNldCkpKTtcblxuICAgIHRoaXMuZmlsZURpcmVjdG9yaWVzUGVyRmlsZSA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzKTtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbi10aCBpbnRlcm5hbCBzdWJmaWxlIG9mIGFuIGltYWdlLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gdGhlIGluZGV4IG9mIHRoZSBpbWFnZSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkZJbWFnZT59IHRoZSBpbWFnZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICovXG4gIGFzeW5jIGdldEltYWdlKGluZGV4ID0gMCkge1xuICAgIGF3YWl0IHRoaXMuZ2V0SW1hZ2VDb3VudCgpO1xuICAgIGF3YWl0IHRoaXMucGFyc2VGaWxlRGlyZWN0b3JpZXNQZXJGaWxlKCk7XG4gICAgbGV0IHZpc2l0ZWQgPSAwO1xuICAgIGxldCByZWxhdGl2ZUluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW1hZ2VGaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW1hZ2VGaWxlID0gdGhpcy5pbWFnZUZpbGVzW2ldO1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHRoaXMuaW1hZ2VDb3VudHNbaV07IGlpKyspIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2aXNpdGVkKSB7XG4gICAgICAgICAgY29uc3QgaWZkID0gYXdhaXQgaW1hZ2VGaWxlLnJlcXVlc3RJRkQocmVsYXRpdmVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBHZW9USUZGSW1hZ2UoXG4gICAgICAgICAgICBpZmQuZmlsZURpcmVjdG9yeSwgaWZkLmdlb0tleURpcmVjdG9yeSxcbiAgICAgICAgICAgIGltYWdlRmlsZS5kYXRhVmlldywgaW1hZ2VGaWxlLmxpdHRsZUVuZGlhbiwgaW1hZ2VGaWxlLmNhY2hlLCBpbWFnZUZpbGUuc291cmNlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCsrO1xuICAgICAgICByZWxhdGl2ZUluZGV4Kys7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBpbWFnZSBpbmRleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBpbnRlcm5hbCBzdWJmaWxlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gdGhlIG51bWJlciBvZiBpbnRlcm5hbCBzdWJmaWxlIGltYWdlc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2VDb3VudCgpIHtcbiAgICBpZiAodGhpcy5pbWFnZUNvdW50ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZUNvdW50O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0cyA9IFt0aGlzLm1haW5GaWxlLmdldEltYWdlQ291bnQoKV1cbiAgICAgIC5jb25jYXQodGhpcy5vdmVydmlld0ZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5nZXRJbWFnZUNvdW50KCkpKTtcbiAgICB0aGlzLmltYWdlQ291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIHRoaXMuaW1hZ2VDb3VudCA9IHRoaXMuaW1hZ2VDb3VudHMucmVkdWNlKChjb3VudCwgaWZkcykgPT4gY291bnQgKyBpZmRzLCAwKTtcbiAgICByZXR1cm4gdGhpcy5pbWFnZUNvdW50O1xuICB9XG59XG5cbmV4cG9ydCB7IE11bHRpR2VvVElGRiB9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgR2VvVElGRiBmcm9tIGEgcmVtb3RlIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byBhY2Nlc3MgdGhlIGltYWdlIGZyb21cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayBtYWtlUmVtb3RlU291cmNlfSBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVVybCh1cmwsIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZVJlbW90ZVNvdXJjZSh1cmwsIG9wdGlvbnMpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIG5ldyBHZW9USUZGIGZyb20gYW5cbiAqIFtBcnJheUJ1ZmZlcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXJ9LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGRhdGEgdG8gcmVhZCB0aGUgZmlsZSBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIHNpZ25hbCkge1xuICByZXR1cm4gR2VvVElGRi5mcm9tU291cmNlKG1ha2VCdWZmZXJTb3VyY2UoYXJyYXlCdWZmZXIpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIEdlb1RJRkYgZnJvbSBhIGxvY2FsIGZpbGUgcGF0aC4gVGhpcyB1c2VzIHRoZSBub2RlXG4gKiBbZmlsZXN5c3RlbSBBUElde0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbH0gYW5kIGlzXG4gKiBub3QgYXZhaWxhYmxlIG9uIGJyb3dzZXJzLlxuICpcbiAqIE4uQi4gQWZ0ZXIgdGhlIEdlb1RJRkYgaGFzIGJlZW4gY29tcGxldGVseSBwcm9jZXNzZWQgaXQgbmVlZHNcbiAqIHRvIGJlIGNsb3NlZCBidXQgb25seSBpZiBpdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBmcm9tIGEgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBmaWxlIHBhdGggdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tRmlsZShwYXRoLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlRmlsZVNvdXJjZShwYXRoKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBHZW9USUZGIGZyb20gYW4gSFRNTFxuICogW0Jsb2Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9ifSBvclxuICogW0ZpbGVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlfVxuICogb2JqZWN0LlxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGJsb2IgVGhlIEJsb2Igb3IgRmlsZSBvYmplY3QgdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tQmxvYihibG9iLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlRmlsZVJlYWRlclNvdXJjZShibG9iKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBNdWx0aUdlb1RJRkYgZnJvbSB0aGUgZ2l2ZW4gVVJMcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYWluVXJsIFRoZSBVUkwgZm9yIHRoZSBtYWluIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvdmVydmlld1VybHMgQW4gYXJyYXkgb2YgVVJMcyBmb3IgdGhlIG92ZXJ2aWV3IGltYWdlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIFttYWtlUmVtb3RlU291cmNlXXtAbGluayBtb2R1bGU6c291cmNlLm1ha2VSZW1vdGVTb3VyY2V9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNdWx0aUdlb1RJRkY+fSBUaGUgcmVzdWx0aW5nIE11bHRpR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVVybHMobWFpblVybCwgb3ZlcnZpZXdVcmxzID0gW10sIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIGNvbnN0IG1haW5GaWxlID0gYXdhaXQgR2VvVElGRi5mcm9tU291cmNlKG1ha2VSZW1vdGVTb3VyY2UobWFpblVybCwgb3B0aW9ucyksIHNpZ25hbCk7XG4gIGNvbnN0IG92ZXJ2aWV3RmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBvdmVydmlld1VybHMubWFwKCh1cmwpID0+IEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKHVybCwgb3B0aW9ucykpKSxcbiAgKTtcblxuICByZXR1cm4gbmV3IE11bHRpR2VvVElGRihtYWluRmlsZSwgb3ZlcnZpZXdGaWxlcyk7XG59XG5cbi8qKlxuICogTWFpbiBjcmVhdGluZyBmdW5jdGlvbiBmb3IgR2VvVElGRiBmaWxlcy5cbiAqIEBwYXJhbSB7KEFycmF5KX0gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzXG4gKiBAcmV0dXJucyB7bWV0YWRhdGF9IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUFycmF5QnVmZmVyKHZhbHVlcywgbWV0YWRhdGEpIHtcbiAgcmV0dXJuIHdyaXRlR2VvdGlmZih2YWx1ZXMsIG1ldGFkYXRhKTtcbn1cblxuZXhwb3J0IHsgUG9vbCB9O1xuZXhwb3J0IHsgR2VvVElGRkltYWdlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiff.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiffimage.js":
/*!**********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffimage.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @petamoriken/float16 */ \"./node_modules/@petamoriken/float16/src/DataView.mjs\");\n/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml-utils/get-attribute.js */ \"./node_modules/xml-utils/get-attribute.js\");\n/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-utils/find-tags-by-name.js */ \"./node_modules/xml-utils/find-tags-by-name.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rgb.js */ \"./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resample.js */ \"./node_modules/geotiff/dist-module/resample.js\");\n/** @module geotiffimage */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__.getFloat16)(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal).then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resampleInterleaved)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resample)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_4__.getDecoder)(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === _globals_js__WEBPACK_IMPORTED_MODULE_5__.ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromWhiteIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromBlackIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromPalette)(raster, fileDirectory.ColorMap);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCMYK)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromYCbCr)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCIELab)(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoTIFFImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmaW1hZ2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNrRDtBQUNJO0FBQ007O0FBRWtCO0FBQzRCO0FBQ3REO0FBQ1U7O0FBRTlEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGVBQWU7QUFDN0I7QUFDQSxjQUFjLGVBQWU7QUFDN0IsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQjtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUNBQW1DOztBQUVqRDtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsYUFBYTtBQUMxQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkI7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLFNBQVM7QUFDdEIsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTs7QUFFM0IsK0JBQStCLGtCQUFrQjtBQUNqRCxpQ0FBaUMsa0JBQWtCO0FBQ25ELGtDQUFrQyw4QkFBOEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtFQUFrRSxVQUFVO0FBQzVFLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUVBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQixzREFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQixXQUFXO0FBQzNDLGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBLHdFQUF3RSxXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGlFQUFVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLGFBQWE7QUFDMUI7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBLGtCQUFrQjtBQUNsQixrREFBa0QsSUFBSTtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLHVFQUE4QjtBQUM3QztBQUNBLGlEQUFpRCx1RUFBOEI7QUFDL0U7QUFDQSx3QkFBd0IsNkNBQTZDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsV0FBVywrRUFBc0M7QUFDakQsV0FBVywrRUFBc0M7QUFDakQsV0FBVywyRUFBa0M7QUFDN0M7QUFDQTtBQUNBLFdBQVcsd0VBQStCO0FBQzFDO0FBQ0E7QUFDQSxXQUFXLHlFQUFnQztBQUMzQyxXQUFXLDBFQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywrRUFBc0M7QUFDakQsZUFBZSx3REFBZTtBQUM5QjtBQUNBLFdBQVcsK0VBQXNDO0FBQ2pELGVBQWUsd0RBQWU7QUFDOUI7QUFDQSxXQUFXLDJFQUFrQztBQUM3QyxlQUFlLG9EQUFXO0FBQzFCO0FBQ0EsV0FBVyx3RUFBK0I7QUFDMUMsZUFBZSxpREFBUTtBQUN2QjtBQUNBLFdBQVcseUVBQWdDO0FBQzNDLGVBQWUsa0RBQVM7QUFDeEI7QUFDQSxXQUFXLDBFQUFpQztBQUM1QyxlQUFlLG1EQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLDJEQUFjOztBQUU5QjtBQUNBLHFDQUFxQyx1REFBWTtBQUNqRCxNQUFNO0FBQ04sNENBQTRDLHVEQUFZO0FBQ3hEOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxlQUFlLHVEQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZmltYWdlLmpzP2U4MzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgZ2VvdGlmZmltYWdlICovXG5pbXBvcnQgeyBnZXRGbG9hdDE2IH0gZnJvbSAnQHBldGFtb3Jpa2VuL2Zsb2F0MTYnO1xuaW1wb3J0IGdldEF0dHJpYnV0ZSBmcm9tICd4bWwtdXRpbHMvZ2V0LWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgZmluZFRhZ3NCeU5hbWUgZnJvbSAneG1sLXV0aWxzL2ZpbmQtdGFncy1ieS1uYW1lLmpzJztcblxuaW1wb3J0IHsgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMsIEV4dHJhU2FtcGxlc1ZhbHVlcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyBmcm9tV2hpdGVJc1plcm8sIGZyb21CbGFja0lzWmVybywgZnJvbVBhbGV0dGUsIGZyb21DTVlLLCBmcm9tWUNiQ3IsIGZyb21DSUVMYWIgfSBmcm9tICcuL3JnYi5qcyc7XG5pbXBvcnQgeyBnZXREZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9pbmRleC5qcyc7XG5pbXBvcnQgeyByZXNhbXBsZSwgcmVzYW1wbGVJbnRlcmxlYXZlZCB9IGZyb20gJy4vcmVzYW1wbGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWRSYXN0ZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFt3aW5kb3c9d2hvbGUgd2luZG93XSB0aGUgc3Vic2V0IHRvIHJlYWQgZGF0YSBmcm9tIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Jib3g9d2hvbGUgaW1hZ2VdIHRoZSBzdWJzZXQgdG8gcmVhZCBkYXRhIGZyb20gaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3NhbXBsZXM9YWxsIHNhbXBsZXNdIHRoZSBzZWxlY3Rpb24gb2Ygc2FtcGxlcyB0byByZWFkIGZyb20uIERlZmF1bHQgaXMgYWxsIHNhbXBsZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcmxlYXZlPWZhbHNlXSB3aGV0aGVyIHRoZSBkYXRhIHNoYWxsIGJlIHJlYWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gb25lIHNpbmdsZSBhcnJheSBvciBzZXBhcmF0ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheXMuXG4gKiBAcHJvcGVydHkge1Bvb2x9IFtwb29sPW51bGxdIFRoZSBvcHRpb25hbCBkZWNvZGVyIHBvb2wgdG8gdXNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm90IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmVzYW1wbGVNZXRob2Q9J25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcHJvcGVydHkge251bWJlcnxudW1iZXJbXX0gW2ZpbGxWYWx1ZV0gVGhlIHZhbHVlIHRvIHVzZSBmb3IgcGFydHMgb2YgdGhlIGltYWdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlIG9mIHRoZSBpbWFnZXMgZXh0ZW50LiBXaGVuIG11bHRpcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVzIGFyZSByZXF1ZXN0ZWQsIGFuIGFycmF5IG9mIGZpbGwgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW4gYmUgcGFzc2VkLlxuICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9nZW90aWZmLmpzXCIpLlR5cGVkQXJyYXl9IFR5cGVkQXJyYXkgKi9cblxuZnVuY3Rpb24gc3VtKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIGxldCBzID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBzICs9IGFycmF5W2ldO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBzaXplKSB7XG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSAxOiAvLyB1bnNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMzIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShzaXplKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjogLy8gdHdvcyBjb21wbGVtZW50IHNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgIGlmIChiaXRzUGVyU2FtcGxlID09PSA4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlID09PSAxNikge1xuICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPT09IDMyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gZmxvYXRpbmcgcG9pbnQgZGF0YVxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoc2l6ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgZm9ybWF0L2JpdHNQZXJTYW1wbGUnKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uKGZvcm1hdCwgYml0c1BlclNhbXBsZSkge1xuICBpZiAoKGZvcm1hdCA9PT0gMSB8fCBmb3JtYXQgPT09IDIpICYmIGJpdHNQZXJTYW1wbGUgPD0gMzIgJiYgYml0c1BlclNhbXBsZSAlIDggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzICYmIChiaXRzUGVyU2FtcGxlID09PSAxNiB8fCBiaXRzUGVyU2FtcGxlID09PSAzMiB8fCBiaXRzUGVyU2FtcGxlID09PSA2NCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KGluQnVmZmVyLCBmb3JtYXQsIHBsYW5hckNvbmZpZ3VyYXRpb24sIHNhbXBsZXNQZXJQaXhlbCwgYml0c1BlclNhbXBsZSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KSB7XG4gIC8vIGNvbnN0IGluQnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW5CdWZmZXIpO1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGluQnVmZmVyKTtcbiAgY29uc3Qgb3V0U2l6ZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDJcbiAgICA/IHRpbGVIZWlnaHQgKiB0aWxlV2lkdGhcbiAgICA6IHRpbGVIZWlnaHQgKiB0aWxlV2lkdGggKiBzYW1wbGVzUGVyUGl4ZWw7XG4gIGNvbnN0IHNhbXBsZXNUb1RyYW5zZmVyID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMlxuICAgID8gMSA6IHNhbXBsZXNQZXJQaXhlbDtcbiAgY29uc3Qgb3V0QXJyYXkgPSBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBvdXRTaXplKTtcbiAgLy8gbGV0IHBpeGVsID0gMDtcblxuICBjb25zdCBiaXRNYXNrID0gcGFyc2VJbnQoJzEnLnJlcGVhdChiaXRzUGVyU2FtcGxlKSwgMik7XG5cbiAgaWYgKGZvcm1hdCA9PT0gMSkgeyAvLyB1bnNpZ25lZCBpbnRlZ2VyXG4gICAgLy8gdHJhbnNsYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL2dkYWwvYmxvYi9tYXN0ZXIvZ2RhbC9mcm10cy9ndGlmZi9nZW90aWZmLmNwcCNMNzMzN1xuICAgIGxldCBwaXhlbEJpdFNraXA7XG4gICAgLy8gbGV0IHNhbXBsZUJpdE9mZnNldCA9IDA7XG4gICAgaWYgKHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgIHBpeGVsQml0U2tpcCA9IHNhbXBsZXNQZXJQaXhlbCAqIGJpdHNQZXJTYW1wbGU7XG4gICAgICAvLyBzYW1wbGVCaXRPZmZzZXQgPSAoc2FtcGxlc1BlclBpeGVsIC0gMSkgKiBiaXRzUGVyU2FtcGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwaXhlbEJpdFNraXAgPSBiaXRzUGVyU2FtcGxlO1xuICAgIH1cblxuICAgIC8vIEJpdHMgcGVyIGxpbmUgcm91bmRzIHVwIHRvIG5leHQgYnl0ZSBib3VuZGFyeS5cbiAgICBsZXQgYml0c1BlckxpbmUgPSB0aWxlV2lkdGggKiBwaXhlbEJpdFNraXA7XG4gICAgaWYgKChiaXRzUGVyTGluZSAmIDcpICE9PSAwKSB7XG4gICAgICBiaXRzUGVyTGluZSA9IChiaXRzUGVyTGluZSArIDcpICYgKH43KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRpbGVIZWlnaHQ7ICsreSkge1xuICAgICAgY29uc3QgbGluZUJpdE9mZnNldCA9IHkgKiBiaXRzUGVyTGluZTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGlsZVdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgcGl4ZWxCaXRPZmZzZXQgPSBsaW5lQml0T2Zmc2V0ICsgKHggKiBzYW1wbGVzVG9UcmFuc2ZlciAqIGJpdHNQZXJTYW1wbGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXNUb1RyYW5zZmVyOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBiaXRPZmZzZXQgPSBwaXhlbEJpdE9mZnNldCArIChpICogYml0c1BlclNhbXBsZSk7XG4gICAgICAgICAgY29uc3Qgb3V0SW5kZXggPSAoKCh5ICogdGlsZVdpZHRoKSArIHgpICogc2FtcGxlc1RvVHJhbnNmZXIpICsgaTtcblxuICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBNYXRoLmZsb29yKGJpdE9mZnNldCAvIDgpO1xuICAgICAgICAgIGNvbnN0IGlubmVyQml0T2Zmc2V0ID0gYml0T2Zmc2V0ICUgODtcbiAgICAgICAgICBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQpID4+ICg4IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSAodmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCkgPj4gKDE2IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDI0KSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSAodmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCkgPDwgOCkgfCAodmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgMikpO1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHJhdyA+PiAoMjQgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0KSA+PiAoMzIgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGV0IG91dFdvcmQgPSAwO1xuICAgICAgICAgIC8vIGZvciAobGV0IGJpdCA9IDA7IGJpdCA8IGJpdHNQZXJTYW1wbGU7ICsrYml0KSB7XG4gICAgICAgICAgLy8gICBpZiAoaW5CeXRlQXJyYXlbYml0T2Zmc2V0ID4+IDNdXG4gICAgICAgICAgLy8gICAgICYgKDB4ODAgPj4gKGJpdE9mZnNldCAmIDcpKSkge1xuICAgICAgICAgIC8vICAgICBvdXRXb3JkIHw9ICgxIDw8IChiaXRzUGVyU2FtcGxlIC0gMSAtIGJpdCkpO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgKytiaXRPZmZzZXQ7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgLy8gb3V0QXJyYXlbb3V0SW5kZXhdID0gb3V0V29yZDtcbiAgICAgICAgICAvLyBvdXRBcnJheVtwaXhlbF0gPSBvdXRXb3JkO1xuICAgICAgICAgIC8vIHBpeGVsICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYml0T2Zmc2V0ID0gYml0T2Zmc2V0ICsgcGl4ZWxCaXRTa2lwIC0gYml0c1BlclNhbXBsZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7IC8vIGZsb2F0aW5nIHBvaW50XG4gICAgLy8gRmxvYXQxNiBpcyBoYW5kbGVkIGVsc2V3aGVyZVxuICAgIC8vIG5vcm1hbGl6ZSAxNi8yNCBiaXQgZmxvYXRzIHRvIDMyIGJpdCBmbG9hdHMgaW4gdGhlIGFycmF5XG4gICAgLy8gY29uc29sZS50aW1lKCk7XG4gICAgLy8gaWYgKGJpdHNQZXJTYW1wbGUgPT09IDE2KSB7XG4gICAgLy8gICBmb3IgKGxldCBieXRlID0gMCwgb3V0SW5kZXggPSAwOyBieXRlIDwgaW5CdWZmZXIuYnl0ZUxlbmd0aDsgYnl0ZSArPSAyLCArK291dEluZGV4KSB7XG4gICAgLy8gICAgIG91dEFycmF5W291dEluZGV4XSA9IGdldEZsb2F0MTYodmlldywgYnl0ZSk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8vIGNvbnNvbGUudGltZUVuZCgpXG4gIH1cblxuICByZXR1cm4gb3V0QXJyYXkuYnVmZmVyO1xufVxuXG4vKipcbiAqIEdlb1RJRkYgc3ViLWZpbGUgaW1hZ2UuXG4gKi9cbmNsYXNzIEdlb1RJRkZJbWFnZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGZpbGVEaXJlY3RvcnkgVGhlIHBhcnNlZCBmaWxlIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvS2V5cyBUaGUgcGFyc2VkIGdlby1rZXlzXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3IFRoZSBEYXRhVmlldyBmb3IgdGhlIHVuZGVybHlpbmcgZmlsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsaXR0bGVFbmRpYW4gV2hldGhlciB0aGUgZmlsZSBpcyBlbmNvZGVkIGluIGxpdHRsZSBvciBiaWcgZW5kaWFuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FjaGUgV2hldGhlciBvciBub3QgZGVjb2RlZCB0aWxlcyBzaGFsbCBiZSBjYWNoZWRcbiAgICogQHBhcmFtIHtTb3VyY2V9IHNvdXJjZSBUaGUgZGF0YXNvdXJjZSB0byByZWFkIGZyb21cbiAgICovXG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnksIGdlb0tleXMsIGRhdGFWaWV3LCBsaXR0bGVFbmRpYW4sIGNhY2hlLCBzb3VyY2UpIHtcbiAgICB0aGlzLmZpbGVEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5O1xuICAgIHRoaXMuZ2VvS2V5cyA9IGdlb0tleXM7XG4gICAgdGhpcy5kYXRhVmlldyA9IGRhdGFWaWV3O1xuICAgIHRoaXMubGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuO1xuICAgIHRoaXMudGlsZXMgPSBjYWNoZSA/IHt9IDogbnVsbDtcbiAgICB0aGlzLmlzVGlsZWQgPSAhZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHM7XG4gICAgY29uc3QgcGxhbmFyQ29uZmlndXJhdGlvbiA9IGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbjtcbiAgICB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPSAodHlwZW9mIHBsYW5hckNvbmZpZ3VyYXRpb24gPT09ICd1bmRlZmluZWQnKSA/IDEgOiBwbGFuYXJDb25maWd1cmF0aW9uO1xuICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gIT09IDEgJiYgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGxhbmFyIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzb2NpYXRlZCBwYXJzZWQgZmlsZSBkaXJlY3RvcnkuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgZmlsZSBkaXJlY3RvcnlcbiAgICovXG4gIGdldEZpbGVEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NvY2lhdGVkIHBhcnNlZCBnZW8ga2V5cy5cbiAgICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBnZW8ga2V5c1xuICAgKi9cbiAgZ2V0R2VvS2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9LZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBpbWFnZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBpbWFnZVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gICAqL1xuICBnZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWxcbiAgICovXG4gIGdldFNhbXBsZXNQZXJQaXhlbCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgOiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIGVhY2ggdGlsZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdpZHRoIG9mIGVhY2ggdGlsZVxuICAgKi9cbiAgZ2V0VGlsZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmlzVGlsZWQgPyB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZVdpZHRoIDogdGhpcy5nZXRXaWR0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiBlYWNoIHRpbGUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgZWFjaCB0aWxlXG4gICAqL1xuICBnZXRUaWxlSGVpZ2h0KCkge1xuICAgIGlmICh0aGlzLmlzVGlsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZUxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAsIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKTtcbiAgfVxuXG4gIGdldEJsb2NrV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVdpZHRoKCk7XG4gIH1cblxuICBnZXRCbG9ja0hlaWdodCh5KSB7XG4gICAgaWYgKHRoaXMuaXNUaWxlZCB8fCAoeSArIDEpICogdGhpcy5nZXRUaWxlSGVpZ2h0KCkgPD0gdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUhlaWdodCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKSAtICh5ICogdGhpcy5nZXRUaWxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgZm9yIGVhY2ggcGl4ZWwgYWNyb3NzIGFsbCBzYW1wbGVzLiBPbmx5IGZ1bGxcbiAgICogYnl0ZXMgYXJlIHN1cHBvcnRlZCwgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGVuIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgYnl0ZXMgcGVyIHBpeGVsXG4gICAqL1xuICBnZXRCeXRlc1BlclBpeGVsKCkge1xuICAgIGxldCBieXRlcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZS5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMgKz0gdGhpcy5nZXRTYW1wbGVCeXRlU2l6ZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgZ2V0U2FtcGxlQnl0ZVNpemUoaSkge1xuICAgIGlmIChpID49IHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFNhbXBsZSBpbmRleCAke2l9IGlzIG91dCBvZiByYW5nZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZVtpXSAvIDgpO1xuICB9XG5cbiAgZ2V0UmVhZGVyRm9yU2FtcGxlKHNhbXBsZUluZGV4KSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFxuICAgICAgPyB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0W3NhbXBsZUluZGV4XSA6IDE7XG4gICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlW3NhbXBsZUluZGV4XTtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSAxOiAvLyB1bnNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDg7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAxNikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDE2O1xuICAgICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMzIpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQzMjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLy8gdHdvcyBjb21wbGVtZW50IHNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50ODtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQxNjtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQzMjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEZsb2F0MTYodGhpcywgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDMyO1xuICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEZsb2F0NjQ7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIGZvcm1hdC9iaXRzUGVyU2FtcGxlJyk7XG4gIH1cblxuICBnZXRTYW1wbGVGb3JtYXQoc2FtcGxlSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRcbiAgICAgID8gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFtzYW1wbGVJbmRleF0gOiAxO1xuICB9XG5cbiAgZ2V0Qml0c1BlclNhbXBsZShzYW1wbGVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbc2FtcGxlSW5kZXhdO1xuICB9XG5cbiAgZ2V0QXJyYXlGb3JTYW1wbGUoc2FtcGxlSW5kZXgsIHNpemUpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldFNhbXBsZUZvcm1hdChzYW1wbGVJbmRleCk7XG4gICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZ2V0Qml0c1BlclNhbXBsZShzYW1wbGVJbmRleCk7XG4gICAgcmV0dXJuIGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlY29kZWQgc3RyaXAgb3IgdGlsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHN0cmlwIG9yIHRpbGUgeC1vZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHRpbGUgeS1vZmZzZXQgKDAgZm9yIHN0cmlwcGVkIGltYWdlcylcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZSB0aGUgc2FtcGxlIHRvIGdldCBmb3Igc2VwYXJhdGVkIHNhbXBsZXNcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb3RpZmZcIikuUG9vbHxBYnN0cmFjdERlY29kZXJ9IHBvb2xPckRlY29kZXIgdGhlIGRlY29kZXIgb3IgZGVjb2RlciBwb29sXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBhc3luYyBnZXRUaWxlT3JTdHJpcCh4LCB5LCBzYW1wbGUsIHBvb2xPckRlY29kZXIsIHNpZ25hbCkge1xuICAgIGNvbnN0IG51bVRpbGVzUGVyUm93ID0gTWF0aC5jZWlsKHRoaXMuZ2V0V2lkdGgoKSAvIHRoaXMuZ2V0VGlsZVdpZHRoKCkpO1xuICAgIGNvbnN0IG51bVRpbGVzUGVyQ29sID0gTWF0aC5jZWlsKHRoaXMuZ2V0SGVpZ2h0KCkgLyB0aGlzLmdldFRpbGVIZWlnaHQoKSk7XG4gICAgbGV0IGluZGV4O1xuICAgIGNvbnN0IHsgdGlsZXMgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSkge1xuICAgICAgaW5kZXggPSAoeSAqIG51bVRpbGVzUGVyUm93KSArIHg7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIpIHtcbiAgICAgIGluZGV4ID0gKHNhbXBsZSAqIG51bVRpbGVzUGVyUm93ICogbnVtVGlsZXNQZXJDb2wpICsgKHkgKiBudW1UaWxlc1BlclJvdykgKyB4O1xuICAgIH1cblxuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IGJ5dGVDb3VudDtcbiAgICBpZiAodGhpcy5pc1RpbGVkKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZU9mZnNldHNbaW5kZXhdO1xuICAgICAgYnl0ZUNvdW50ID0gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVCeXRlQ291bnRzW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0c1tpbmRleF07XG4gICAgICBieXRlQ291bnQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuU3RyaXBCeXRlQ291bnRzW2luZGV4XTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSAoYXdhaXQgdGhpcy5zb3VyY2UuZmV0Y2goW3sgb2Zmc2V0LCBsZW5ndGg6IGJ5dGVDb3VudCB9XSwgc2lnbmFsKSlbMF07XG5cbiAgICBsZXQgcmVxdWVzdDtcbiAgICBpZiAodGlsZXMgPT09IG51bGwgfHwgIXRpbGVzW2luZGV4XSkge1xuICAgIC8vIHJlc29sdmUgZWFjaCByZXF1ZXN0IGJ5IHBvdGVudGlhbGx5IGFwcGx5aW5nIGFycmF5IG5vcm1hbGl6YXRpb25cbiAgICAgIHJlcXVlc3QgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHBvb2xPckRlY29kZXIuZGVjb2RlKHRoaXMuZmlsZURpcmVjdG9yeSwgc2xpY2UpO1xuICAgICAgICBjb25zdCBzYW1wbGVGb3JtYXQgPSB0aGlzLmdldFNhbXBsZUZvcm1hdCgpO1xuICAgICAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gdGhpcy5nZXRCaXRzUGVyU2FtcGxlKCk7XG4gICAgICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oc2FtcGxlRm9ybWF0LCBiaXRzUGVyU2FtcGxlKSkge1xuICAgICAgICAgIGRhdGEgPSBub3JtYWxpemVBcnJheShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzYW1wbGVGb3JtYXQsXG4gICAgICAgICAgICB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICB0aGlzLmdldFNhbXBsZXNQZXJQaXhlbCgpLFxuICAgICAgICAgICAgYml0c1BlclNhbXBsZSxcbiAgICAgICAgICAgIHRoaXMuZ2V0VGlsZVdpZHRoKCksXG4gICAgICAgICAgICB0aGlzLmdldEJsb2NrSGVpZ2h0KHkpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KSgpO1xuXG4gICAgICAvLyBzZXQgdGhlIGNhY2hlXG4gICAgICBpZiAodGlsZXMgIT09IG51bGwpIHtcbiAgICAgICAgdGlsZXNbaW5kZXhdID0gcmVxdWVzdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0IGZyb20gdGhlIGNhY2hlXG4gICAgICByZXF1ZXN0ID0gdGlsZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIC8vIGNhY2hlIHRoZSB0aWxlIHJlcXVlc3RcbiAgICByZXR1cm4geyB4LCB5LCBzYW1wbGUsIGRhdGE6IGF3YWl0IHJlcXVlc3QgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCByZWFkIGZ1bmN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBpbWFnZVdpbmRvdyBUaGUgaW1hZ2Ugd2luZG93IGluIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZXMgVGhlIHNlbGVjdGVkIHNhbXBsZXMgKDAtYmFzZWQgaW5kaWNlcylcbiAgICogQHBhcmFtIHtUeXBlZEFycmF5W118VHlwZWRBcnJheX0gdmFsdWVBcnJheXMgVGhlIGFycmF5KHMpIHRvIHdyaXRlIGludG9cbiAgICogQHBhcmFtIHtCb29sZWFufSBpbnRlcmxlYXZlIFdoZXRoZXIgb3Igbm90IHRvIHdyaXRlIGluIGFuIGludGVybGVhdmVkIG1hbm5lclxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvdGlmZlwiKS5Qb29sfEFic3RyYWN0RGVjb2Rlcn0gcG9vbE9yRGVjb2RlciB0aGUgZGVjb2RlciBvciBkZWNvZGVyIHBvb2xcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHRoZSB3aWR0aCBvZiB3aW5kb3cgdG8gYmUgcmVhZCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgdGhlIGhlaWdodCBvZiB3aW5kb3cgdG8gYmUgcmVhZCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNhbXBsZU1ldGhvZCB0aGUgcmVzYW1wbGluZyBtZXRob2QgdG8gYmUgdXNlZCB3aGVuIGludGVycG9sYXRpbmdcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8VHlwZWRBcnJheVtdPnxQcm9taXNlPFR5cGVkQXJyYXk+fVxuICAgKi9cbiAgYXN5bmMgX3JlYWRSYXN0ZXIoaW1hZ2VXaW5kb3csIHNhbXBsZXMsIHZhbHVlQXJyYXlzLCBpbnRlcmxlYXZlLCBwb29sT3JEZWNvZGVyLCB3aWR0aCxcbiAgICBoZWlnaHQsIHJlc2FtcGxlTWV0aG9kLCBzaWduYWwpIHtcbiAgICBjb25zdCB0aWxlV2lkdGggPSB0aGlzLmdldFRpbGVXaWR0aCgpO1xuICAgIGNvbnN0IHRpbGVIZWlnaHQgPSB0aGlzLmdldFRpbGVIZWlnaHQoKTtcbiAgICBjb25zdCBpbWFnZVdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgIGNvbnN0IG1pblhUaWxlID0gTWF0aC5tYXgoTWF0aC5mbG9vcihpbWFnZVdpbmRvd1swXSAvIHRpbGVXaWR0aCksIDApO1xuICAgIGNvbnN0IG1heFhUaWxlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaW5kb3dbMl0gLyB0aWxlV2lkdGgpLFxuICAgICAgTWF0aC5jZWlsKGltYWdlV2lkdGggLyB0aWxlV2lkdGgpLFxuICAgICk7XG4gICAgY29uc3QgbWluWVRpbGUgPSBNYXRoLm1heChNYXRoLmZsb29yKGltYWdlV2luZG93WzFdIC8gdGlsZUhlaWdodCksIDApO1xuICAgIGNvbnN0IG1heFlUaWxlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaW5kb3dbM10gLyB0aWxlSGVpZ2h0KSxcbiAgICAgIE1hdGguY2VpbChpbWFnZUhlaWdodCAvIHRpbGVIZWlnaHQpLFxuICAgICk7XG4gICAgY29uc3Qgd2luZG93V2lkdGggPSBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuXG4gICAgbGV0IGJ5dGVzUGVyUGl4ZWwgPSB0aGlzLmdldEJ5dGVzUGVyUGl4ZWwoKTtcblxuICAgIGNvbnN0IHNyY1NhbXBsZU9mZnNldHMgPSBbXTtcbiAgICBjb25zdCBzYW1wbGVSZWFkZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICAgIHNyY1NhbXBsZU9mZnNldHMucHVzaChzdW0odGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUsIDAsIHNhbXBsZXNbaV0pIC8gOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmNTYW1wbGVPZmZzZXRzLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBzYW1wbGVSZWFkZXJzLnB1c2godGhpcy5nZXRSZWFkZXJGb3JTYW1wbGUoc2FtcGxlc1tpXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3QgeyBsaXR0bGVFbmRpYW4gfSA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCB5VGlsZSA9IG1pbllUaWxlOyB5VGlsZSA8IG1heFlUaWxlOyArK3lUaWxlKSB7XG4gICAgICBmb3IgKGxldCB4VGlsZSA9IG1pblhUaWxlOyB4VGlsZSA8IG1heFhUaWxlOyArK3hUaWxlKSB7XG4gICAgICAgIGZvciAobGV0IHNhbXBsZUluZGV4ID0gMDsgc2FtcGxlSW5kZXggPCBzYW1wbGVzLmxlbmd0aDsgKytzYW1wbGVJbmRleCkge1xuICAgICAgICAgIGNvbnN0IHNpID0gc2FtcGxlSW5kZXg7XG4gICAgICAgICAgY29uc3Qgc2FtcGxlID0gc2FtcGxlc1tzYW1wbGVJbmRleF07XG4gICAgICAgICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgYnl0ZXNQZXJQaXhlbCA9IHRoaXMuZ2V0U2FtcGxlQnl0ZVNpemUoc2FtcGxlSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5nZXRUaWxlT3JTdHJpcCh4VGlsZSwgeVRpbGUsIHNhbXBsZSwgcG9vbE9yRGVjb2Rlciwgc2lnbmFsKS50aGVuKCh0aWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aWxlLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIZWlnaHQgPSB0aGlzLmdldEJsb2NrSGVpZ2h0KHRpbGUueSk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSB0aWxlLnkgKiB0aWxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDb2wgPSB0aWxlLnggKiB0aWxlV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBsYXN0TGluZSA9IGZpcnN0TGluZSArIGJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbGFzdENvbCA9ICh0aWxlLnggKyAxKSAqIHRpbGVXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHNhbXBsZVJlYWRlcnNbc2ldO1xuXG4gICAgICAgICAgICBjb25zdCB5bWF4ID0gTWF0aC5taW4oYmxvY2tIZWlnaHQsIGJsb2NrSGVpZ2h0IC0gKGxhc3RMaW5lIC0gaW1hZ2VXaW5kb3dbM10pLCBpbWFnZUhlaWdodCAtIGZpcnN0TGluZSk7XG4gICAgICAgICAgICBjb25zdCB4bWF4ID0gTWF0aC5taW4odGlsZVdpZHRoLCB0aWxlV2lkdGggLSAobGFzdENvbCAtIGltYWdlV2luZG93WzJdKSwgaW1hZ2VXaWR0aCAtIGZpcnN0Q29sKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IE1hdGgubWF4KDAsIGltYWdlV2luZG93WzFdIC0gZmlyc3RMaW5lKTsgeSA8IHltYXg7ICsreSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gTWF0aC5tYXgoMCwgaW1hZ2VXaW5kb3dbMF0gLSBmaXJzdENvbCk7IHggPCB4bWF4OyArK3gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbE9mZnNldCA9ICgoeSAqIHRpbGVXaWR0aCkgKyB4KSAqIGJ5dGVzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWFkZXIuY2FsbChcbiAgICAgICAgICAgICAgICAgIGRhdGFWaWV3LCBwaXhlbE9mZnNldCArIHNyY1NhbXBsZU9mZnNldHNbc2ldLCBsaXR0bGVFbmRpYW4sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBsZXQgd2luZG93Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJsZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgd2luZG93Q29vcmRpbmF0ZSA9ICgoeSArIGZpcnN0TGluZSAtIGltYWdlV2luZG93WzFdKSAqIHdpbmRvd1dpZHRoICogc2FtcGxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICsgKCh4ICsgZmlyc3RDb2wgLSBpbWFnZVdpbmRvd1swXSkgKiBzYW1wbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKyBzaTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXlzW3dpbmRvd0Nvb3JkaW5hdGVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvd0Nvb3JkaW5hdGUgPSAoXG4gICAgICAgICAgICAgICAgICAgICh5ICsgZmlyc3RMaW5lIC0gaW1hZ2VXaW5kb3dbMV0pICogd2luZG93V2lkdGhcbiAgICAgICAgICAgICAgICAgICkgKyB4ICsgZmlyc3RDb2wgLSBpbWFnZVdpbmRvd1swXTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXlzW3NpXVt3aW5kb3dDb29yZGluYXRlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgaWYgKCh3aWR0aCAmJiAoaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSkgIT09IHdpZHRoKVxuICAgICAgICB8fCAoaGVpZ2h0ICYmIChpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdKSAhPT0gaGVpZ2h0KSkge1xuICAgICAgbGV0IHJlc2FtcGxlZDtcbiAgICAgIGlmIChpbnRlcmxlYXZlKSB7XG4gICAgICAgIHJlc2FtcGxlZCA9IHJlc2FtcGxlSW50ZXJsZWF2ZWQoXG4gICAgICAgICAgdmFsdWVBcnJheXMsXG4gICAgICAgICAgaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSxcbiAgICAgICAgICBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzYW1wbGVNZXRob2QsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNhbXBsZWQgPSByZXNhbXBsZShcbiAgICAgICAgICB2YWx1ZUFycmF5cyxcbiAgICAgICAgICBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdLFxuICAgICAgICAgIGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV0sXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc2FtcGxlZC53aWR0aCA9IHdpZHRoO1xuICAgICAgcmVzYW1wbGVkLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHJldHVybiByZXNhbXBsZWQ7XG4gICAgfVxuXG4gICAgdmFsdWVBcnJheXMud2lkdGggPSB3aWR0aCB8fCBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuICAgIHZhbHVlQXJyYXlzLmhlaWdodCA9IGhlaWdodCB8fCBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdO1xuXG4gICAgcmV0dXJuIHZhbHVlQXJyYXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGltYWdlLiBUaGlzIGZ1bmN0aW9uIHJlYWRzIGFsbCBzZWxlY3RlZCBzYW1wbGVzXG4gICAqIGludG8gc2VwYXJhdGUgYXJyYXlzIG9mIHRoZSBjb3JyZWN0IHR5cGUgZm9yIHRoYXQgc2FtcGxlIG9yIGludG8gYSBzaW5nbGVcbiAgICogY29tYmluZWQgYXJyYXkgd2hlbiBgaW50ZXJsZWF2ZWAgaXMgc2V0LiBXaGVuIHByb3ZpZGVkLCBvbmx5IGEgc3Vic2V0XG4gICAqIG9mIHRoZSByYXN0ZXIgaXMgcmVhZCBmb3IgZWFjaCBzYW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhZFJhc3Rlck9wdGlvbnN9IFtvcHRpb25zPXt9XSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjwoVHlwZWRBcnJheXxUeXBlZEFycmF5W10pPn0gdGhlIGRlY29kZWQgYXJyYXlzIGFzIGEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVhZFJhc3RlcnMoe1xuICAgIHdpbmRvdzogd25kLCBzYW1wbGVzID0gW10sIGludGVybGVhdmUsIHBvb2wgPSBudWxsLFxuICAgIHdpZHRoLCBoZWlnaHQsIHJlc2FtcGxlTWV0aG9kLCBmaWxsVmFsdWUsIHNpZ25hbCxcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgaW1hZ2VXaW5kb3cgPSB3bmQgfHwgWzAsIDAsIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKV07XG5cbiAgICAvLyBjaGVjayBwYXJhbWV0ZXJzXG4gICAgaWYgKGltYWdlV2luZG93WzBdID4gaW1hZ2VXaW5kb3dbMl0gfHwgaW1hZ2VXaW5kb3dbMV0gPiBpbWFnZVdpbmRvd1szXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNldHMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZVdpbmRvd1dpZHRoID0gaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXTtcbiAgICBjb25zdCBpbWFnZVdpbmRvd0hlaWdodCA9IGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV07XG4gICAgY29uc3QgbnVtUGl4ZWxzID0gaW1hZ2VXaW5kb3dXaWR0aCAqIGltYWdlV2luZG93SGVpZ2h0O1xuICAgIGNvbnN0IHNhbXBsZXNQZXJQaXhlbCA9IHRoaXMuZ2V0U2FtcGxlc1BlclBpeGVsKCk7XG5cbiAgICBpZiAoIXNhbXBsZXMgfHwgIXNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXNQZXJQaXhlbDsgKytpKSB7XG4gICAgICAgIHNhbXBsZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzYW1wbGVzW2ldID49IHNhbXBsZXNQZXJQaXhlbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBzYW1wbGUgaW5kZXggJyR7c2FtcGxlc1tpXX0nLmApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdmFsdWVBcnJheXM7XG4gICAgaWYgKGludGVybGVhdmUpIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRcbiAgICAgICAgPyBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0KSA6IDE7XG4gICAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUpO1xuICAgICAgdmFsdWVBcnJheXMgPSBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBudW1QaXhlbHMgKiBzYW1wbGVzLmxlbmd0aCk7XG4gICAgICBpZiAoZmlsbFZhbHVlKSB7XG4gICAgICAgIHZhbHVlQXJyYXlzLmZpbGwoZmlsbFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVBcnJheXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB2YWx1ZUFycmF5ID0gdGhpcy5nZXRBcnJheUZvclNhbXBsZShzYW1wbGVzW2ldLCBudW1QaXhlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxsVmFsdWUpICYmIGkgPCBmaWxsVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsdWVBcnJheS5maWxsKGZpbGxWYWx1ZVtpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbFZhbHVlICYmICFBcnJheS5pc0FycmF5KGZpbGxWYWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZUFycmF5LmZpbGwoZmlsbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZUFycmF5cy5wdXNoKHZhbHVlQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBvb2xPckRlY29kZXIgPSBwb29sIHx8IGF3YWl0IGdldERlY29kZXIodGhpcy5maWxlRGlyZWN0b3J5KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3JlYWRSYXN0ZXIoXG4gICAgICBpbWFnZVdpbmRvdywgc2FtcGxlcywgdmFsdWVBcnJheXMsIGludGVybGVhdmUsIHBvb2xPckRlY29kZXIsIHdpZHRoLCBoZWlnaHQsIHJlc2FtcGxlTWV0aG9kLCBzaWduYWwsXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGltYWdlIGFzIFJHQi4gVGhlIHJlc3VsdCBpcyBhbHdheXMgYW5cbiAgICogaW50ZXJsZWF2ZWQgdHlwZWQgYXJyYXkuXG4gICAqIENvbG9yc3BhY2VzIG90aGVyIHRoYW4gUkdCIHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gUkdCLCBjb2xvciBtYXBzIGV4cGFuZGVkLlxuICAgKiBXaGVuIG5vIG90aGVyIG1ldGhvZCBpcyBhcHBsaWNhYmxlLCB0aGUgZmlyc3Qgc2FtcGxlIGlzIHVzZWQgdG8gcHJvZHVjZSBhXG4gICAqIGdyZWF5c2NhbGUgaW1hZ2UuXG4gICAqIFdoZW4gcHJvdmlkZWQsIG9ubHkgYSBzdWJzZXQgb2YgdGhlIHJhc3RlciBpcyByZWFkIGZvciBlYWNoIHNhbXBsZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMud2luZG93XSB0aGUgc3Vic2V0IHRvIHJlYWQgZGF0YSBmcm9tIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbnRlcmxlYXZlPXRydWVdIHdoZXRoZXIgdGhlIGRhdGEgc2hhbGwgYmUgcmVhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG9uZSBzaW5nbGUgYXJyYXkgb3Igc2VwYXJhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW90aWZmXCIpLlBvb2x9IFtvcHRpb25zLnBvb2w9bnVsbF0gVGhlIG9wdGlvbmFsIGRlY29kZXIgcG9vbCB0byB1c2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZSBhcyB0aGUgaW1hZ2VzLCByZXNhbXBsaW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlc2FtcGxlTWV0aG9kPSduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlQWxwaGE9ZmFsc2VdIEVuYWJsZSByZWFkaW5nIGFscGhhIGNoYW5uZWwgaWYgcHJlc2VudC5cbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW29wdGlvbnMuc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFR5cGVkQXJyYXl8VHlwZWRBcnJheVtdPn0gdGhlIFJHQiBhcnJheSBhcyBhIFByb21pc2VcbiAgICovXG4gIGFzeW5jIHJlYWRSR0IoeyB3aW5kb3csIGludGVybGVhdmUgPSB0cnVlLCBwb29sID0gbnVsbCwgd2lkdGgsIGhlaWdodCxcbiAgICByZXNhbXBsZU1ldGhvZCwgZW5hYmxlQWxwaGEgPSBmYWxzZSwgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IGltYWdlV2luZG93ID0gd2luZG93IHx8IFswLCAwLCB0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuXG4gICAgLy8gY2hlY2sgcGFyYW1ldGVyc1xuICAgIGlmIChpbWFnZVdpbmRvd1swXSA+IGltYWdlV2luZG93WzJdIHx8IGltYWdlV2luZG93WzFdID4gaW1hZ2VXaW5kb3dbM10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzZXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGkgPSB0aGlzLmZpbGVEaXJlY3RvcnkuUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbjtcblxuICAgIGlmIChwaSA9PT0gcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUkdCKSB7XG4gICAgICBsZXQgcyA9IFswLCAxLCAyXTtcbiAgICAgIGlmICgoISh0aGlzLmZpbGVEaXJlY3RvcnkuRXh0cmFTYW1wbGVzID09PSBFeHRyYVNhbXBsZXNWYWx1ZXMuVW5zcGVjaWZpZWQpKSAmJiBlbmFibGVBbHBoYSkge1xuICAgICAgICBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlYWRSYXN0ZXJzKHtcbiAgICAgICAgd2luZG93LFxuICAgICAgICBpbnRlcmxlYXZlLFxuICAgICAgICBzYW1wbGVzOiBzLFxuICAgICAgICBwb29sLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHNhbXBsZXM7XG4gICAgc3dpdGNoIChwaSkge1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5XaGl0ZUlzWmVybzpcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQmxhY2tJc1plcm86XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLlBhbGV0dGU6XG4gICAgICAgIHNhbXBsZXMgPSBbMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DTVlLOlxuICAgICAgICBzYW1wbGVzID0gWzAsIDEsIDIsIDNdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuWUNiQ3I6XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNJRUxhYjpcbiAgICAgICAgc2FtcGxlcyA9IFswLCAxLCAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgcGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb24uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViT3B0aW9ucyA9IHtcbiAgICAgIHdpbmRvdzogaW1hZ2VXaW5kb3csXG4gICAgICBpbnRlcmxlYXZlOiB0cnVlLFxuICAgICAgc2FtcGxlcyxcbiAgICAgIHBvb2wsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgc2lnbmFsLFxuICAgIH07XG4gICAgY29uc3QgeyBmaWxlRGlyZWN0b3J5IH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhc3RlciA9IGF3YWl0IHRoaXMucmVhZFJhc3RlcnMoc3ViT3B0aW9ucyk7XG5cbiAgICBjb25zdCBtYXggPSAyICoqIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlWzBdO1xuICAgIGxldCBkYXRhO1xuICAgIHN3aXRjaCAocGkpIHtcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuV2hpdGVJc1plcm86XG4gICAgICAgIGRhdGEgPSBmcm9tV2hpdGVJc1plcm8ocmFzdGVyLCBtYXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQmxhY2tJc1plcm86XG4gICAgICAgIGRhdGEgPSBmcm9tQmxhY2tJc1plcm8ocmFzdGVyLCBtYXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUGFsZXR0ZTpcbiAgICAgICAgZGF0YSA9IGZyb21QYWxldHRlKHJhc3RlciwgZmlsZURpcmVjdG9yeS5Db2xvck1hcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DTVlLOlxuICAgICAgICBkYXRhID0gZnJvbUNNWUsocmFzdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLllDYkNyOlxuICAgICAgICBkYXRhID0gZnJvbVlDYkNyKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DSUVMYWI6XG4gICAgICAgIGRhdGEgPSBmcm9tQ0lFTGFiKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwaG90b21ldHJpYyBpbnRlcnByZXRhdGlvbi4nKTtcbiAgICB9XG5cbiAgICAvLyBpZiBub24taW50ZXJsZWF2ZWQgZGF0YSBpcyByZXF1ZXN0ZWQsIHdlIG11c3Qgc3BsaXQgdGhlIGNoYW5uZWxzXG4gICAgLy8gaW50byB0aGVpciByZXNwZWN0aXZlIGFycmF5c1xuICAgIGlmICghaW50ZXJsZWF2ZSkge1xuICAgICAgY29uc3QgcmVkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGNvbnN0IGdyZWVuID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGNvbnN0IGJsdWUgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMywgKytqKSB7XG4gICAgICAgIHJlZFtqXSA9IGRhdGFbaV07XG4gICAgICAgIGdyZWVuW2pdID0gZGF0YVtpICsgMV07XG4gICAgICAgIGJsdWVbal0gPSBkYXRhW2kgKyAyXTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBbcmVkLCBncmVlbiwgYmx1ZV07XG4gICAgfVxuXG4gICAgZGF0YS53aWR0aCA9IHJhc3Rlci53aWR0aDtcbiAgICBkYXRhLmhlaWdodCA9IHJhc3Rlci5oZWlnaHQ7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aWVwb2ludHMuXG4gICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICovXG4gIGdldFRpZVBvaW50cygpIHtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdGllUG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgdGllUG9pbnRzLnB1c2goe1xuICAgICAgICBpOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpXSxcbiAgICAgICAgajogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDFdLFxuICAgICAgICBrOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgMl0sXG4gICAgICAgIHg6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyAzXSxcbiAgICAgICAgeTogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDRdLFxuICAgICAgICB6OiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgNV0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpZVBvaW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJzZWQgR0RBTCBtZXRhZGF0YSBpdGVtcy5cbiAgICpcbiAgICogSWYgc2FtcGxlIGlzIHBhc3NlZCB0byBudWxsLCBkYXRhc2V0LWxldmVsIG1ldGFkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBvbmx5IG1ldGFkYXRhIHNwZWNpZmljIHRvIHRoZSBwcm92aWRlZCBzYW1wbGUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGU9bnVsbF0gVGhlIHNhbXBsZSBpbmRleC5cbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldEdEQUxNZXRhZGF0YShzYW1wbGUgPSBudWxsKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5HREFMX01FVEFEQVRBKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTUVUQURBVEE7XG5cbiAgICBsZXQgaXRlbXMgPSBmaW5kVGFnc0J5TmFtZShzdHJpbmcsICdJdGVtJyk7XG5cbiAgICBpZiAoc2FtcGxlID09PSBudWxsKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gZ2V0QXR0cmlidXRlKGl0ZW0sICdzYW1wbGUnKSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IE51bWJlcihnZXRBdHRyaWJ1dGUoaXRlbSwgJ3NhbXBsZScpKSA9PT0gc2FtcGxlKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBtZXRhZGF0YVtnZXRBdHRyaWJ1dGUoaXRlbSwgJ25hbWUnKV0gPSBpdGVtLmlubmVyO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgR0RBTCBub2RhdGEgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgKi9cbiAgZ2V0R0RBTE5vRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5HREFMX05PREFUQSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuZmlsZURpcmVjdG9yeS5HREFMX05PREFUQTtcbiAgICByZXR1cm4gTnVtYmVyKHN0cmluZy5zdWJzdHJpbmcoMCwgc3RyaW5nLmxlbmd0aCAtIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvcmlnaW4gYXMgYSBYWVotdmVjdG9yLiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lXG4gICAqIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgb3JpZ2luIGFzIGEgdmVjdG9yXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgY29uc3QgdGllUG9pbnRzID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnQ7XG4gICAgY29uc3QgbW9kZWxUcmFuc2Zvcm1hdGlvbiA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuICAgIGlmICh0aWVQb2ludHMgJiYgdGllUG9pbnRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGllUG9pbnRzWzNdLFxuICAgICAgICB0aWVQb2ludHNbNF0sXG4gICAgICAgIHRpZVBvaW50c1s1XSxcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzNdLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzddLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzExXSxcbiAgICAgIF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGltYWdlIGRvZXMgbm90IGhhdmUgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIHJlc29sdXRpb24gYXMgYSBYWVotdmVjdG9yLiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lXG4gICAqIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSB7R2VvVElGRkltYWdlfSBbcmVmZXJlbmNlSW1hZ2U9bnVsbF0gQSByZWZlcmVuY2UgaW1hZ2UgdG8gY2FsY3VsYXRlIHRoZSByZXNvbHV0aW9uIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBjYXNlcyB3aGVuIHRoZSBjdXJyZW50IGltYWdlIGRvZXMgbm90IGhhdmUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQgdGFncyBvbiBpdHMgb3duLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIHJlc29sdXRpb24gYXMgYSB2ZWN0b3JcbiAgICovXG4gIGdldFJlc29sdXRpb24ocmVmZXJlbmNlSW1hZ2UgPSBudWxsKSB7XG4gICAgY29uc3QgbW9kZWxQaXhlbFNjYWxlID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsUGl4ZWxTY2FsZTtcbiAgICBjb25zdCBtb2RlbFRyYW5zZm9ybWF0aW9uID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb247XG5cbiAgICBpZiAobW9kZWxQaXhlbFNjYWxlKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFBpeGVsU2NhbGVbMF0sXG4gICAgICAgIC1tb2RlbFBpeGVsU2NhbGVbMV0sXG4gICAgICAgIG1vZGVsUGl4ZWxTY2FsZVsyXSxcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzBdLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzVdLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzEwXSxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZUltYWdlKSB7XG4gICAgICBjb25zdCBbcmVmUmVzWCwgcmVmUmVzWSwgcmVmUmVzWl0gPSByZWZlcmVuY2VJbWFnZS5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICByZWZSZXNYICogcmVmZXJlbmNlSW1hZ2UuZ2V0V2lkdGgoKSAvIHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgcmVmUmVzWSAqIHJlZmVyZW5jZUltYWdlLmdldEhlaWdodCgpIC8gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgcmVmUmVzWiAqIHJlZmVyZW5jZUltYWdlLmdldFdpZHRoKCkgLyB0aGlzLmdldFdpZHRoKCksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGltYWdlIGRvZXMgbm90IGhhdmUgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBpeGVscyBvZiB0aGUgaW1hZ2UgZGVwaWN0IGFuIGFyZWEgKG9yIHBvaW50KS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHBpeGVscyBhcmUgYSBwb2ludFxuICAgKi9cbiAgcGl4ZWxJc0FyZWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvS2V5cy5HVFJhc3RlclR5cGVHZW9LZXkgPT09IDE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2UgYm91bmRpbmcgYm94IGFzIGFuIGFycmF5IG9mIDQgdmFsdWVzOiBtaW4teCwgbWluLXksXG4gICAqIG1heC14IGFuZCBtYXgteS4gV2hlbiB0aGUgaW1hZ2UgaGFzIG5vIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBhblxuICAgKiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIGJvdW5kaW5nIGJveFxuICAgKi9cbiAgZ2V0Qm91bmRpbmdCb3goKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oKTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG5cbiAgICBjb25zdCB4MSA9IG9yaWdpblswXTtcbiAgICBjb25zdCB5MSA9IG9yaWdpblsxXTtcblxuICAgIGNvbnN0IHgyID0geDEgKyAocmVzb2x1dGlvblswXSAqIHRoaXMuZ2V0V2lkdGgoKSk7XG4gICAgY29uc3QgeTIgPSB5MSArIChyZXNvbHV0aW9uWzFdICogdGhpcy5nZXRIZWlnaHQoKSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgTWF0aC5taW4oeDEsIHgyKSxcbiAgICAgIE1hdGgubWluKHkxLCB5MiksXG4gICAgICBNYXRoLm1heCh4MSwgeDIpLFxuICAgICAgTWF0aC5tYXgoeTEsIHkyKSxcbiAgICBdO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlb1RJRkZJbWFnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiffimage.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiffwriter.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffwriter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"writeGeotiff\": () => (/* binding */ writeGeotiff)\n/* harmony export */ });\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\n\n\n\nconst tagName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagNames);\nconst geoKeyName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.geoKeyNames);\nconst name2code = {};\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, tagName2Code);\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, geoKeyName2Code);\nconst typeName2byte = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.forEach)(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nfunction writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(height, (rowIndex) => {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(width, (columnIndex) => {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmd3JpdGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RjtBQUNuQjs7QUFFdEUscUJBQXFCLGlEQUFNLENBQUMsc0RBQWE7QUFDekMsd0JBQXdCLGlEQUFNLENBQUMsb0RBQVc7QUFDMUM7QUFDQSxpREFBTTtBQUNOLGlEQUFNO0FBQ04sc0JBQXNCLGlEQUFNLENBQUMsdURBQWM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksZ0RBQUs7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLGdEQUFLO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEscUJBQXFCLHNEQUFhO0FBQ2xDOztBQUVBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQ7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsbURBQVE7QUFDbkU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSxnREFBSztBQUNYO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixNQUFNLGdEQUFLO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLE1BQU0sZ0RBQUs7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixNQUFNLGdEQUFLO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFOztBQUVBO0FBQ0EsbUVBQW1FLE1BQU07QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLGdEQUFLO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsRUFBRSxrREFBTztBQUNUO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1QsTUFBTSxnREFBSztBQUNYLFFBQVEsZ0RBQUs7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLGdEQUFLO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixnREFBSztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1EQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DO0FBQ0EsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixxRUFBcUUsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmZ3cml0ZXIuanM/MDMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBTb21lIHBhcnRzIG9mIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gVVRJRi5qcyxcbiAgd2hpY2ggd2FzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAgWW91IGNhbiB2aWV3IHRoYXQgaGVyZTpcbiAgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1VUSUYuanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbmltcG9ydCB7IGZpZWxkVGFnTmFtZXMsIGZpZWxkVGFnVHlwZXMsIGZpZWxkVHlwZU5hbWVzLCBnZW9LZXlOYW1lcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyBhc3NpZ24sIGVuZHNXaXRoLCBmb3JFYWNoLCBpbnZlcnQsIHRpbWVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IHRhZ05hbWUyQ29kZSA9IGludmVydChmaWVsZFRhZ05hbWVzKTtcbmNvbnN0IGdlb0tleU5hbWUyQ29kZSA9IGludmVydChnZW9LZXlOYW1lcyk7XG5jb25zdCBuYW1lMmNvZGUgPSB7fTtcbmFzc2lnbihuYW1lMmNvZGUsIHRhZ05hbWUyQ29kZSk7XG5hc3NpZ24obmFtZTJjb2RlLCBnZW9LZXlOYW1lMkNvZGUpO1xuY29uc3QgdHlwZU5hbWUyYnl0ZSA9IGludmVydChmaWVsZFR5cGVOYW1lcyk7XG5cbi8vIGNvbmZpZyB2YXJpYWJsZXNcbmNvbnN0IG51bUJ5dGVzSW5JZmQgPSAxMDAwO1xuXG5jb25zdCBfYmluQkUgPSB7XG4gIG5leHRaZXJvOiAoZGF0YSwgbykgPT4ge1xuICAgIGxldCBvaW5jciA9IG87XG4gICAgd2hpbGUgKGRhdGFbb2luY3JdICE9PSAwKSB7XG4gICAgICBvaW5jcisrO1xuICAgIH1cbiAgICByZXR1cm4gb2luY3I7XG4gIH0sXG4gIHJlYWRVc2hvcnQ6IChidWZmLCBwKSA9PiB7XG4gICAgcmV0dXJuIChidWZmW3BdIDw8IDgpIHwgYnVmZltwICsgMV07XG4gIH0sXG4gIHJlYWRTaG9ydDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICBhWzBdID0gYnVmZltwICsgMV07XG4gICAgYVsxXSA9IGJ1ZmZbcCArIDBdO1xuICAgIHJldHVybiBfYmluQkUuaTE2WzBdO1xuICB9LFxuICByZWFkSW50OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIGFbMF0gPSBidWZmW3AgKyAzXTtcbiAgICBhWzFdID0gYnVmZltwICsgMl07XG4gICAgYVsyXSA9IGJ1ZmZbcCArIDFdO1xuICAgIGFbM10gPSBidWZmW3AgKyAwXTtcbiAgICByZXR1cm4gX2JpbkJFLmkzMlswXTtcbiAgfSxcbiAgcmVhZFVpbnQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgYVswXSA9IGJ1ZmZbcCArIDNdO1xuICAgIGFbMV0gPSBidWZmW3AgKyAyXTtcbiAgICBhWzJdID0gYnVmZltwICsgMV07XG4gICAgYVszXSA9IGJ1ZmZbcCArIDBdO1xuICAgIHJldHVybiBfYmluQkUudWkzMlswXTtcbiAgfSxcbiAgcmVhZEFTQ0lJOiAoYnVmZiwgcCwgbCkgPT4ge1xuICAgIHJldHVybiBsLm1hcCgoaSkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmW3AgKyBpXSkpLmpvaW4oJycpO1xuICB9LFxuICByZWFkRmxvYXQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgdGltZXMoNCwgKGkpID0+IHtcbiAgICAgIGFbaV0gPSBidWZmW3AgKyAzIC0gaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIF9iaW5CRS5mbDMyWzBdO1xuICB9LFxuICByZWFkRG91YmxlOiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIHRpbWVzKDgsIChpKSA9PiB7XG4gICAgICBhW2ldID0gYnVmZltwICsgNyAtIGldO1xuICAgIH0pO1xuICAgIHJldHVybiBfYmluQkUuZmw2NFswXTtcbiAgfSxcbiAgd3JpdGVVc2hvcnQ6IChidWZmLCBwLCBuKSA9PiB7XG4gICAgYnVmZltwXSA9IChuID4+IDgpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDFdID0gbiAmIDI1NTtcbiAgfSxcbiAgd3JpdGVVaW50OiAoYnVmZiwgcCwgbikgPT4ge1xuICAgIGJ1ZmZbcF0gPSAobiA+PiAyNCkgJiAyNTU7XG4gICAgYnVmZltwICsgMV0gPSAobiA+PiAxNikgJiAyNTU7XG4gICAgYnVmZltwICsgMl0gPSAobiA+PiA4KSAmIDI1NTtcbiAgICBidWZmW3AgKyAzXSA9IChuID4+IDApICYgMjU1O1xuICB9LFxuICB3cml0ZUFTQ0lJOiAoYnVmZiwgcCwgcykgPT4ge1xuICAgIHRpbWVzKHMubGVuZ3RoLCAoaSkgPT4ge1xuICAgICAgYnVmZltwICsgaV0gPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgfSk7XG4gIH0sXG4gIHVpODogbmV3IFVpbnQ4QXJyYXkoOCksXG59O1xuXG5fYmluQkUuZmw2NCA9IG5ldyBGbG9hdDY0QXJyYXkoX2JpbkJFLnVpOC5idWZmZXIpO1xuXG5fYmluQkUud3JpdGVEb3VibGUgPSAoYnVmZiwgcCwgbikgPT4ge1xuICBfYmluQkUuZmw2NFswXSA9IG47XG4gIHRpbWVzKDgsIChpKSA9PiB7XG4gICAgYnVmZltwICsgaV0gPSBfYmluQkUudWk4WzcgLSBpXTtcbiAgfSk7XG59O1xuXG5jb25zdCBfd3JpdGVJRkQgPSAoYmluLCBkYXRhLCBfb2Zmc2V0LCBpZmQpID0+IHtcbiAgbGV0IG9mZnNldCA9IF9vZmZzZXQ7XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlmZCkuZmlsdGVyKChrZXkpID0+IHtcbiAgICByZXR1cm4ga2V5ICE9PSB1bmRlZmluZWQgJiYga2V5ICE9PSBudWxsICYmIGtleSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0pO1xuXG4gIGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIGtleXMubGVuZ3RoKTtcbiAgb2Zmc2V0ICs9IDI7XG5cbiAgbGV0IGVvZmYgPSBvZmZzZXQgKyAoMTIgKiBrZXlzLmxlbmd0aCkgKyA0O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRhZyA9IGtleTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YWcgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlTmFtZSA9IGZpZWxkVGFnVHlwZXNbdGFnXTtcbiAgICBjb25zdCB0eXBlTnVtID0gdHlwZU5hbWUyYnl0ZVt0eXBlTmFtZV07XG5cbiAgICBpZiAodHlwZU5hbWUgPT0gbnVsbCB8fCB0eXBlTmFtZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlTmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlIG9mIHRhZzogJHt0YWd9YCk7XG4gICAgfVxuXG4gICAgbGV0IHZhbCA9IGlmZFtrZXldO1xuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBnZXQgdmFsdWUgZm9yIGtleSAke2tleX1gKTtcbiAgICB9XG5cbiAgICAvLyBBU0NJSVogZm9ybWF0IHdpdGggdHJhaWxpbmcgMCBjaGFyYWN0ZXJcbiAgICAvLyBodHRwOi8vd3d3LmZpbGVmb3JtYXQuaW5mby9mb3JtYXQvdGlmZi9jb3Jpb24uaHRtXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzc4MzA0NC93aGF0cy10aGUtZGlmZmVyZW5jZS1iZXR3ZWVuLWFzY2lpei12cy1hc2NpaVxuICAgIGlmICh0eXBlTmFtZSA9PT0gJ0FTQ0lJJyAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiBlbmRzV2l0aCh2YWwsICdcXHUwMDAwJykgPT09IGZhbHNlKSB7XG4gICAgICB2YWwgKz0gJ1xcdTAwMDAnO1xuICAgIH1cblxuICAgIGNvbnN0IG51bSA9IHZhbC5sZW5ndGg7XG5cbiAgICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgb2Zmc2V0LCB0YWcpO1xuICAgIG9mZnNldCArPSAyO1xuXG4gICAgYmluLndyaXRlVXNob3J0KGRhdGEsIG9mZnNldCwgdHlwZU51bSk7XG4gICAgb2Zmc2V0ICs9IDI7XG5cbiAgICBiaW4ud3JpdGVVaW50KGRhdGEsIG9mZnNldCwgbnVtKTtcbiAgICBvZmZzZXQgKz0gNDtcblxuICAgIGxldCBkbGVuID0gWy0xLCAxLCAxLCAyLCA0LCA4LCAwLCAwLCAwLCAwLCAwLCAwLCA4XVt0eXBlTnVtXSAqIG51bTtcbiAgICBsZXQgdG9mZiA9IG9mZnNldDtcblxuICAgIGlmIChkbGVuID4gNCkge1xuICAgICAgYmluLndyaXRlVWludChkYXRhLCBvZmZzZXQsIGVvZmYpO1xuICAgICAgdG9mZiA9IGVvZmY7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVOYW1lID09PSAnQVNDSUknKSB7XG4gICAgICBiaW4ud3JpdGVBU0NJSShkYXRhLCB0b2ZmLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdTSE9SVCcpIHtcbiAgICAgIHRpbWVzKG51bSwgKGkpID0+IHtcbiAgICAgICAgYmluLndyaXRlVXNob3J0KGRhdGEsIHRvZmYgKyAoMiAqIGkpLCB2YWxbaV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ0xPTkcnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgdG9mZiArICg0ICogaSksIHZhbFtpXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnUkFUSU9OQUwnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgdG9mZiArICg4ICogaSksIE1hdGgucm91bmQodmFsW2ldICogMTAwMDApKTtcbiAgICAgICAgYmluLndyaXRlVWludChkYXRhLCB0b2ZmICsgKDggKiBpKSArIDQsIDEwMDAwKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdET1VCTEUnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZURvdWJsZShkYXRhLCB0b2ZmICsgKDggKiBpKSwgdmFsW2ldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkbGVuID4gNCkge1xuICAgICAgZGxlbiArPSAoZGxlbiAmIDEpO1xuICAgICAgZW9mZiArPSBkbGVuO1xuICAgIH1cblxuICAgIG9mZnNldCArPSA0O1xuICB9XG5cbiAgcmV0dXJuIFtvZmZzZXQsIGVvZmZdO1xufTtcblxuY29uc3QgZW5jb2RlSWZkcyA9IChpZmRzKSA9PiB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShudW1CeXRlc0luSWZkKTtcbiAgbGV0IG9mZnNldCA9IDQ7XG4gIGNvbnN0IGJpbiA9IF9iaW5CRTtcblxuICAvLyBzZXQgYmlnLWVuZGlhbiBieXRlLW9yZGVyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RJRkYjQnl0ZV9vcmRlclxuICBkYXRhWzBdID0gNzc7XG4gIGRhdGFbMV0gPSA3NztcblxuICAvLyBzZXQgZm9ybWF0LXZlcnNpb24gbnVtYmVyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RJRkYjQnl0ZV9vcmRlclxuICBkYXRhWzNdID0gNDI7XG5cbiAgbGV0IGlmZG8gPSA4O1xuXG4gIGJpbi53cml0ZVVpbnQoZGF0YSwgb2Zmc2V0LCBpZmRvKTtcblxuICBvZmZzZXQgKz0gNDtcblxuICBpZmRzLmZvckVhY2goKGlmZCwgaSkgPT4ge1xuICAgIGNvbnN0IG5vZmZzID0gX3dyaXRlSUZEKGJpbiwgZGF0YSwgaWZkbywgaWZkKTtcbiAgICBpZmRvID0gbm9mZnNbMV07XG4gICAgaWYgKGkgPCBpZmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgbm9mZnNbMF0sIGlmZG8pO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRhdGEuc2xpY2UpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBpZmRvKS5idWZmZXI7XG4gIH1cblxuICAvLyBub2RlIGhhc24ndCBpbXBsZW1lbnRlZCBzbGljZSBvbiBVaW50OEFycmF5IHlldFxuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShpZmRvKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZmRvOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBkYXRhW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcblxuY29uc3QgZW5jb2RlSW1hZ2UgPSAodmFsdWVzLCB3aWR0aCwgaGVpZ2h0LCBtZXRhZGF0YSkgPT4ge1xuICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB5b3UgcGFzc2VkIGludG8gZW5jb2RlSW1hZ2UgYSB3aWR0aCBvZiB0eXBlICR7aGVpZ2h0fWApO1xuICB9XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgd2lkdGggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHlvdSBwYXNzZWQgaW50byBlbmNvZGVJbWFnZSBhIHdpZHRoIG9mIHR5cGUgJHt3aWR0aH1gKTtcbiAgfVxuXG4gIGNvbnN0IGlmZCA9IHtcbiAgICAyNTY6IFt3aWR0aF0sIC8vIEltYWdlV2lkdGhcbiAgICAyNTc6IFtoZWlnaHRdLCAvLyBJbWFnZUxlbmd0aFxuICAgIDI3MzogW251bUJ5dGVzSW5JZmRdLCAvLyBzdHJpcHMgb2Zmc2V0XG4gICAgMjc4OiBbaGVpZ2h0XSwgLy8gUm93c1BlclN0cmlwXG4gICAgMzA1OiAnZ2VvdGlmZi5qcycsIC8vIG5vIGFycmF5IGZvciBBU0NJSShaKVxuICB9O1xuXG4gIGlmIChtZXRhZGF0YSkge1xuICAgIGZvciAoY29uc3QgaSBpbiBtZXRhZGF0YSkge1xuICAgICAgaWYgKG1ldGFkYXRhLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmZFtpXSA9IG1ldGFkYXRhW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByZnggPSBuZXcgVWludDhBcnJheShlbmNvZGVJZmRzKFtpZmRdKSk7XG5cbiAgY29uc3QgaW1nID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzKTtcblxuICBjb25zdCBzYW1wbGVzUGVyUGl4ZWwgPSBpZmRbMjc3XTtcblxuICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXNJbklmZCArICh3aWR0aCAqIGhlaWdodCAqIHNhbXBsZXNQZXJQaXhlbCkpO1xuICB0aW1lcyhwcmZ4Lmxlbmd0aCwgKGkpID0+IHtcbiAgICBkYXRhW2ldID0gcHJmeFtpXTtcbiAgfSk7XG4gIGZvckVhY2goaW1nLCAodmFsdWUsIGkpID0+IHtcbiAgICBkYXRhW251bUJ5dGVzSW5JZmQgKyBpXSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gZGF0YS5idWZmZXI7XG59O1xuXG5jb25zdCBjb252ZXJ0VG9UaWRzID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgIGlmIChrZXkgIT09ICdTdHJpcE9mZnNldHMnKSB7XG4gICAgICBpZiAoIW5hbWUyY29kZVtrZXldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3Ioa2V5LCAnbm90IGluIG5hbWUyY29kZTonLCBPYmplY3Qua2V5cyhuYW1lMmNvZGUpKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdFtuYW1lMmNvZGVba2V5XV0gPSBpbnB1dFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgdG9BcnJheSA9IChpbnB1dCkgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIFtpbnB1dF07XG59O1xuXG5jb25zdCBtZXRhZGF0YURlZmF1bHRzID0gW1xuICBbJ0NvbXByZXNzaW9uJywgMV0sIC8vIG5vIGNvbXByZXNzaW9uXG4gIFsnUGxhbmFyQ29uZmlndXJhdGlvbicsIDFdLFxuICBbJ0V4dHJhU2FtcGxlcycsIDBdLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlR2VvdGlmZihkYXRhLCBtZXRhZGF0YSkge1xuICBjb25zdCBpc0ZsYXR0ZW5lZCA9IHR5cGVvZiBkYXRhWzBdID09PSAnbnVtYmVyJztcblxuICBsZXQgaGVpZ2h0O1xuICBsZXQgbnVtQmFuZHM7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGZsYXR0ZW5lZFZhbHVlcztcblxuICBpZiAoaXNGbGF0dGVuZWQpIHtcbiAgICBoZWlnaHQgPSBtZXRhZGF0YS5oZWlnaHQgfHwgbWV0YWRhdGEuSW1hZ2VMZW5ndGg7XG4gICAgd2lkdGggPSBtZXRhZGF0YS53aWR0aCB8fCBtZXRhZGF0YS5JbWFnZVdpZHRoO1xuICAgIG51bUJhbmRzID0gZGF0YS5sZW5ndGggLyAoaGVpZ2h0ICogd2lkdGgpO1xuICAgIGZsYXR0ZW5lZFZhbHVlcyA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgbnVtQmFuZHMgPSBkYXRhLmxlbmd0aDtcbiAgICBoZWlnaHQgPSBkYXRhWzBdLmxlbmd0aDtcbiAgICB3aWR0aCA9IGRhdGFbMF1bMF0ubGVuZ3RoO1xuICAgIGZsYXR0ZW5lZFZhbHVlcyA9IFtdO1xuICAgIHRpbWVzKGhlaWdodCwgKHJvd0luZGV4KSA9PiB7XG4gICAgICB0aW1lcyh3aWR0aCwgKGNvbHVtbkluZGV4KSA9PiB7XG4gICAgICAgIHRpbWVzKG51bUJhbmRzLCAoYmFuZEluZGV4KSA9PiB7XG4gICAgICAgICAgZmxhdHRlbmVkVmFsdWVzLnB1c2goZGF0YVtiYW5kSW5kZXhdW3Jvd0luZGV4XVtjb2x1bW5JbmRleF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgbWV0YWRhdGEuSW1hZ2VMZW5ndGggPSBoZWlnaHQ7XG4gIGRlbGV0ZSBtZXRhZGF0YS5oZWlnaHQ7XG4gIG1ldGFkYXRhLkltYWdlV2lkdGggPSB3aWR0aDtcbiAgZGVsZXRlIG1ldGFkYXRhLndpZHRoO1xuXG4gIC8vIGNvbnN1bHQgaHR0cHM6Ly93d3cubG9jLmdvdi9wcmVzZXJ2YXRpb24vZGlnaXRhbC9mb3JtYXRzL2NvbnRlbnQvdGlmZl90YWdzLnNodG1sXG5cbiAgaWYgKCFtZXRhZGF0YS5CaXRzUGVyU2FtcGxlKSB7XG4gICAgbWV0YWRhdGEuQml0c1BlclNhbXBsZSA9IHRpbWVzKG51bUJhbmRzLCAoKSA9PiA4KTtcbiAgfVxuXG4gIG1ldGFkYXRhRGVmYXVsdHMuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gdGFnWzBdO1xuICAgIGlmICghbWV0YWRhdGFba2V5XSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0YWdbMV07XG4gICAgICBtZXRhZGF0YVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBUaGUgY29sb3Igc3BhY2Ugb2YgdGhlIGltYWdlIGRhdGEuXG4gIC8vIDE9YmxhY2sgaXMgemVybyBhbmQgMj1SR0IuXG4gIGlmICghbWV0YWRhdGEuUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbikge1xuICAgIG1ldGFkYXRhLlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gPSBtZXRhZGF0YS5CaXRzUGVyU2FtcGxlLmxlbmd0aCA9PT0gMyA/IDIgOiAxO1xuICB9XG5cbiAgLy8gVGhlIG51bWJlciBvZiBjb21wb25lbnRzIHBlciBwaXhlbC5cbiAgaWYgKCFtZXRhZGF0YS5TYW1wbGVzUGVyUGl4ZWwpIHtcbiAgICBtZXRhZGF0YS5TYW1wbGVzUGVyUGl4ZWwgPSBbbnVtQmFuZHNdO1xuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5TdHJpcEJ5dGVDb3VudHMpIHtcbiAgICAvLyB3ZSBhcmUgb25seSB3cml0aW5nIG9uZSBzdHJpcFxuICAgIG1ldGFkYXRhLlN0cmlwQnl0ZUNvdW50cyA9IFtudW1CYW5kcyAqIGhlaWdodCAqIHdpZHRoXTtcbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuTW9kZWxQaXhlbFNjYWxlKSB7XG4gICAgLy8gYXNzdW1lcyByYXN0ZXIgdGFrZXMgdXAgZXhhY3RseSB0aGUgd2hvbGUgZ2xvYmVcbiAgICBtZXRhZGF0YS5Nb2RlbFBpeGVsU2NhbGUgPSBbMzYwIC8gd2lkdGgsIDE4MCAvIGhlaWdodCwgMF07XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLlNhbXBsZUZvcm1hdCkge1xuICAgIG1ldGFkYXRhLlNhbXBsZUZvcm1hdCA9IHRpbWVzKG51bUJhbmRzLCAoKSA9PiAxKTtcbiAgfVxuXG4gIC8vIGlmIGRpZG4ndCBwYXNzIGluIHByb2plY3Rpb24gaW5mb3JtYXRpb24sIGFzc3VtZSB0aGUgcG9wdWxhciA0MzI2IFwiZ2VvZ3JhcGhpYyBwcm9qZWN0aW9uXCJcbiAgaWYgKCFtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eSgnR2VvZ3JhcGhpY1R5cGVHZW9LZXknKSAmJiAhbWV0YWRhdGEuaGFzT3duUHJvcGVydHkoJ1Byb2plY3RlZENTVHlwZUdlb0tleScpKSB7XG4gICAgbWV0YWRhdGEuR2VvZ3JhcGhpY1R5cGVHZW9LZXkgPSA0MzI2O1xuICAgIG1ldGFkYXRhLk1vZGVsVGllcG9pbnQgPSBbMCwgMCwgMCwgLTE4MCwgOTAsIDBdOyAvLyByYXN0ZXIgZml0cyB3aG9sZSBnbG9iZVxuICAgIG1ldGFkYXRhLkdlb2dDaXRhdGlvbkdlb0tleSA9ICdXR1MgODQnO1xuICAgIG1ldGFkYXRhLkdUTW9kZWxUeXBlR2VvS2V5ID0gMjtcbiAgfVxuXG4gIGNvbnN0IGdlb0tleXMgPSBPYmplY3Qua2V5cyhtZXRhZGF0YSlcbiAgICAuZmlsdGVyKChrZXkpID0+IGVuZHNXaXRoKGtleSwgJ0dlb0tleScpKVxuICAgIC5zb3J0KChhLCBiKSA9PiBuYW1lMmNvZGVbYV0gLSBuYW1lMmNvZGVbYl0pO1xuXG4gIGlmICghbWV0YWRhdGEuR2VvQXNjaWlQYXJhbXMpIHtcbiAgICBsZXQgZ2VvQXNjaWlQYXJhbXMgPSAnJztcbiAgICBnZW9LZXlzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIobmFtZTJjb2RlW25hbWVdKTtcbiAgICAgIGNvbnN0IHRhZ1R5cGUgPSBmaWVsZFRhZ1R5cGVzW2NvZGVdO1xuICAgICAgaWYgKHRhZ1R5cGUgPT09ICdBU0NJSScpIHtcbiAgICAgICAgZ2VvQXNjaWlQYXJhbXMgKz0gYCR7bWV0YWRhdGFbbmFtZV0udG9TdHJpbmcoKX1cXHUwMDAwYDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZ2VvQXNjaWlQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgbWV0YWRhdGEuR2VvQXNjaWlQYXJhbXMgPSBnZW9Bc2NpaVBhcmFtcztcbiAgICB9XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLkdlb0tleURpcmVjdG9yeSkge1xuICAgIGNvbnN0IE51bWJlck9mS2V5cyA9IGdlb0tleXMubGVuZ3RoO1xuXG4gICAgY29uc3QgR2VvS2V5RGlyZWN0b3J5ID0gWzEsIDEsIDAsIE51bWJlck9mS2V5c107XG4gICAgZ2VvS2V5cy5mb3JFYWNoKChnZW9LZXkpID0+IHtcbiAgICAgIGNvbnN0IEtleUlEID0gTnVtYmVyKG5hbWUyY29kZVtnZW9LZXldKTtcbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKEtleUlEKTtcblxuICAgICAgbGV0IENvdW50O1xuICAgICAgbGV0IFRJRkZUYWdMb2NhdGlvbjtcbiAgICAgIGxldCB2YWx1ZU9mZnNldDtcbiAgICAgIGlmIChmaWVsZFRhZ1R5cGVzW0tleUlEXSA9PT0gJ1NIT1JUJykge1xuICAgICAgICBDb3VudCA9IDE7XG4gICAgICAgIFRJRkZUYWdMb2NhdGlvbiA9IDA7XG4gICAgICAgIHZhbHVlT2Zmc2V0ID0gbWV0YWRhdGFbZ2VvS2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvS2V5ID09PSAnR2VvZ0NpdGF0aW9uR2VvS2V5Jykge1xuICAgICAgICBDb3VudCA9IG1ldGFkYXRhLkdlb0FzY2lpUGFyYW1zLmxlbmd0aDtcbiAgICAgICAgVElGRlRhZ0xvY2F0aW9uID0gTnVtYmVyKG5hbWUyY29kZS5HZW9Bc2NpaVBhcmFtcyk7XG4gICAgICAgIHZhbHVlT2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbZ2VvdGlmZi5qc10gY291bGRuJ3QgZ2V0IFRJRkZUYWdMb2NhdGlvbiBmb3IgJHtnZW9LZXl9YCk7XG4gICAgICB9XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaChUSUZGVGFnTG9jYXRpb24pO1xuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2goQ291bnQpO1xuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2godmFsdWVPZmZzZXQpO1xuICAgIH0pO1xuICAgIG1ldGFkYXRhLkdlb0tleURpcmVjdG9yeSA9IEdlb0tleURpcmVjdG9yeTtcbiAgfVxuXG4gIC8vIGRlbGV0ZSBHZW9LZXlzIGZyb20gbWV0YWRhdGEsIGJlY2F1c2Ugc3RvcmVkIGluIEdlb0tleURpcmVjdG9yeSB0YWdcbiAgZm9yIChjb25zdCBnZW9LZXkgaW4gZ2VvS2V5cykge1xuICAgIGlmIChnZW9LZXlzLmhhc093blByb3BlcnR5KGdlb0tleSkpIHtcbiAgICAgIGRlbGV0ZSBtZXRhZGF0YVtnZW9LZXldO1xuICAgIH1cbiAgfVxuXG4gIFtcbiAgICAnQ29tcHJlc3Npb24nLFxuICAgICdFeHRyYVNhbXBsZXMnLFxuICAgICdHZW9ncmFwaGljVHlwZUdlb0tleScsXG4gICAgJ0dUTW9kZWxUeXBlR2VvS2V5JyxcbiAgICAnR1RSYXN0ZXJUeXBlR2VvS2V5JyxcbiAgICAnSW1hZ2VMZW5ndGgnLCAvLyBzeW5vbnltIG9mIEltYWdlSGVpZ2h0XG4gICAgJ0ltYWdlV2lkdGgnLFxuICAgICdPcmllbnRhdGlvbicsXG4gICAgJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAgICdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknLFxuICAgICdQbGFuYXJDb25maWd1cmF0aW9uJyxcbiAgICAnUmVzb2x1dGlvblVuaXQnLFxuICAgICdTYW1wbGVzUGVyUGl4ZWwnLFxuICAgICdYUG9zaXRpb24nLFxuICAgICdZUG9zaXRpb24nLFxuICBdLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBpZiAobWV0YWRhdGFbbmFtZV0pIHtcbiAgICAgIG1ldGFkYXRhW25hbWVdID0gdG9BcnJheShtZXRhZGF0YVtuYW1lXSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBlbmNvZGVkTWV0YWRhdGEgPSBjb252ZXJ0VG9UaWRzKG1ldGFkYXRhKTtcblxuICBjb25zdCBvdXRwdXRJbWFnZSA9IGVuY29kZUltYWdlKGZsYXR0ZW5lZFZhbHVlcywgd2lkdGgsIGhlaWdodCwgZW5jb2RlZE1ldGFkYXRhKTtcblxuICByZXR1cm4gb3V0cHV0SW1hZ2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiffwriter.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/globals.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/globals.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ExtraSamplesValues\": () => (/* binding */ ExtraSamplesValues),\n/* harmony export */   \"LercAddCompression\": () => (/* binding */ LercAddCompression),\n/* harmony export */   \"LercParameters\": () => (/* binding */ LercParameters),\n/* harmony export */   \"arrayFields\": () => (/* binding */ arrayFields),\n/* harmony export */   \"fieldTagNames\": () => (/* binding */ fieldTagNames),\n/* harmony export */   \"fieldTagTypes\": () => (/* binding */ fieldTagTypes),\n/* harmony export */   \"fieldTags\": () => (/* binding */ fieldTags),\n/* harmony export */   \"fieldTypeNames\": () => (/* binding */ fieldTypeNames),\n/* harmony export */   \"fieldTypes\": () => (/* binding */ fieldTypes),\n/* harmony export */   \"geoKeyNames\": () => (/* binding */ geoKeyNames),\n/* harmony export */   \"geoKeys\": () => (/* binding */ geoKeys),\n/* harmony export */   \"photometricInterpretations\": () => (/* binding */ photometricInterpretations)\n/* harmony export */ });\nconst fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nconst fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nconst arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nconst fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nconst fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nconst ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nconst LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nconst LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n};\n\nconst geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nconst geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nbG9iYWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2xvYmFscy5qcz8wZTcxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBmaWVsZFRhZ05hbWVzID0ge1xuICAvLyBUSUZGIEJhc2VsaW5lXG4gIDB4MDEzQjogJ0FydGlzdCcsXG4gIDB4MDEwMjogJ0JpdHNQZXJTYW1wbGUnLFxuICAweDAxMDk6ICdDZWxsTGVuZ3RoJyxcbiAgMHgwMTA4OiAnQ2VsbFdpZHRoJyxcbiAgMHgwMTQwOiAnQ29sb3JNYXAnLFxuICAweDAxMDM6ICdDb21wcmVzc2lvbicsXG4gIDB4ODI5ODogJ0NvcHlyaWdodCcsXG4gIDB4MDEzMjogJ0RhdGVUaW1lJyxcbiAgMHgwMTUyOiAnRXh0cmFTYW1wbGVzJyxcbiAgMHgwMTBBOiAnRmlsbE9yZGVyJyxcbiAgMHgwMTIxOiAnRnJlZUJ5dGVDb3VudHMnLFxuICAweDAxMjA6ICdGcmVlT2Zmc2V0cycsXG4gIDB4MDEyMzogJ0dyYXlSZXNwb25zZUN1cnZlJyxcbiAgMHgwMTIyOiAnR3JheVJlc3BvbnNlVW5pdCcsXG4gIDB4MDEzQzogJ0hvc3RDb21wdXRlcicsXG4gIDB4MDEwRTogJ0ltYWdlRGVzY3JpcHRpb24nLFxuICAweDAxMDE6ICdJbWFnZUxlbmd0aCcsXG4gIDB4MDEwMDogJ0ltYWdlV2lkdGgnLFxuICAweDAxMEY6ICdNYWtlJyxcbiAgMHgwMTE5OiAnTWF4U2FtcGxlVmFsdWUnLFxuICAweDAxMTg6ICdNaW5TYW1wbGVWYWx1ZScsXG4gIDB4MDExMDogJ01vZGVsJyxcbiAgMHgwMEZFOiAnTmV3U3ViZmlsZVR5cGUnLFxuICAweDAxMTI6ICdPcmllbnRhdGlvbicsXG4gIDB4MDEwNjogJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAweDAxMUM6ICdQbGFuYXJDb25maWd1cmF0aW9uJyxcbiAgMHgwMTI4OiAnUmVzb2x1dGlvblVuaXQnLFxuICAweDAxMTY6ICdSb3dzUGVyU3RyaXAnLFxuICAweDAxMTU6ICdTYW1wbGVzUGVyUGl4ZWwnLFxuICAweDAxMzE6ICdTb2Z0d2FyZScsXG4gIDB4MDExNzogJ1N0cmlwQnl0ZUNvdW50cycsXG4gIDB4MDExMTogJ1N0cmlwT2Zmc2V0cycsXG4gIDB4MDBGRjogJ1N1YmZpbGVUeXBlJyxcbiAgMHgwMTA3OiAnVGhyZXNoaG9sZGluZycsXG4gIDB4MDExQTogJ1hSZXNvbHV0aW9uJyxcbiAgMHgwMTFCOiAnWVJlc29sdXRpb24nLFxuXG4gIC8vIFRJRkYgRXh0ZW5kZWRcbiAgMHgwMTQ2OiAnQmFkRmF4TGluZXMnLFxuICAweDAxNDc6ICdDbGVhbkZheERhdGEnLFxuICAweDAxNTc6ICdDbGlwUGF0aCcsXG4gIDB4MDE0ODogJ0NvbnNlY3V0aXZlQmFkRmF4TGluZXMnLFxuICAweDAxQjE6ICdEZWNvZGUnLFxuICAweDAxQjI6ICdEZWZhdWx0SW1hZ2VDb2xvcicsXG4gIDB4MDEwRDogJ0RvY3VtZW50TmFtZScsXG4gIDB4MDE1MDogJ0RvdFJhbmdlJyxcbiAgMHgwMTQxOiAnSGFsZnRvbmVIaW50cycsXG4gIDB4MDE1QTogJ0luZGV4ZWQnLFxuICAweDAxNUI6ICdKUEVHVGFibGVzJyxcbiAgMHgwMTFEOiAnUGFnZU5hbWUnLFxuICAweDAxMjk6ICdQYWdlTnVtYmVyJyxcbiAgMHgwMTNEOiAnUHJlZGljdG9yJyxcbiAgMHgwMTNGOiAnUHJpbWFyeUNocm9tYXRpY2l0aWVzJyxcbiAgMHgwMjE0OiAnUmVmZXJlbmNlQmxhY2tXaGl0ZScsXG4gIDB4MDE1MzogJ1NhbXBsZUZvcm1hdCcsXG4gIDB4MDE1NDogJ1NNaW5TYW1wbGVWYWx1ZScsXG4gIDB4MDE1NTogJ1NNYXhTYW1wbGVWYWx1ZScsXG4gIDB4MDIyRjogJ1N0cmlwUm93Q291bnRzJyxcbiAgMHgwMTRBOiAnU3ViSUZEcycsXG4gIDB4MDEyNDogJ1Q0T3B0aW9ucycsXG4gIDB4MDEyNTogJ1Q2T3B0aW9ucycsXG4gIDB4MDE0NTogJ1RpbGVCeXRlQ291bnRzJyxcbiAgMHgwMTQzOiAnVGlsZUxlbmd0aCcsXG4gIDB4MDE0NDogJ1RpbGVPZmZzZXRzJyxcbiAgMHgwMTQyOiAnVGlsZVdpZHRoJyxcbiAgMHgwMTJEOiAnVHJhbnNmZXJGdW5jdGlvbicsXG4gIDB4MDEzRTogJ1doaXRlUG9pbnQnLFxuICAweDAxNTg6ICdYQ2xpcFBhdGhVbml0cycsXG4gIDB4MDExRTogJ1hQb3NpdGlvbicsXG4gIDB4MDIxMTogJ1lDYkNyQ29lZmZpY2llbnRzJyxcbiAgMHgwMjEzOiAnWUNiQ3JQb3NpdGlvbmluZycsXG4gIDB4MDIxMjogJ1lDYkNyU3ViU2FtcGxpbmcnLFxuICAweDAxNTk6ICdZQ2xpcFBhdGhVbml0cycsXG4gIDB4MDExRjogJ1lQb3NpdGlvbicsXG5cbiAgLy8gRVhJRlxuICAweDkyMDI6ICdBcGVydHVyZVZhbHVlJyxcbiAgMHhBMDAxOiAnQ29sb3JTcGFjZScsXG4gIDB4OTAwNDogJ0RhdGVUaW1lRGlnaXRpemVkJyxcbiAgMHg5MDAzOiAnRGF0ZVRpbWVPcmlnaW5hbCcsXG4gIDB4ODc2OTogJ0V4aWYgSUZEJyxcbiAgMHg5MDAwOiAnRXhpZlZlcnNpb24nLFxuICAweDgyOUE6ICdFeHBvc3VyZVRpbWUnLFxuICAweEEzMDA6ICdGaWxlU291cmNlJyxcbiAgMHg5MjA5OiAnRmxhc2gnLFxuICAweEEwMDA6ICdGbGFzaHBpeFZlcnNpb24nLFxuICAweDgyOUQ6ICdGTnVtYmVyJyxcbiAgMHhBNDIwOiAnSW1hZ2VVbmlxdWVJRCcsXG4gIDB4OTIwODogJ0xpZ2h0U291cmNlJyxcbiAgMHg5MjdDOiAnTWFrZXJOb3RlJyxcbiAgMHg5MjAxOiAnU2h1dHRlclNwZWVkVmFsdWUnLFxuICAweDkyODY6ICdVc2VyQ29tbWVudCcsXG5cbiAgLy8gSVBUQ1xuICAweDgzQkI6ICdJUFRDJyxcblxuICAvLyBJQ0NcbiAgMHg4NzczOiAnSUNDIFByb2ZpbGUnLFxuXG4gIC8vIFhNUFxuICAweDAyQkM6ICdYTVAnLFxuXG4gIC8vIEdEQUxcbiAgMHhBNDgwOiAnR0RBTF9NRVRBREFUQScsXG4gIDB4QTQ4MTogJ0dEQUxfTk9EQVRBJyxcblxuICAvLyBQaG90b3Nob3BcbiAgMHg4NjQ5OiAnUGhvdG9zaG9wJyxcblxuICAvLyBHZW9UaWZmXG4gIDB4ODMwRTogJ01vZGVsUGl4ZWxTY2FsZScsXG4gIDB4ODQ4MjogJ01vZGVsVGllcG9pbnQnLFxuICAweDg1RDg6ICdNb2RlbFRyYW5zZm9ybWF0aW9uJyxcbiAgMHg4N0FGOiAnR2VvS2V5RGlyZWN0b3J5JyxcbiAgMHg4N0IwOiAnR2VvRG91YmxlUGFyYW1zJyxcbiAgMHg4N0IxOiAnR2VvQXNjaWlQYXJhbXMnLFxuXG4gIC8vIExFUkNcbiAgMHhDNUYyOiAnTGVyY1BhcmFtZXRlcnMnLFxufTtcblxuZXhwb3J0IGNvbnN0IGZpZWxkVGFncyA9IHt9O1xuZm9yIChjb25zdCBrZXkgaW4gZmllbGRUYWdOYW1lcykge1xuICBpZiAoZmllbGRUYWdOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgZmllbGRUYWdzW2ZpZWxkVGFnTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmllbGRUYWdUeXBlcyA9IHtcbiAgMjU2OiAnU0hPUlQnLFxuICAyNTc6ICdTSE9SVCcsXG4gIDI1ODogJ1NIT1JUJyxcbiAgMjU5OiAnU0hPUlQnLFxuICAyNjI6ICdTSE9SVCcsXG4gIDI3MzogJ0xPTkcnLFxuICAyNzQ6ICdTSE9SVCcsXG4gIDI3NzogJ1NIT1JUJyxcbiAgMjc4OiAnTE9ORycsXG4gIDI3OTogJ0xPTkcnLFxuICAyODI6ICdSQVRJT05BTCcsXG4gIDI4MzogJ1JBVElPTkFMJyxcbiAgMjg0OiAnU0hPUlQnLFxuICAyODY6ICdTSE9SVCcsXG4gIDI4NzogJ1JBVElPTkFMJyxcbiAgMjk2OiAnU0hPUlQnLFxuICAyOTc6ICdTSE9SVCcsXG4gIDMwNTogJ0FTQ0lJJyxcbiAgMzA2OiAnQVNDSUknLFxuICAzMzg6ICdTSE9SVCcsXG4gIDMzOTogJ1NIT1JUJyxcbiAgNTEzOiAnTE9ORycsXG4gIDUxNDogJ0xPTkcnLFxuICAxMDI0OiAnU0hPUlQnLFxuICAxMDI1OiAnU0hPUlQnLFxuICAyMDQ4OiAnU0hPUlQnLFxuICAyMDQ5OiAnQVNDSUknLFxuICAzMDcyOiAnU0hPUlQnLFxuICAzMDczOiAnQVNDSUknLFxuICAzMzU1MDogJ0RPVUJMRScsXG4gIDMzOTIyOiAnRE9VQkxFJyxcbiAgMzQ2NjU6ICdMT05HJyxcbiAgMzQ3MzU6ICdTSE9SVCcsXG4gIDM0NzM3OiAnQVNDSUknLFxuICA0MjExMzogJ0FTQ0lJJyxcbn07XG5cbmV4cG9ydCBjb25zdCBhcnJheUZpZWxkcyA9IFtcbiAgZmllbGRUYWdzLkJpdHNQZXJTYW1wbGUsXG4gIGZpZWxkVGFncy5FeHRyYVNhbXBsZXMsXG4gIGZpZWxkVGFncy5TYW1wbGVGb3JtYXQsXG4gIGZpZWxkVGFncy5TdHJpcEJ5dGVDb3VudHMsXG4gIGZpZWxkVGFncy5TdHJpcE9mZnNldHMsXG4gIGZpZWxkVGFncy5TdHJpcFJvd0NvdW50cyxcbiAgZmllbGRUYWdzLlRpbGVCeXRlQ291bnRzLFxuICBmaWVsZFRhZ3MuVGlsZU9mZnNldHMsXG4gIGZpZWxkVGFncy5TdWJJRkRzLFxuXTtcblxuZXhwb3J0IGNvbnN0IGZpZWxkVHlwZU5hbWVzID0ge1xuICAweDAwMDE6ICdCWVRFJyxcbiAgMHgwMDAyOiAnQVNDSUknLFxuICAweDAwMDM6ICdTSE9SVCcsXG4gIDB4MDAwNDogJ0xPTkcnLFxuICAweDAwMDU6ICdSQVRJT05BTCcsXG4gIDB4MDAwNjogJ1NCWVRFJyxcbiAgMHgwMDA3OiAnVU5ERUZJTkVEJyxcbiAgMHgwMDA4OiAnU1NIT1JUJyxcbiAgMHgwMDA5OiAnU0xPTkcnLFxuICAweDAwMEE6ICdTUkFUSU9OQUwnLFxuICAweDAwMEI6ICdGTE9BVCcsXG4gIDB4MDAwQzogJ0RPVUJMRScsXG4gIC8vIElGRCBvZmZzZXQsIHN1Z2dlc3RlZCBieSBodHRwczovL293bC5waHkucXVlZW5zdS5jYS9+cGhpbC9leGlmdG9vbC9zdGFuZGFyZHMuaHRtbFxuICAweDAwMEQ6ICdJRkQnLFxuICAvLyBpbnRyb2R1Y2VkIGJ5IEJpZ1RJRkZcbiAgMHgwMDEwOiAnTE9ORzgnLFxuICAweDAwMTE6ICdTTE9ORzgnLFxuICAweDAwMTI6ICdJRkQ4Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBmaWVsZFR5cGVzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFR5cGVOYW1lcykge1xuICBpZiAoZmllbGRUeXBlTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGZpZWxkVHlwZXNbZmllbGRUeXBlTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMgPSB7XG4gIFdoaXRlSXNaZXJvOiAwLFxuICBCbGFja0lzWmVybzogMSxcbiAgUkdCOiAyLFxuICBQYWxldHRlOiAzLFxuICBUcmFuc3BhcmVuY3lNYXNrOiA0LFxuICBDTVlLOiA1LFxuICBZQ2JDcjogNixcblxuICBDSUVMYWI6IDgsXG4gIElDQ0xhYjogOSxcbn07XG5cbmV4cG9ydCBjb25zdCBFeHRyYVNhbXBsZXNWYWx1ZXMgPSB7XG4gIFVuc3BlY2lmaWVkOiAwLFxuICBBc3NvY2FscGhhOiAxLFxuICBVbmFzc2FscGhhOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IExlcmNQYXJhbWV0ZXJzID0ge1xuICBWZXJzaW9uOiAwLFxuICBBZGRDb21wcmVzc2lvbjogMSxcbn07XG5cbmV4cG9ydCBjb25zdCBMZXJjQWRkQ29tcHJlc3Npb24gPSB7XG4gIE5vbmU6IDAsXG4gIERlZmxhdGU6IDEsXG59O1xuXG5leHBvcnQgY29uc3QgZ2VvS2V5TmFtZXMgPSB7XG4gIDEwMjQ6ICdHVE1vZGVsVHlwZUdlb0tleScsXG4gIDEwMjU6ICdHVFJhc3RlclR5cGVHZW9LZXknLFxuICAxMDI2OiAnR1RDaXRhdGlvbkdlb0tleScsXG4gIDIwNDg6ICdHZW9ncmFwaGljVHlwZUdlb0tleScsXG4gIDIwNDk6ICdHZW9nQ2l0YXRpb25HZW9LZXknLFxuICAyMDUwOiAnR2VvZ0dlb2RldGljRGF0dW1HZW9LZXknLFxuICAyMDUxOiAnR2VvZ1ByaW1lTWVyaWRpYW5HZW9LZXknLFxuICAyMDUyOiAnR2VvZ0xpbmVhclVuaXRzR2VvS2V5JyxcbiAgMjA1MzogJ0dlb2dMaW5lYXJVbml0U2l6ZUdlb0tleScsXG4gIDIwNTQ6ICdHZW9nQW5ndWxhclVuaXRzR2VvS2V5JyxcbiAgMjA1NTogJ0dlb2dBbmd1bGFyVW5pdFNpemVHZW9LZXknLFxuICAyMDU2OiAnR2VvZ0VsbGlwc29pZEdlb0tleScsXG4gIDIwNTc6ICdHZW9nU2VtaU1ham9yQXhpc0dlb0tleScsXG4gIDIwNTg6ICdHZW9nU2VtaU1pbm9yQXhpc0dlb0tleScsXG4gIDIwNTk6ICdHZW9nSW52RmxhdHRlbmluZ0dlb0tleScsXG4gIDIwNjA6ICdHZW9nQXppbXV0aFVuaXRzR2VvS2V5JyxcbiAgMjA2MTogJ0dlb2dQcmltZU1lcmlkaWFuTG9uZ0dlb0tleScsXG4gIDIwNjI6ICdHZW9nVE9XR1M4NEdlb0tleScsXG4gIDMwNzI6ICdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknLFxuICAzMDczOiAnUENTQ2l0YXRpb25HZW9LZXknLFxuICAzMDc0OiAnUHJvamVjdGlvbkdlb0tleScsXG4gIDMwNzU6ICdQcm9qQ29vcmRUcmFuc0dlb0tleScsXG4gIDMwNzY6ICdQcm9qTGluZWFyVW5pdHNHZW9LZXknLFxuICAzMDc3OiAnUHJvakxpbmVhclVuaXRTaXplR2VvS2V5JyxcbiAgMzA3ODogJ1Byb2pTdGRQYXJhbGxlbDFHZW9LZXknLFxuICAzMDc5OiAnUHJvalN0ZFBhcmFsbGVsMkdlb0tleScsXG4gIDMwODA6ICdQcm9qTmF0T3JpZ2luTG9uZ0dlb0tleScsXG4gIDMwODE6ICdQcm9qTmF0T3JpZ2luTGF0R2VvS2V5JyxcbiAgMzA4MjogJ1Byb2pGYWxzZUVhc3RpbmdHZW9LZXknLFxuICAzMDgzOiAnUHJvakZhbHNlTm9ydGhpbmdHZW9LZXknLFxuICAzMDg0OiAnUHJvakZhbHNlT3JpZ2luTG9uZ0dlb0tleScsXG4gIDMwODU6ICdQcm9qRmFsc2VPcmlnaW5MYXRHZW9LZXknLFxuICAzMDg2OiAnUHJvakZhbHNlT3JpZ2luRWFzdGluZ0dlb0tleScsXG4gIDMwODc6ICdQcm9qRmFsc2VPcmlnaW5Ob3J0aGluZ0dlb0tleScsXG4gIDMwODg6ICdQcm9qQ2VudGVyTG9uZ0dlb0tleScsXG4gIDMwODk6ICdQcm9qQ2VudGVyTGF0R2VvS2V5JyxcbiAgMzA5MDogJ1Byb2pDZW50ZXJFYXN0aW5nR2VvS2V5JyxcbiAgMzA5MTogJ1Byb2pDZW50ZXJOb3J0aGluZ0dlb0tleScsXG4gIDMwOTI6ICdQcm9qU2NhbGVBdE5hdE9yaWdpbkdlb0tleScsXG4gIDMwOTM6ICdQcm9qU2NhbGVBdENlbnRlckdlb0tleScsXG4gIDMwOTQ6ICdQcm9qQXppbXV0aEFuZ2xlR2VvS2V5JyxcbiAgMzA5NTogJ1Byb2pTdHJhaWdodFZlcnRQb2xlTG9uZ0dlb0tleScsXG4gIDMwOTY6ICdQcm9qUmVjdGlmaWVkR3JpZEFuZ2xlR2VvS2V5JyxcbiAgNDA5NjogJ1ZlcnRpY2FsQ1NUeXBlR2VvS2V5JyxcbiAgNDA5NzogJ1ZlcnRpY2FsQ2l0YXRpb25HZW9LZXknLFxuICA0MDk4OiAnVmVydGljYWxEYXR1bUdlb0tleScsXG4gIDQwOTk6ICdWZXJ0aWNhbFVuaXRzR2VvS2V5Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBnZW9LZXlzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBnZW9LZXlOYW1lcykge1xuICBpZiAoZ2VvS2V5TmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGdlb0tleXNbZ2VvS2V5TmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/globals.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/logging.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"debug\": () => (/* binding */ debug),\n/* harmony export */   \"error\": () => (/* binding */ error),\n/* harmony export */   \"info\": () => (/* binding */ info),\n/* harmony export */   \"log\": () => (/* binding */ log),\n/* harmony export */   \"setLogger\": () => (/* binding */ setLogger),\n/* harmony export */   \"time\": () => (/* binding */ time),\n/* harmony export */   \"timeEnd\": () => (/* binding */ timeEnd),\n/* harmony export */   \"warn\": () => (/* binding */ warn)\n/* harmony export */ });\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nfunction setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nfunction debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nfunction log(...args) {\n  return LOGGER.log(...args);\n}\n\nfunction info(...args) {\n  return LOGGER.info(...args);\n}\n\nfunction warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nfunction error(...args) {\n  return LOGGER.error(...args);\n}\n\nfunction time(...args) {\n  return LOGGER.time(...args);\n}\n\nfunction timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9sb2dnaW5nLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2xvZ2dpbmcuanM/NWIwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgbm8tb3AgbG9nZ2VyXG4gKi9cbmNsYXNzIER1bW15TG9nZ2VyIHtcbiAgbG9nKCkge31cblxuICBkZWJ1ZygpIHt9XG5cbiAgaW5mbygpIHt9XG5cbiAgd2FybigpIHt9XG5cbiAgZXJyb3IoKSB7fVxuXG4gIHRpbWUoKSB7fVxuXG4gIHRpbWVFbmQoKSB7fVxufVxuXG5sZXQgTE9HR0VSID0gbmV3IER1bW15TG9nZ2VyKCk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBsb2dnZXIgdGhlIG5ldyBsb2dnZXIuIGUuZyBgY29uc29sZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExvZ2dlcihsb2dnZXIgPSBuZXcgRHVtbXlMb2dnZXIoKSkge1xuICBMT0dHRVIgPSBsb2dnZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuZGVidWcoLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2coLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLmxvZyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZm8oLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLmluZm8oLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi53YXJuKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLmVycm9yKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZSguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIudGltZSguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVFbmQoLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLnRpbWVFbmQoLi4uYXJncyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/logging.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/geotiff/dist-module/pool.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        __webpack_require__.e(/*! import() */ \"vendors-node_modules_geotiff_dist-module_worker_decoder_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./worker/decoder.js */ \"./node_modules/geotiff/dist-module/worker/decoder.js\")).then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_0__.getDecoder)(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pool);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wb29sLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsME9BQTZCO0FBQ3JDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Bvb2wuanM/MWI3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXREZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9pbmRleC5qcyc7XG5cbmNvbnN0IGRlZmF1bHRQb29sU2l6ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gKG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDIpIDogMjtcblxuLyoqXG4gKiBAbW9kdWxlIHBvb2xcbiAqL1xuXG4vKipcbiAqIFBvb2wgZm9yIHdvcmtlcnMgdG8gZGVjb2RlIGNodW5rcyBvZiB0aGUgaW1hZ2VzLlxuICovXG5jbGFzcyBQb29sIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBwb29sLiBEZWZhdWx0cyB0byB0aGUgbnVtYmVyIG9mIENQVXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlLiBXaGVuIHRoaXMgcGFyYW1ldGVyIGlzIGBudWxsYCBvciAwLCB0aGVuIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICBkZWNvZGluZyB3aWxsIGJlIGRvbmUgaW4gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IFdvcmtlcn0gW2NyZWF0ZVdvcmtlcl0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIGRlY29kZXIgd29ya2VyLlxuICAgKiBEZWZhdWx0cyB0byBhIHdvcmtlciB3aXRoIGFsbCBkZWNvZGVycyB0aGF0IHNoaXAgd2l0aCBnZW90aWZmLmpzLiBUaGUgYGNyZWF0ZVdvcmtlcigpYFxuICAgKiBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSBgV29ya2VyYCBjb21wYXRpYmxlIHdpdGggV2ViIFdvcmtlcnMuIEZvciBjb2RlIHRoYXRcbiAgICogcnVucyBpbiBOb2RlLCBbd2ViLXdvcmtlcl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2ViLXdvcmtlcikgaXMgYSBnb29kIGNob2ljZS5cbiAgICpcbiAgICogQSB3b3JrZXIgdGhhdCB1c2VzIGEgY3VzdG9tIGx6dyBkZWNvZGVyIHdvdWxkIGxvb2sgbGlrZSB0aGlzIGBteS1jdXN0b20td29ya2VyLmpzYCBmaWxlOlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBhZGREZWNvZGVyLCBnZXREZWNvZGVyIH0gZnJvbSAnZ2VvdGlmZic7XG4gICAqIGFkZERlY29kZXIoNSwgKCkgPT4gaW1wb3J0ICgnLi9teS1jdXN0b20tbHp3JykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG4gICAqIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChlKSA9PiB7XG4gICAqICAgY29uc3QgeyBpZCwgZmlsZURpcmVjdG9yeSwgYnVmZmVyIH0gPSBlLmRhdGE7XG4gICAqICAgY29uc3QgZGVjb2RlciA9IGF3YWl0IGdldERlY29kZXIoZmlsZURpcmVjdG9yeSk7XG4gICAqICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IGRlY29kZXIuZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcik7XG4gICAqICAgc2VsZi5wb3N0TWVzc2FnZSh7IGRlY29kZWQsIGlkIH0sIFtkZWNvZGVkXSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogVGhlIHdheSB0aGUgYWJvdmUgY29kZSBpcyBidWlsdCBpbnRvIGEgd29ya2VyIGJ5IHRoZSBgY3JlYXRlV29ya2VyKClgIGZ1bmN0aW9uXG4gICAqIGRlcGVuZHMgb24gdGhlIHVzZWQgYnVuZGxlci4gRm9yIG1vc3QgYnVuZGxlcnMsIHNvbWV0aGluZyBsaWtlIHRoaXMgd2lsbCB3b3JrOlxuICAgKiBgYGBqc1xuICAgKiBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoKSB7XG4gICAqICAgcmV0dXJuIG5ldyBXb3JrZXIobmV3IFVSTCgnLi9teS1jdXN0b20td29ya2VyLmpzJywgaW1wb3J0Lm1ldGEudXJsKSk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzaXplID0gZGVmYXVsdFBvb2xTaXplLCBjcmVhdGVXb3JrZXIpIHtcbiAgICB0aGlzLndvcmtlcnMgPSBudWxsO1xuICAgIHRoaXMuX2F3YWl0aW5nRGVjb2RlciA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLm1lc3NhZ2VJZCA9IDA7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgIHRoaXMuX2F3YWl0aW5nRGVjb2RlciA9IGNyZWF0ZVdvcmtlciA/IFByb21pc2UucmVzb2x2ZShjcmVhdGVXb3JrZXIpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaW1wb3J0KCcuL3dvcmtlci9kZWNvZGVyLmpzJykudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShtb2R1bGUuY3JlYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2F3YWl0aW5nRGVjb2Rlci50aGVuKChjcmVhdGUpID0+IHtcbiAgICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53b3JrZXJzLnB1c2goeyB3b3JrZXI6IGNyZWF0ZSgpLCBpZGxlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHRoZSBnaXZlbiBibG9jayBvZiBieXRlcyB3aXRoIHRoZSBzZXQgY29tcHJlc3Npb24gbWV0aG9kLlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgdGhlIGFycmF5IGJ1ZmZlciBvZiBieXRlcyB0byBkZWNvZGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5QnVmZmVyPn0gdGhlIGRlY29kZWQgcmVzdWx0IGFzIGEgYFByb21pc2VgXG4gICAqL1xuICBhc3luYyBkZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSB7XG4gICAgaWYgKHRoaXMuX2F3YWl0aW5nRGVjb2Rlcikge1xuICAgICAgYXdhaXQgdGhpcy5fYXdhaXRpbmdEZWNvZGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaXplID09PSAwXG4gICAgICA/IGdldERlY29kZXIoZmlsZURpcmVjdG9yeSkudGhlbigoZGVjb2RlcikgPT4gZGVjb2Rlci5kZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSlcbiAgICAgIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJzLmZpbmQoKGNhbmRpZGF0ZSkgPT4gY2FuZGlkYXRlLmlkbGUpXG4gICAgICAgICAgfHwgdGhpcy53b3JrZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuc2l6ZSldO1xuICAgICAgICB3b3JrZXIuaWRsZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWVzc2FnZUlkKys7XG4gICAgICAgIGNvbnN0IG9uTWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUuZGF0YS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHdvcmtlci5pZGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoZS5kYXRhLmRlY29kZWQpO1xuICAgICAgICAgICAgd29ya2VyLndvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSk7XG4gICAgICAgIHdvcmtlci53b3JrZXIucG9zdE1lc3NhZ2UoeyBmaWxlRGlyZWN0b3J5LCBidWZmZXIsIGlkIH0sIFtidWZmZXJdKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy53b3JrZXJzKSB7XG4gICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCgod29ya2VyKSA9PiB7XG4gICAgICAgIHdvcmtlci53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvb2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/pool.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/predictor.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/predictor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPredictor\": () => (/* binding */ applyPredictor)\n/* harmony export */ });\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nfunction applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wcmVkaWN0b3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0EsTUFBTSw0QkFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wcmVkaWN0b3IuanM/ZjBlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBkZWNvZGVSb3dBY2Mocm93LCBzdHJpZGUpIHtcbiAgbGV0IGxlbmd0aCA9IHJvdy5sZW5ndGggLSBzdHJpZGU7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBkbyB7XG4gICAgZm9yIChsZXQgaSA9IHN0cmlkZTsgaSA+IDA7IGktLSkge1xuICAgICAgcm93W29mZnNldCArIHN0cmlkZV0gKz0gcm93W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICBsZW5ndGggLT0gc3RyaWRlO1xuICB9IHdoaWxlIChsZW5ndGggPiAwKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUm93RmxvYXRpbmdQb2ludChyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGNvdW50ID0gcm93Lmxlbmd0aDtcbiAgY29uc3Qgd2MgPSBjb3VudCAvIGJ5dGVzUGVyU2FtcGxlO1xuXG4gIHdoaWxlIChjb3VudCA+IHN0cmlkZSkge1xuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyAtLWkpIHtcbiAgICAgIHJvd1tpbmRleCArIHN0cmlkZV0gKz0gcm93W2luZGV4XTtcbiAgICAgICsraW5kZXg7XG4gICAgfVxuICAgIGNvdW50IC09IHN0cmlkZTtcbiAgfVxuXG4gIGNvbnN0IGNvcHkgPSByb3cuc2xpY2UoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3YzsgKytpKSB7XG4gICAgZm9yIChsZXQgYiA9IDA7IGIgPCBieXRlc1BlclNhbXBsZTsgKytiKSB7XG4gICAgICByb3dbKGJ5dGVzUGVyU2FtcGxlICogaSkgKyBiXSA9IGNvcHlbKChieXRlc1BlclNhbXBsZSAtIGIgLSAxKSAqIHdjKSArIGldO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQcmVkaWN0b3IoYmxvY2ssIHByZWRpY3Rvciwgd2lkdGgsIGhlaWdodCwgYml0c1BlclNhbXBsZSxcbiAgcGxhbmFyQ29uZmlndXJhdGlvbikge1xuICBpZiAoIXByZWRpY3RvciB8fCBwcmVkaWN0b3IgPT09IDEpIHtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdHNQZXJTYW1wbGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYml0c1BlclNhbXBsZVtpXSAlIDggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3Rvciwgb25seSBtdWx0aXBsZSBvZiA4IGJpdHMgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gIT09IGJpdHNQZXJTYW1wbGVbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3RvciwgYWxsIHNhbXBsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHNpemUuJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnl0ZXNQZXJTYW1wbGUgPSBiaXRzUGVyU2FtcGxlWzBdIC8gODtcbiAgY29uc3Qgc3RyaWRlID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMiA/IDEgOiBiaXRzUGVyU2FtcGxlLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XG4gICAgLy8gTGFzdCBzdHJpcCB3aWxsIGJlIHRydW5jYXRlZCBpZiBoZWlnaHQgJSBzdHJpcEhlaWdodCAhPSAwXG4gICAgaWYgKGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlID49IGJsb2NrLmJ5dGVMZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgcm93O1xuICAgIGlmIChwcmVkaWN0b3IgPT09IDIpIHsgLy8gaG9yaXpvbnRhbCBwcmVkaWN0aW9uXG4gICAgICBzd2l0Y2ggKGJpdHNQZXJTYW1wbGVbMF0pIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQxNkFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlIC8gMixcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByZWRpY3RvciAyIG5vdCBhbGxvd2VkIHdpdGggJHtiaXRzUGVyU2FtcGxlWzBdfSBiaXRzIHBlciBzYW1wbGUuYCk7XG4gICAgICB9XG4gICAgICBkZWNvZGVSb3dBY2Mocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKTtcbiAgICB9IGVsc2UgaWYgKHByZWRpY3RvciA9PT0gMykgeyAvLyBob3Jpem9udGFsIGZsb2F0aW5nIHBvaW50XG4gICAgICByb3cgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLFxuICAgICAgKTtcbiAgICAgIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/predictor.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/resample.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/resample.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resample\": () => (/* binding */ resample),\n/* harmony export */   \"resampleBilinear\": () => (/* binding */ resampleBilinear),\n/* harmony export */   \"resampleBilinearInterleaved\": () => (/* binding */ resampleBilinearInterleaved),\n/* harmony export */   \"resampleInterleaved\": () => (/* binding */ resampleInterleaved),\n/* harmony export */   \"resampleNearest\": () => (/* binding */ resampleNearest),\n/* harmony export */   \"resampleNearestInterleaved\": () => (/* binding */ resampleNearestInterleaved)\n/* harmony export */ });\n/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nfunction resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZXNhbXBsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGNBQWM7QUFDM0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZXNhbXBsZS5qcz84YWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSByZXNhbXBsZVxuICovXG5cbmZ1bmN0aW9uIGNvcHlOZXdTaXplKGFycmF5LCB3aWR0aCwgaGVpZ2h0LCBzYW1wbGVzUGVyUGl4ZWwgPSAxKSB7XG4gIHJldHVybiBuZXcgKE9iamVjdC5nZXRQcm90b3R5cGVPZihhcnJheSkuY29uc3RydWN0b3IpKHdpZHRoICogaGVpZ2h0ICogc2FtcGxlc1BlclBpeGVsKTtcbn1cblxuLyoqXG4gKiBSZXNhbXBsZSB0aGUgaW5wdXQgYXJyYXlzIHVzaW5nIG5lYXJlc3QgbmVpZ2hib3IgdmFsdWUgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHJldHVybnMge1R5cGVkQXJyYXlbXX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZU5lYXJlc3QodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KSB7XG4gIGNvbnN0IHJlbFggPSBpbldpZHRoIC8gb3V0V2lkdGg7XG4gIGNvbnN0IHJlbFkgPSBpbkhlaWdodCAvIG91dEhlaWdodDtcbiAgcmV0dXJuIHZhbHVlQXJyYXlzLm1hcCgoYXJyYXkpID0+IHtcbiAgICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKGFycmF5LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dEhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCBjeSA9IE1hdGgubWluKE1hdGgucm91bmQocmVsWSAqIHkpLCBpbkhlaWdodCAtIDEpO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRXaWR0aDsgKyt4KSB7XG4gICAgICAgIGNvbnN0IGN4ID0gTWF0aC5taW4oTWF0aC5yb3VuZChyZWxYICogeCksIGluV2lkdGggLSAxKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVsoY3kgKiBpbldpZHRoKSArIGN4XTtcbiAgICAgICAgbmV3QXJyYXlbKHkgKiBvdXRXaWR0aCkgKyB4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH0pO1xufVxuXG4vLyBzaW1wbGUgbGluZWFyIGludGVycG9sYXRpb24sIGNvZGUgZnJvbTpcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uI1Byb2dyYW1taW5nX2xhbmd1YWdlX3N1cHBvcnRcbmZ1bmN0aW9uIGxlcnAodjAsIHYxLCB0KSB7XG4gIHJldHVybiAoKDEgLSB0KSAqIHYwKSArICh0ICogdjEpO1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBpbnB1dCBhcnJheXMgdXNpbmcgYmlsaW5lYXIgaW50ZXJwb2xhdGlvbi5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheVtdfSB2YWx1ZUFycmF5cyBUaGUgaW5wdXQgYXJyYXlzIHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5W119IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVCaWxpbmVhcih2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuXG4gIHJldHVybiB2YWx1ZUFycmF5cy5tYXAoKGFycmF5KSA9PiB7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBjb3B5TmV3U2l6ZShhcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRIZWlnaHQ7ICsreSkge1xuICAgICAgY29uc3QgcmF3WSA9IHJlbFkgKiB5O1xuXG4gICAgICBjb25zdCB5bCA9IE1hdGguZmxvb3IocmF3WSk7XG4gICAgICBjb25zdCB5aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdZKSwgKGluSGVpZ2h0IC0gMSkpO1xuXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dFdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgcmF3WCA9IHJlbFggKiB4O1xuICAgICAgICBjb25zdCB0eCA9IHJhd1ggJSAxO1xuXG4gICAgICAgIGNvbnN0IHhsID0gTWF0aC5mbG9vcihyYXdYKTtcbiAgICAgICAgY29uc3QgeGggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WCksIChpbldpZHRoIC0gMSkpO1xuXG4gICAgICAgIGNvbnN0IGxsID0gYXJyYXlbKHlsICogaW5XaWR0aCkgKyB4bF07XG4gICAgICAgIGNvbnN0IGhsID0gYXJyYXlbKHlsICogaW5XaWR0aCkgKyB4aF07XG4gICAgICAgIGNvbnN0IGxoID0gYXJyYXlbKHloICogaW5XaWR0aCkgKyB4bF07XG4gICAgICAgIGNvbnN0IGhoID0gYXJyYXlbKHloICogaW5XaWR0aCkgKyB4aF07XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsZXJwKFxuICAgICAgICAgIGxlcnAobGwsIGhsLCB0eCksXG4gICAgICAgICAgbGVycChsaCwgaGgsIHR4KSxcbiAgICAgICAgICByYXdZICUgMSxcbiAgICAgICAgKTtcbiAgICAgICAgbmV3QXJyYXlbKHkgKiBvdXRXaWR0aCkgKyB4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBpbnB1dCBhcnJheXMgdXNpbmcgdGhlIHNlbGVjdGVkIHJlc2FtcGxpbmcgbWV0aG9kLlxuICogQHBhcmFtIHtUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2QgPSAnbmVhcmVzdCddIFRoZSBkZXNpcmVkIHJlc2FtcGxpbmcgbWV0aG9kXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheVtdfSBUaGUgcmVzYW1wbGVkIHJhc3RlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlKHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgbWV0aG9kID0gJ25lYXJlc3QnKSB7XG4gIHN3aXRjaCAobWV0aG9kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgIHJldHVybiByZXNhbXBsZU5lYXJlc3QodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBjYXNlICdiaWxpbmVhcic6XG4gICAgY2FzZSAnbGluZWFyJzpcbiAgICAgIHJldHVybiByZXNhbXBsZUJpbGluZWFyKHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzYW1wbGluZyBtZXRob2Q6ICcke21ldGhvZH0nYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNhbXBsZSB0aGUgcGl4ZWwgaW50ZXJsZWF2ZWQgaW5wdXQgYXJyYXkgdXNpbmcgbmVhcmVzdCBuZWlnaGJvciB2YWx1ZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXMgVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbCBmb3IgcGl4ZWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5fSBUaGUgcmVzYW1wbGVkIHJhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVOZWFyZXN0SW50ZXJsZWF2ZWQoXG4gIHZhbHVlQXJyYXksIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBzYW1wbGVzKSB7XG4gIGNvbnN0IHJlbFggPSBpbldpZHRoIC8gb3V0V2lkdGg7XG4gIGNvbnN0IHJlbFkgPSBpbkhlaWdodCAvIG91dEhlaWdodDtcblxuICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKHZhbHVlQXJyYXksIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMpO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dEhlaWdodDsgKyt5KSB7XG4gICAgY29uc3QgY3kgPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFkgKiB5KSwgaW5IZWlnaHQgLSAxKTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dFdpZHRoOyArK3gpIHtcbiAgICAgIGNvbnN0IGN4ID0gTWF0aC5taW4oTWF0aC5yb3VuZChyZWxYICogeCksIGluV2lkdGggLSAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlczsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVBcnJheVsoY3kgKiBpbldpZHRoICogc2FtcGxlcykgKyAoY3ggKiBzYW1wbGVzKSArIGldO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoICogc2FtcGxlcykgKyAoeCAqIHNhbXBsZXMpICsgaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyBiaWxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtUeXBlZEFycmF5fSB2YWx1ZUFycmF5cyBUaGUgaW5wdXQgYXJyYXlzIHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVzIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwgZm9yIHBpeGVsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmxlYXZlZCBkYXRhXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlQmlsaW5lYXJJbnRlcmxlYXZlZChcbiAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKHZhbHVlQXJyYXksIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMpO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dEhlaWdodDsgKyt5KSB7XG4gICAgY29uc3QgcmF3WSA9IHJlbFkgKiB5O1xuXG4gICAgY29uc3QgeWwgPSBNYXRoLmZsb29yKHJhd1kpO1xuICAgIGNvbnN0IHloID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1kpLCAoaW5IZWlnaHQgLSAxKSk7XG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dFdpZHRoOyArK3gpIHtcbiAgICAgIGNvbnN0IHJhd1ggPSByZWxYICogeDtcbiAgICAgIGNvbnN0IHR4ID0gcmF3WCAlIDE7XG5cbiAgICAgIGNvbnN0IHhsID0gTWF0aC5mbG9vcihyYXdYKTtcbiAgICAgIGNvbnN0IHhoID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1gpLCAoaW5XaWR0aCAtIDEpKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgICAgY29uc3QgbGwgPSB2YWx1ZUFycmF5Wyh5bCAqIGluV2lkdGggKiBzYW1wbGVzKSArICh4bCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIGNvbnN0IGhsID0gdmFsdWVBcnJheVsoeWwgKiBpbldpZHRoICogc2FtcGxlcykgKyAoeGggKiBzYW1wbGVzKSArIGldO1xuICAgICAgICBjb25zdCBsaCA9IHZhbHVlQXJyYXlbKHloICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhsICogc2FtcGxlcykgKyBpXTtcbiAgICAgICAgY29uc3QgaGggPSB2YWx1ZUFycmF5Wyh5aCAqIGluV2lkdGggKiBzYW1wbGVzKSArICh4aCAqIHNhbXBsZXMpICsgaV07XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsZXJwKFxuICAgICAgICAgIGxlcnAobGwsIGhsLCB0eCksXG4gICAgICAgICAgbGVycChsaCwgaGgsIHR4KSxcbiAgICAgICAgICByYXdZICUgMSxcbiAgICAgICAgKTtcbiAgICAgICAgbmV3QXJyYXlbKHkgKiBvdXRXaWR0aCAqIHNhbXBsZXMpICsgKHggKiBzYW1wbGVzKSArIGldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuLyoqXG4gKiBSZXNhbXBsZSB0aGUgcGl4ZWwgaW50ZXJsZWF2ZWQgaW5wdXQgYXJyYXkgdXNpbmcgdGhlIHNlbGVjdGVkIHJlc2FtcGxpbmcgbWV0aG9kLlxuICogQHBhcmFtIHtUeXBlZEFycmF5fSB2YWx1ZUFycmF5IFRoZSBpbnB1dCBhcnJheSB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlcyBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsIGZvciBwaXhlbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmxlYXZlZCBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZCA9ICduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2RcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5fSBUaGUgcmVzYW1wbGVkIHJhc3RlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlSW50ZXJsZWF2ZWQodmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsIG1ldGhvZCA9ICduZWFyZXN0Jykge1xuICBzd2l0Y2ggKG1ldGhvZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICByZXR1cm4gcmVzYW1wbGVOZWFyZXN0SW50ZXJsZWF2ZWQoXG4gICAgICAgIHZhbHVlQXJyYXksIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBzYW1wbGVzLFxuICAgICAgKTtcbiAgICBjYXNlICdiaWxpbmVhcic6XG4gICAgY2FzZSAnbGluZWFyJzpcbiAgICAgIHJldHVybiByZXNhbXBsZUJpbGluZWFySW50ZXJsZWF2ZWQoXG4gICAgICAgIHZhbHVlQXJyYXksIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBzYW1wbGVzLFxuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCByZXNhbXBsaW5nIG1ldGhvZDogJyR7bWV0aG9kfSdgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/resample.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/rgb.js":
/*!*************************************************!*\
  !*** ./node_modules/geotiff/dist-module/rgb.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fromBlackIsZero\": () => (/* binding */ fromBlackIsZero),\n/* harmony export */   \"fromCIELab\": () => (/* binding */ fromCIELab),\n/* harmony export */   \"fromCMYK\": () => (/* binding */ fromCMYK),\n/* harmony export */   \"fromPalette\": () => (/* binding */ fromPalette),\n/* harmony export */   \"fromWhiteIsZero\": () => (/* binding */ fromWhiteIsZero),\n/* harmony export */   \"fromYCbCr\": () => (/* binding */ fromYCbCr)\n/* harmony export */ });\nfunction fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nfunction fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nfunction fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nfunction fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZ2IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjs7QUFFQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0EsZ0RBQWdEO0FBQ2hELGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZ2IuanM/ZGNhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZnJvbVdoaXRlSXNaZXJvKHJhc3RlciwgbWF4KSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBsZXQgdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHJhc3Rlci5sZW5ndGg7ICsraSwgaiArPSAzKSB7XG4gICAgdmFsdWUgPSAyNTYgLSAocmFzdGVyW2ldIC8gbWF4ICogMjU2KTtcbiAgICByZ2JSYXN0ZXJbal0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gdmFsdWU7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQmxhY2tJc1plcm8ocmFzdGVyLCBtYXgpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgcmFzdGVyLmxlbmd0aDsgKytpLCBqICs9IDMpIHtcbiAgICB2YWx1ZSA9IHJhc3RlcltpXSAvIG1heCAqIDI1NjtcbiAgICByZ2JSYXN0ZXJbal0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gdmFsdWU7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUGFsZXR0ZShyYXN0ZXIsIGNvbG9yTWFwKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBjb25zdCBncmVlbk9mZnNldCA9IGNvbG9yTWFwLmxlbmd0aCAvIDM7XG4gIGNvbnN0IGJsdWVPZmZzZXQgPSBjb2xvck1hcC5sZW5ndGggLyAzICogMjtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgcmFzdGVyLmxlbmd0aDsgKytpLCBqICs9IDMpIHtcbiAgICBjb25zdCBtYXBJbmRleCA9IHJhc3RlcltpXTtcbiAgICByZ2JSYXN0ZXJbal0gPSBjb2xvck1hcFttYXBJbmRleF0gLyA2NTUzNiAqIDI1NjtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gY29sb3JNYXBbbWFwSW5kZXggKyBncmVlbk9mZnNldF0gLyA2NTUzNiAqIDI1NjtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gY29sb3JNYXBbbWFwSW5kZXggKyBibHVlT2Zmc2V0XSAvIDY1NTM2ICogMjU2O1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ01ZSyhjbXlrUmFzdGVyKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY215a1Jhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY215a1Jhc3Rlci5sZW5ndGg7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgY29uc3QgYyA9IGNteWtSYXN0ZXJbaV07XG4gICAgY29uc3QgbSA9IGNteWtSYXN0ZXJbaSArIDFdO1xuICAgIGNvbnN0IHkgPSBjbXlrUmFzdGVyW2kgKyAyXTtcbiAgICBjb25zdCBrID0gY215a1Jhc3RlcltpICsgM107XG5cbiAgICByZ2JSYXN0ZXJbal0gPSAyNTUgKiAoKDI1NSAtIGMpIC8gMjU2KSAqICgoMjU1IC0gaykgLyAyNTYpO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSAyNTUgKiAoKDI1NSAtIG0pIC8gMjU2KSAqICgoMjU1IC0gaykgLyAyNTYpO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSAyNTUgKiAoKDI1NSAtIHkpIC8gMjU2KSAqICgoMjU1IC0gaykgLyAyNTYpO1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWUNiQ3IoeUNiQ3JSYXN0ZXIpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB5Q2JDclJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHlDYkNyUmFzdGVyLmxlbmd0aDsgaSArPSAzLCBqICs9IDMpIHtcbiAgICBjb25zdCB5ID0geUNiQ3JSYXN0ZXJbaV07XG4gICAgY29uc3QgY2IgPSB5Q2JDclJhc3RlcltpICsgMV07XG4gICAgY29uc3QgY3IgPSB5Q2JDclJhc3RlcltpICsgMl07XG5cbiAgICByZ2JSYXN0ZXJbal0gPSAoeSArICgxLjQwMjAwICogKGNyIC0gMHg4MCkpKTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gKHkgLSAoMC4zNDQxNCAqIChjYiAtIDB4ODApKSAtICgwLjcxNDE0ICogKGNyIC0gMHg4MCkpKTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gKHkgKyAoMS43NzIwMCAqIChjYiAtIDB4ODApKSk7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuY29uc3QgWG4gPSAwLjk1MDQ3O1xuY29uc3QgWW4gPSAxLjAwMDAwO1xuY29uc3QgWm4gPSAxLjA4ODgzO1xuXG4vLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRpbWF0dGVyMTUvcmdiLWxhYi9ibG9iL21hc3Rlci9jb2xvci5qc1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNJRUxhYihjaWVMYWJSYXN0ZXIpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjaWVMYWJSYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY2llTGFiUmFzdGVyLmxlbmd0aDsgaSArPSAzLCBqICs9IDMpIHtcbiAgICBjb25zdCBMID0gY2llTGFiUmFzdGVyW2kgKyAwXTtcbiAgICBjb25zdCBhXyA9IGNpZUxhYlJhc3RlcltpICsgMV0gPDwgMjQgPj4gMjQ7IC8vIGNvbnZlcnNpb24gZnJvbSB1aW50OCB0byBpbnQ4XG4gICAgY29uc3QgYl8gPSBjaWVMYWJSYXN0ZXJbaSArIDJdIDw8IDI0ID4+IDI0OyAvLyBzYW1lXG5cbiAgICBsZXQgeSA9IChMICsgMTYpIC8gMTE2O1xuICAgIGxldCB4ID0gKGFfIC8gNTAwKSArIHk7XG4gICAgbGV0IHogPSB5IC0gKGJfIC8gMjAwKTtcbiAgICBsZXQgcjtcbiAgICBsZXQgZztcbiAgICBsZXQgYjtcblxuICAgIHggPSBYbiAqICgoeCAqIHggKiB4ID4gMC4wMDg4NTYpID8geCAqIHggKiB4IDogKHggLSAoMTYgLyAxMTYpKSAvIDcuNzg3KTtcbiAgICB5ID0gWW4gKiAoKHkgKiB5ICogeSA+IDAuMDA4ODU2KSA/IHkgKiB5ICogeSA6ICh5IC0gKDE2IC8gMTE2KSkgLyA3Ljc4Nyk7XG4gICAgeiA9IFpuICogKCh6ICogeiAqIHogPiAwLjAwODg1NikgPyB6ICogeiAqIHogOiAoeiAtICgxNiAvIDExNikpIC8gNy43ODcpO1xuXG4gICAgciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuICAgIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICAgIGIgPSAoeCAqIDAuMDU1NykgKyAoeSAqIC0wLjIwNDApICsgKHogKiAxLjA1NzApO1xuXG4gICAgciA9IChyID4gMC4wMDMxMzA4KSA/ICgoMS4wNTUgKiAociAqKiAoMSAvIDIuNCkpKSAtIDAuMDU1KSA6IDEyLjkyICogcjtcbiAgICBnID0gKGcgPiAwLjAwMzEzMDgpID8gKCgxLjA1NSAqIChnICoqICgxIC8gMi40KSkpIC0gMC4wNTUpIDogMTIuOTIgKiBnO1xuICAgIGIgPSAoYiA+IDAuMDAzMTMwOCkgPyAoKDEuMDU1ICogKGIgKiogKDEgLyAyLjQpKSkgLSAwLjA1NSkgOiAxMi45MiAqIGI7XG5cbiAgICByZ2JSYXN0ZXJbal0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCByKSkgKiAyNTU7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGcpKSAqIDI1NTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYikpICogMjU1O1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/rgb.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/arraybuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/arraybuffer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeBufferSource\": () => (/* binding */ makeBufferSource)\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass ArrayBufferSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nfunction makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYXJyYXlidWZmZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQ0o7O0FBRXpDLGdDQUFnQyxzREFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYXJyYXlidWZmZXIuanM/YmUxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNsYXNzIEFycmF5QnVmZmVyU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKGFycmF5QnVmZmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXI7XG4gIH1cblxuICBmZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKHNsaWNlLm9mZnNldCwgc2xpY2Uub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUJ1ZmZlclNvdXJjZShhcnJheUJ1ZmZlcikge1xuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyU291cmNlKGFycmF5QnVmZmVyKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/arraybuffer.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/basesource.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/basesource.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseSource\": () => (/* binding */ BaseSource)\n/* harmony export */ });\n/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nclass BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmFzZXNvdXJjZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRU87QUFDUDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmFzZXNvdXJjZS5qcz81MzcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYgU2xpY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuXG5leHBvcnQgY2xhc3MgQmFzZVNvdXJjZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NsaWNlW119IHNsaWNlc1xuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJbXX1cbiAgICovXG4gIGFzeW5jIGZldGNoKHNsaWNlcywgc2lnbmFsID0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgc2xpY2VzLm1hcCgoc2xpY2UpID0+IHRoaXMuZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NsaWNlfSBzbGljZVxuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gICAqL1xuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBmZXRjaGluZyBvZiBzbGljZSAke3NsaWNlfSBub3QgcG9zc2libGUsIG5vdCBpbXBsZW1lbnRlZGApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbGVzaXplIGlmIGFscmVhZHkgZGV0ZXJtaW5lZCBhbmQgbnVsbCBvdGhlcndpc2VcbiAgICovXG4gIGdldCBmaWxlU2l6ZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIC8vIG5vLW9wIGJ5IGRlZmF1bHRcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/basesource.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/blockedsource.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/blockedsource.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BlockedSource\": () => (/* binding */ BlockedSource)\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nclass BlockedSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({ maxSize: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wait)();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.zip)(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmxvY2tlZHNvdXJjZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlDO0FBQ1k7QUFDdUI7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLDRCQUE0QixzREFBVTtBQUM3QztBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLHdCQUF3QixxQ0FBcUMsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGlEQUFRLEdBQUcsb0JBQW9COztBQUV6RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLCtDQUFJO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFVO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBYztBQUM5Qjs7QUFFQTtBQUNBLG1DQUFtQyw4Q0FBRzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQiw0QkFBNEI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsd0JBQXdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9ibG9ja2Vkc291cmNlLmpzPzA1OTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFF1aWNrTFJVIGZyb20gJ3F1aWNrLWxydSc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IsIEFnZ3JlZ2F0ZUVycm9yLCB3YWl0LCB6aXAgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNsYXNzIEJsb2NrIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBbZGF0YV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9mZnNldCwgbGVuZ3RoLCBkYXRhID0gbnVsbCkge1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn0gdGhlIHRvcCBieXRlIGJvcmRlclxuICAgKi9cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgfVxufVxuXG5jbGFzcyBCbG9ja0dyb3VwIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge251bWJlcltdfSBibG9ja0lkc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob2Zmc2V0LCBsZW5ndGgsIGJsb2NrSWRzKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5ibG9ja0lkcyA9IGJsb2NrSWRzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja2VkU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlIFRoZSB1bmRlcmx5aW5nIHNvdXJjZSB0aGF0IHNoYWxsIGJlIGJsb2NrZWQgYW5kIGNhY2hlZFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCB7IGJsb2NrU2l6ZSA9IDY1NTM2LCBjYWNoZVNpemUgPSAxMDAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmJsb2NrU2l6ZSA9IGJsb2NrU2l6ZTtcblxuICAgIHRoaXMuYmxvY2tDYWNoZSA9IG5ldyBRdWlja0xSVSh7IG1heFNpemU6IGNhY2hlU2l6ZSB9KTtcblxuICAgIC8vIG1hcHBpbmcgYmxvY2tJZCAtPiBCbG9jayBpbnN0YW5jZVxuICAgIHRoaXMuYmxvY2tSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIHNldCBvZiBibG9ja0lkcyBtaXNzaW5nIGZvciB0aGUgY3VycmVudCByZXF1ZXN0c1xuICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoID0gbmV3IFNldCgpO1xuXG4gICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICBnZXQgZmlsZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmZpbGVTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7YmFzZXNvdXJjZS9TbGljZVtdfSBzbGljZXNcbiAgICovXG4gIGFzeW5jIGZldGNoKHNsaWNlcywgc2lnbmFsKSB7XG4gICAgY29uc3QgYmxvY2tSZXF1ZXN0cyA9IFtdO1xuICAgIGNvbnN0IG1pc3NpbmdCbG9ja0lkcyA9IFtdO1xuICAgIGNvbnN0IGFsbEJsb2NrSWRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHsgb2Zmc2V0LCBsZW5ndGggfSBvZiBzbGljZXMpIHtcbiAgICAgIGxldCB0b3AgPSBvZmZzZXQgKyBsZW5ndGg7XG5cbiAgICAgIGNvbnN0IHsgZmlsZVNpemUgfSA9IHRoaXM7XG4gICAgICBpZiAoZmlsZVNpemUgIT09IG51bGwpIHtcbiAgICAgICAgdG9wID0gTWF0aC5taW4odG9wLCBmaWxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0QmxvY2tPZmZzZXQgPSBNYXRoLmZsb29yKG9mZnNldCAvIHRoaXMuYmxvY2tTaXplKSAqIHRoaXMuYmxvY2tTaXplO1xuXG4gICAgICBmb3IgKGxldCBjdXJyZW50ID0gZmlyc3RCbG9ja09mZnNldDsgY3VycmVudCA8IHRvcDsgY3VycmVudCArPSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICBjb25zdCBibG9ja0lkID0gTWF0aC5mbG9vcihjdXJyZW50IC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgICBpZiAoIXRoaXMuYmxvY2tDYWNoZS5oYXMoYmxvY2tJZCkgJiYgIXRoaXMuYmxvY2tSZXF1ZXN0cy5oYXMoYmxvY2tJZCkpIHtcbiAgICAgICAgICB0aGlzLmJsb2NrSWRzVG9GZXRjaC5hZGQoYmxvY2tJZCk7XG4gICAgICAgICAgbWlzc2luZ0Jsb2NrSWRzLnB1c2goYmxvY2tJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmxvY2tSZXF1ZXN0cy5oYXMoYmxvY2tJZCkpIHtcbiAgICAgICAgICBibG9ja1JlcXVlc3RzLnB1c2godGhpcy5ibG9ja1JlcXVlc3RzLmdldChibG9ja0lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsQmxvY2tJZHMucHVzaChibG9ja0lkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGxvdyBhZGRpdGlvbmFsIGJsb2NrIHJlcXVlc3RzIHRvIGFjY3VtdWxhdGVcbiAgICBhd2FpdCB3YWl0KCk7XG4gICAgdGhpcy5mZXRjaEJsb2NrcyhzaWduYWwpO1xuXG4gICAgLy8gR2F0aGVyIGFsbCBvZiB0aGUgbmV3IHJlcXVlc3RzIHRoYXQgdGhpcyBmZXRjaCBjYWxsIGlzIGNvbnRyaWJ1dGluZyB0byBgZmV0Y2hgLlxuICAgIGNvbnN0IG1pc3NpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBtaXNzaW5nQmxvY2tJZHMpIHtcbiAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgbWlzc2luZyBibG9jayBjb3VsZCBhbHJlYWR5IGJlIGluIHRoZSBjYWNoZVxuICAgICAgLy8gaW5zdGVhZCBvZiBoYXZpbmcgaXRzIHJlcXVlc3Qgc3RpbGwgYmUgb3V0c3RhbmRpbmcuXG4gICAgICBpZiAodGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICBtaXNzaW5nUmVxdWVzdHMucHVzaCh0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBY3R1YWxseSBhd2FpdCBhbGwgcGVuZGluZyByZXF1ZXN0cyB0aGF0IGFyZSBuZWVkZWQgZm9yIHRoaXMgYGZldGNoYC5cbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYmxvY2tSZXF1ZXN0cyk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKG1pc3NpbmdSZXF1ZXN0cyk7XG5cbiAgICAvLyBQZXJmb3JtIHJldHJpZXMgaWYgYSBibG9jayB3YXMgaW50ZXJydXB0ZWQgYnkgYSBwcmV2aW91cyBzaWduYWxcbiAgICBjb25zdCBhYm9ydGVkQmxvY2tSZXF1ZXN0cyA9IFtdO1xuICAgIGNvbnN0IGFib3J0ZWRCbG9ja0lkcyA9IGFsbEJsb2NrSWRzXG4gICAgICAuZmlsdGVyKChpZCkgPT4gdGhpcy5hYm9ydGVkQmxvY2tJZHMuaGFzKGlkKSB8fCAhdGhpcy5ibG9ja0NhY2hlLmhhcyhpZCkpO1xuICAgIGFib3J0ZWRCbG9ja0lkcy5mb3JFYWNoKChpZCkgPT4gdGhpcy5ibG9ja0lkc1RvRmV0Y2guYWRkKGlkKSk7XG4gICAgLy8gc3RhcnQgdGhlIHJldHJ5IG9mIHNvbWUgYmxvY2tzIGlmIHJlcXVpcmVkXG4gICAgaWYgKGFib3J0ZWRCbG9ja0lkcy5sZW5ndGggPiAwICYmIHNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMuZmV0Y2hCbG9ja3MobnVsbCk7XG4gICAgICBmb3IgKGNvbnN0IGJsb2NrSWQgb2YgYWJvcnRlZEJsb2NrSWRzKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5ibG9ja1JlcXVlc3RzLmdldChibG9ja0lkKTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgJHtibG9ja0lkfSBpcyBub3QgaW4gdGhlIGJsb2NrIHJlcXVlc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRlZEJsb2NrUmVxdWVzdHMucHVzaChibG9jayk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYWJvcnRlZEJsb2NrUmVxdWVzdHMpO1xuICAgIH1cblxuICAgIC8vIHRocm93IGFuICBhYm9ydCBlcnJvclxuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IHdhcyBhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmxvY2tzID0gYWxsQmxvY2tJZHMubWFwKChpZCkgPT4gdGhpcy5ibG9ja0NhY2hlLmdldChpZCkpO1xuICAgIGNvbnN0IGZhaWxlZEJsb2NrcyA9IGJsb2Nrcy5maWx0ZXIoKGkpID0+ICFpKTtcbiAgICBpZiAoZmFpbGVkQmxvY2tzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yKGZhaWxlZEJsb2NrcywgJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgZmluYWwgTWFwLCB3aXRoIGFsbCByZXF1aXJlZCBibG9ja3MgZm9yIHRoaXMgcmVxdWVzdCB0byBzYXRpc2Z5XG4gICAgY29uc3QgcmVxdWlyZWRCbG9ja3MgPSBuZXcgTWFwKHppcChhbGxCbG9ja0lkcywgYmxvY2tzKSk7XG5cbiAgICAvLyBUT0RPOiBzYXRpc2Z5IGVhY2ggc2xpY2VcbiAgICByZXR1cm4gdGhpcy5yZWFkU2xpY2VEYXRhKHNsaWNlcywgcmVxdWlyZWRCbG9ja3MpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHNpZ25hbFxuICAgKi9cbiAgZmV0Y2hCbG9ja3Moc2lnbmFsKSB7XG4gICAgLy8gY2hlY2sgaWYgd2Ugc3RpbGwgbmVlZCB0b1xuICAgIGlmICh0aGlzLmJsb2NrSWRzVG9GZXRjaC5zaXplID4gMCkge1xuICAgICAgY29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cEJsb2Nrcyh0aGlzLmJsb2NrSWRzVG9GZXRjaCk7XG5cbiAgICAgIC8vIHN0YXJ0IHJlcXVlc3Rpbmcgc2xpY2VzIG9mIGRhdGFcbiAgICAgIGNvbnN0IGdyb3VwUmVxdWVzdHMgPSB0aGlzLnNvdXJjZS5mZXRjaChncm91cHMsIHNpZ25hbCk7XG5cbiAgICAgIGZvciAobGV0IGdyb3VwSW5kZXggPSAwOyBncm91cEluZGV4IDwgZ3JvdXBzLmxlbmd0aDsgKytncm91cEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2dyb3VwSW5kZXhdO1xuXG4gICAgICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBncm91cC5ibG9ja0lkcykge1xuICAgICAgICAgIC8vIG1ha2UgYW4gYXN5bmMgSUlGRSBmb3IgZWFjaCBibG9ja1xuICAgICAgICAgIHRoaXMuYmxvY2tSZXF1ZXN0cy5zZXQoYmxvY2tJZCwgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IGdyb3VwUmVxdWVzdHMpW2dyb3VwSW5kZXhdO1xuICAgICAgICAgICAgICBjb25zdCBibG9ja09mZnNldCA9IGJsb2NrSWQgKiB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IGJsb2NrT2Zmc2V0IC0gcmVzcG9uc2Uub2Zmc2V0O1xuICAgICAgICAgICAgICBjb25zdCB0ID0gTWF0aC5taW4obyArIHRoaXMuYmxvY2tTaXplLCByZXNwb25zZS5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YS5zbGljZShvLCB0KTtcbiAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBuZXcgQmxvY2soXG4gICAgICAgICAgICAgICAgYmxvY2tPZmZzZXQsXG4gICAgICAgICAgICAgICAgZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYmxvY2tJZCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja0NhY2hlLnNldChibG9ja0lkLCBibG9jayk7XG4gICAgICAgICAgICAgIHRoaXMuYWJvcnRlZEJsb2NrSWRzLmRlbGV0ZShibG9ja0lkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBzaWduYWwgaGVyZSwgd2UgbmVlZCBpdCB0byBkZXRlcm1pbmUgbGF0ZXIgaWYgYW5cbiAgICAgICAgICAgICAgICAvLyBlcnJvciB3YXMgY2F1c2VkIGJ5IHRoaXMgc2lnbmFsXG4gICAgICAgICAgICAgICAgZXJyLnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2FjaGUuZGVsZXRlKGJsb2NrSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRlZEJsb2NrSWRzLmFkZChibG9ja0lkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRoaXMuYmxvY2tSZXF1ZXN0cy5kZWxldGUoYmxvY2tJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2V0fSBibG9ja0lkc1xuICAgKiBAcmV0dXJucyB7QmxvY2tHcm91cFtdfVxuICAgKi9cbiAgZ3JvdXBCbG9ja3MoYmxvY2tJZHMpIHtcbiAgICBjb25zdCBzb3J0ZWRCbG9ja0lkcyA9IEFycmF5LmZyb20oYmxvY2tJZHMpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBpZiAoc29ydGVkQmxvY2tJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBjdXJyZW50ID0gW107XG4gICAgbGV0IGxhc3RCbG9ja0lkID0gbnVsbDtcbiAgICBjb25zdCBncm91cHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBzb3J0ZWRCbG9ja0lkcykge1xuICAgICAgaWYgKGxhc3RCbG9ja0lkID09PSBudWxsIHx8IGxhc3RCbG9ja0lkICsgMSA9PT0gYmxvY2tJZCkge1xuICAgICAgICBjdXJyZW50LnB1c2goYmxvY2tJZCk7XG4gICAgICAgIGxhc3RCbG9ja0lkID0gYmxvY2tJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3Vwcy5wdXNoKG5ldyBCbG9ja0dyb3VwKFxuICAgICAgICAgIGN1cnJlbnRbMF0gKiB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgICAgICBjdXJyZW50Lmxlbmd0aCAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICkpO1xuICAgICAgICBjdXJyZW50ID0gW2Jsb2NrSWRdO1xuICAgICAgICBsYXN0QmxvY2tJZCA9IGJsb2NrSWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3JvdXBzLnB1c2gobmV3IEJsb2NrR3JvdXAoXG4gICAgICBjdXJyZW50WzBdICogdGhpcy5ibG9ja1NpemUsXG4gICAgICBjdXJyZW50Lmxlbmd0aCAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgY3VycmVudCxcbiAgICApKTtcblxuICAgIHJldHVybiBncm91cHM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTbGljZVtdfSBzbGljZXNcbiAgICogQHBhcmFtIHtNYXB9IGJsb2Nrc1xuICAgKi9cbiAgcmVhZFNsaWNlRGF0YShzbGljZXMsIGJsb2Nrcykge1xuICAgIHJldHVybiBzbGljZXMubWFwKChzbGljZSkgPT4ge1xuICAgICAgbGV0IHRvcCA9IHNsaWNlLm9mZnNldCArIHNsaWNlLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmZpbGVTaXplICE9PSBudWxsKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKHRoaXMuZmlsZVNpemUsIHRvcCk7XG4gICAgICB9XG4gICAgICBjb25zdCBibG9ja0lkTG93ID0gTWF0aC5mbG9vcihzbGljZS5vZmZzZXQgLyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICBjb25zdCBibG9ja0lkSGlnaCA9IE1hdGguZmxvb3IodG9wIC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgY29uc3Qgc2xpY2VEYXRhID0gbmV3IEFycmF5QnVmZmVyKHNsaWNlLmxlbmd0aCk7XG4gICAgICBjb25zdCBzbGljZVZpZXcgPSBuZXcgVWludDhBcnJheShzbGljZURhdGEpO1xuXG4gICAgICBmb3IgKGxldCBibG9ja0lkID0gYmxvY2tJZExvdzsgYmxvY2tJZCA8PSBibG9ja0lkSGlnaDsgKytibG9ja0lkKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYmxvY2tzLmdldChibG9ja0lkKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBibG9jay5vZmZzZXQgLSBzbGljZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRvcERlbHRhID0gYmxvY2sudG9wIC0gdG9wO1xuICAgICAgICBsZXQgYmxvY2tJbm5lck9mZnNldCA9IDA7XG4gICAgICAgIGxldCByYW5nZUlubmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHVzZWRCbG9ja0xlbmd0aDtcblxuICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgYmxvY2tJbm5lck9mZnNldCA9IC1kZWx0YTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICByYW5nZUlubmVyT2Zmc2V0ID0gZGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wRGVsdGEgPCAwKSB7XG4gICAgICAgICAgdXNlZEJsb2NrTGVuZ3RoID0gYmxvY2subGVuZ3RoIC0gYmxvY2tJbm5lck9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2VkQmxvY2tMZW5ndGggPSB0b3AgLSBibG9jay5vZmZzZXQgLSBibG9ja0lubmVyT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmxvY2tWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2suZGF0YSwgYmxvY2tJbm5lck9mZnNldCwgdXNlZEJsb2NrTGVuZ3RoKTtcbiAgICAgICAgc2xpY2VWaWV3LnNldChibG9ja1ZpZXcsIHJhbmdlSW5uZXJPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2xpY2VEYXRhO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/blockedsource.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/base.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseClient\": () => (/* binding */ BaseClient),\n/* harmony export */   \"BaseResponse\": () => (/* binding */ BaseResponse)\n/* harmony export */ });\nclass BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nclass BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {object} [options]\n   */\n  async request({ headers, credentials, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2Jhc2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxrQkFBa0IsK0JBQStCLElBQUksSUFBSTtBQUN6RDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2NsaWVudC9iYXNlLmpzP2U3MTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyBhbiBvaydpc2ggc3RhdHVzIGNvZGVcbiAgICovXG4gIGdldCBvaygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDw9IDI5OTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2VcbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGhlYWRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyTmFtZSB0aGUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIGhlYWRlciB2YWx1ZVxuICAgKi9cbiAgZ2V0SGVhZGVyKGhlYWRlck5hbWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSB0aGUgcmVzcG9uc2UgZGF0YSBvZiB0aGUgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYXNlQ2xpZW50IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHJlcXVlc3Qgd2l0aCB0aGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgY3JlZGVudGlhbHMsIHNpZ25hbCB9ID0ge30pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWVzdCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/base.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FetchClient\": () => (/* binding */ FetchClient)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n\n\nclass FetchResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nclass FetchClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  async request({ headers, credentials, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2ZldGNoLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFEOztBQUVyRCw0QkFBNEIsa0RBQVk7QUFDeEM7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sMEJBQTBCLGdEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwrQkFBK0IsSUFBSTtBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2ZldGNoLmpzPzU3YTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcblxuY2xhc3MgRmV0Y2hSZXNwb25zZSBleHRlbmRzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBCYXNlUmVzcG9uc2UgZmFjYWRlIGZvciBmZXRjaCBBUEkgUmVzcG9uc2VcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1cztcbiAgfVxuXG4gIGdldEhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSk7XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3BvbnNlLmFycmF5QnVmZmVyXG4gICAgICA/IGF3YWl0IHRoaXMucmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgICAgOiAoYXdhaXQgdGhpcy5yZXNwb25zZS5idWZmZXIoKSkuYnVmZmVyO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGZXRjaENsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGNyZWRlbnRpYWxzKSB7XG4gICAgc3VwZXIodXJsKTtcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgY3JlZGVudGlhbHMsIHNpZ25hbCB9ID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMudXJsLCB7XG4gICAgICBoZWFkZXJzLCBjcmVkZW50aWFscywgc2lnbmFsLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/fetch.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/http.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/http.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HttpClient\": () => (/* binding */ HttpClient)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"?cdec\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"?753a\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"?4e4d\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\n\n\n\nclass HttpResponse extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nclass HttpClient extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = url__WEBPACK_IMPORTED_MODULE_2__.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2h0dHAuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdCO0FBQ0U7QUFDRDs7QUFFNEI7QUFDVDs7QUFFNUMsMkJBQTJCLGtEQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHlCQUF5QixnREFBVTtBQUMxQztBQUNBO0FBQ0EscUJBQXFCLHNDQUFZO0FBQ2pDLDBEQUEwRCxpQ0FBSSxHQUFHLGtDQUFLO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQVU7QUFDeEM7QUFDQSxtRUFBbUUsaURBQVU7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0JBQWtCLGtCQUFrQixJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvaHR0cC5qcz9hNDZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCB1cmxNb2QgZnJvbSAndXJsJztcblxuaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEh0dHBSZXNwb25zZSBleHRlbmRzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBCYXNlUmVzcG9uc2UgZmFjYWRlIGZvciBub2RlIEhUVFAvSFRUUFMgQVBJIFJlc3BvbnNlXG4gICAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCBkYXRhUHJvbWlzZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuZGF0YVByb21pc2UgPSBkYXRhUHJvbWlzZTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgfVxuXG4gIGdldEhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UuaGVhZGVyc1tuYW1lXTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZGF0YVByb21pc2U7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEh0dHBDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgc3VwZXIodXJsKTtcbiAgICB0aGlzLnBhcnNlZFVybCA9IHVybE1vZC5wYXJzZSh0aGlzLnVybCk7XG4gICAgdGhpcy5odHRwQXBpID0gKHRoaXMucGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cDonID8gaHR0cCA6IGh0dHBzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmh0dHBBcGkuZ2V0KFxuICAgICAgICB7XG4gICAgICAgICAgLi4udGhpcy5wYXJzZWRVcmwsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZURhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBjb2xsZWN0IGNodW5rc1xuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNvbmNhdGVuYXRlIGFsbCBjaHVua3MgYW5kIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0aW5nIGJ1ZmZlclxuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKS5idWZmZXI7XG4gICAgICAgICAgICAgIHJlc29sdmVEYXRhKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc29sdmUobmV3IEh0dHBSZXNwb25zZShyZXNwb25zZSwgZGF0YVByb21pc2UpKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmVxdWVzdC5kZXN0cm95KG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gcmVxdWVzdC5kZXN0cm95KG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdCh7IGhlYWRlcnMsIHNpZ25hbCB9ID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29uc3RydWN0UmVxdWVzdChoZWFkZXJzLCBzaWduYWwpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/http.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/xhr.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/xhr.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XHRClient\": () => (/* binding */ XHRClient)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass XHRResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nclass XHRClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L3hoci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDVDs7QUFFNUMsMEJBQTBCLGtEQUFZO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sd0JBQXdCLGdEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlEQUFVO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxrQkFBa0Isa0JBQWtCLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2NsaWVudC94aHIuanM/YTJhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfSBmcm9tICcuL2Jhc2UuanMnO1xuaW1wb3J0IHsgQWJvcnRFcnJvciB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcblxuY2xhc3MgWEhSUmVzcG9uc2UgZXh0ZW5kcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQmFzZVJlc3BvbnNlIGZhY2FkZSBmb3IgWE1MSHR0cFJlcXVlc3RcbiAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0geGhyXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAgICovXG4gIGNvbnN0cnVjdG9yKHhociwgZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy54aHIgPSB4aHI7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMueGhyLnN0YXR1cztcbiAgfVxuXG4gIGdldEhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICB9XG5cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBYSFJDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgY29uc3RydWN0UmVxdWVzdChoZWFkZXJzLCBzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgdGhpcy51cmwpO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gaG9vayBzaWduYWxzXG4gICAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICByZXNvbHZlKG5ldyBYSFJSZXNwb25zZSh4aHIsIGRhdGEpKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IHJlamVjdDtcbiAgICAgIHhoci5vbmFib3J0ID0gKCkgPT4gcmVqZWN0KG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKSk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHhoci5hYm9ydCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/xhr.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/file.js":
/*!*********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/file.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeFileSource\": () => (/* binding */ makeFileSource)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?662e\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nfunction makeFileSource(path) {\n  return new FileSource(path);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0I7QUFDeUI7O0FBRTdDO0FBQ0E7QUFDQSxJQUFJLHFDQUFRO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxvQ0FBTztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLElBQUksb0NBQU87QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHlCQUF5QixzREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlLmpzP2RkM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuXG5mdW5jdGlvbiBjbG9zZUFzeW5jKGZkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMuY2xvc2UoZmQsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvcGVuQXN5bmMocGF0aCwgZmxhZ3MsIG1vZGUgPSB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5vcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoZmQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZEFzeW5jKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKC4uLmFyZ3MsIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgRmlsZVNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMub3BlblJlcXVlc3QgPSBvcGVuQXN5bmMocGF0aCwgJ3InKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UpIHtcbiAgICAvLyBUT0RPOiB1c2UgYHNpZ25hbGBcbiAgICBjb25zdCBmZCA9IGF3YWl0IHRoaXMub3BlblJlcXVlc3Q7XG4gICAgY29uc3QgeyBidWZmZXIgfSA9IGF3YWl0IHJlYWRBc3luYyhcbiAgICAgIGZkLFxuICAgICAgQnVmZmVyLmFsbG9jKHNsaWNlLmxlbmd0aCksXG4gICAgICAwLFxuICAgICAgc2xpY2UubGVuZ3RoLFxuICAgICAgc2xpY2Uub2Zmc2V0LFxuICAgICk7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBjb25zdCBmZCA9IGF3YWl0IHRoaXMub3BlblJlcXVlc3Q7XG4gICAgYXdhaXQgY2xvc2VBc3luYyhmZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGaWxlU291cmNlKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBGaWxlU291cmNlKHBhdGgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/file.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/filereader.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/filereader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeFileReaderSource\": () => (/* binding */ makeFileReaderSource)\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\nclass FileReaderSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nfunction makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZXJlYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2Qzs7QUFFN0MsK0JBQStCLHNEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlcmVhZGVyLmpzPzQwZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVNvdXJjZSB9IGZyb20gJy4vYmFzZXNvdXJjZS5qcyc7XG5cbmNsYXNzIEZpbGVSZWFkZXJTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IoZmlsZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBibG9iID0gdGhpcy5maWxlLnNsaWNlKHNsaWNlLm9mZnNldCwgc2xpY2Uub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICByZWFkZXIub25hYm9ydCA9IHJlamVjdDtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiByZWFkZXIuYWJvcnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc291cmNlIGZyb20gYSBnaXZlbiBmaWxlL2Jsb2IuXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGUgVGhlIGZpbGUgb3IgYmxvYiB0byByZWFkIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY29uc3RydWN0ZWQgc291cmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmlsZVJlYWRlclNvdXJjZShmaWxlKSB7XG4gIHJldHVybiBuZXcgRmlsZVJlYWRlclNvdXJjZShmaWxlKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/filereader.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/httputils.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/httputils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parseByteRanges\": () => (/* binding */ parseByteRanges),\n/* harmony export */   \"parseContentRange\": () => (/* binding */ parseContentRange),\n/* harmony export */   \"parseContentType\": () => (/* binding */ parseContentType)\n/* harmony export */ });\nconst CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nfunction parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nfunction parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nfunction parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvaHR0cHV0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQLHNEQUFzRDtBQUN0RDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixTQUFTO0FBQ3RDLHlCQUF5QixjQUFjOztBQUV2QztBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2h0dHB1dGlscy5qcz9iNTNjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENSTEZDUkxGID0gJ1xcclxcblxcclxcbic7XG5cbi8qXG4gKiBTaGltIGZvciAnT2JqZWN0LmZyb21FbnRyaWVzJ1xuICovXG5mdW5jdGlvbiBpdGVtc1RvT2JqZWN0KGl0ZW1zKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmZyb21FbnRyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaXRlbXMpO1xuICB9XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVtcykge1xuICAgIG9ialtrZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlIEhUVFAgaGVhZGVycyBmcm9tIGEgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgdG8gcGFyc2UgdGhlIGhlYWRlcnMgZnJvbVxuICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBoZWFkZXJzIHdpdGggbG93ZXJjYXNlIGtleXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHRleHQpIHtcbiAgY29uc3QgaXRlbXMgPSB0ZXh0XG4gICAgLnNwbGl0KCdcXHJcXG4nKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGt2ID0gbGluZS5zcGxpdCgnOicpLm1hcCgoc3RyKSA9PiBzdHIudHJpbSgpKTtcbiAgICAgIGt2WzBdID0ga3ZbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBrdjtcbiAgICB9KTtcblxuICByZXR1cm4gaXRlbXNUb09iamVjdChpdGVtcyk7XG59XG5cbi8qKlxuICogUGFyc2UgYSAnQ29udGVudC1UeXBlJyBoZWFkZXIgdmFsdWUgdG8gdGhlIGNvbnRlbnQtdHlwZSBhbmQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbnRlbnRUeXBlIHRoZSByYXcgc3RyaW5nIHRvIHBhcnNlIGZyb21cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgY29udGVudCB0eXBlIHdpdGggdGhlIGZpZWxkczogdHlwZSBhbmQgcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRUeXBlKHJhd0NvbnRlbnRUeXBlKSB7XG4gIGNvbnN0IFt0eXBlLCAuLi5yYXdQYXJhbXNdID0gcmF3Q29udGVudFR5cGUuc3BsaXQoJzsnKS5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgY29uc3QgcGFyYW1zSXRlbXMgPSByYXdQYXJhbXMubWFwKChwYXJhbSkgPT4gcGFyYW0uc3BsaXQoJz0nKSk7XG4gIHJldHVybiB7IHR5cGUsIHBhcmFtczogaXRlbXNUb09iamVjdChwYXJhbXNJdGVtcykgfTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhICdDb250ZW50LVJhbmdlJyBoZWFkZXIgdmFsdWUgdG8gaXRzIHN0YXJ0LCBlbmQsIGFuZCB0b3RhbCBwYXJ0c1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbnRlbnRSYW5nZSB0aGUgcmF3IHN0cmluZyB0byBwYXJzZSBmcm9tXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIHBhcnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRSYW5nZShyYXdDb250ZW50UmFuZ2UpIHtcbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuICBsZXQgdG90YWw7XG5cbiAgaWYgKHJhd0NvbnRlbnRSYW5nZSkge1xuICAgIFssIHN0YXJ0LCBlbmQsIHRvdGFsXSA9IHJhd0NvbnRlbnRSYW5nZS5tYXRjaCgvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8pO1xuICAgIHN0YXJ0ID0gcGFyc2VJbnQoc3RhcnQsIDEwKTtcbiAgICBlbmQgPSBwYXJzZUludChlbmQsIDEwKTtcbiAgICB0b3RhbCA9IHBhcnNlSW50KHRvdGFsLCAxMCk7XG4gIH1cblxuICByZXR1cm4geyBzdGFydCwgZW5kLCB0b3RhbCB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhIGxpc3Qgb2YgYnl0ZXJhbmdlcyBmcm9tIHRoZSBnaXZlbiAnbXVsdGlwYXJ0L2J5dGVyYW5nZXMnIEhUVFAgcmVzcG9uc2UuXG4gKiBFYWNoIGl0ZW0gaW4gdGhlIGxpc3QgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIC0gaGVhZGVyczogdGhlIEhUVFAgaGVhZGVyc1xuICogLSBkYXRhOiB0aGUgc2xpY2VkIEFycmF5QnVmZmVyIGZvciB0aGF0IHNwZWNpZmljIHBhcnRcbiAqIC0gb2Zmc2V0OiB0aGUgb2Zmc2V0IG9mIHRoZSBieXRlcmFuZ2Ugd2l0aGluIGl0cyBvcmlnaW5hdGluZyBmaWxlXG4gKiAtIGxlbmd0aDogdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZXJhbmdlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSByZXNwb25zZUFycmF5QnVmZmVyIHRoZSByZXNwb25zZSB0byBiZSBwYXJzZWQgYW5kIHNwbGl0XG4gKiBAcGFyYW0ge1N0cmluZ30gYm91bmRhcnkgdGhlIGJvdW5kYXJ5IHN0cmluZyB1c2VkIHRvIHNwbGl0IHRoZSBzZWN0aW9uc1xuICogQHJldHVybnMge09iamVjdFtdfSB0aGUgcGFyc2VkIGJ5dGVyYW5nZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQnl0ZVJhbmdlcyhyZXNwb25zZUFycmF5QnVmZmVyLCBib3VuZGFyeSkge1xuICBsZXQgb2Zmc2V0ID0gbnVsbDtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcignYXNjaWknKTtcbiAgY29uc3Qgb3V0ID0gW107XG5cbiAgY29uc3Qgc3RhcnRCb3VuZGFyeSA9IGAtLSR7Ym91bmRhcnl9YDtcbiAgY29uc3QgZW5kQm91bmRhcnkgPSBgJHtzdGFydEJvdW5kYXJ5fS0tYDtcblxuICAvLyBzZWFyY2ggZm9yIHRoZSBpbml0aWFsIGJvdW5kYXJ5LCBtYXkgYmUgb2Zmc2V0IGJ5IHNvbWUgYnl0ZXNcbiAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgdG8gY2hlY2sgZm9yIGAtLWAgaW4gYnl0ZXMgZGlyZWN0bHlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2VBcnJheUJ1ZmZlciwgaSwgc3RhcnRCb3VuZGFyeS5sZW5ndGgpLFxuICAgICk7XG4gICAgaWYgKHRleHQgPT09IHN0YXJ0Qm91bmRhcnkpIHtcbiAgICAgIG9mZnNldCA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9mZnNldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaW5pdGlhbCBib3VuZGFyeScpO1xuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA8IHJlc3BvbnNlQXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IHRleHQgPSBkZWNvZGVyLmRlY29kZShcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3BvbnNlQXJyYXlCdWZmZXIsIG9mZnNldCxcbiAgICAgICAgTWF0aC5taW4oc3RhcnRCb3VuZGFyeS5sZW5ndGggKyAxMDI0LCByZXNwb25zZUFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBvZmZzZXQpLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgLy8gYnJlYWsgaWYgd2UgYXJyaXZlZCBhdCB0aGUgZW5kXG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAwIHx8IHRleHQuc3RhcnRzV2l0aChlbmRCb3VuZGFyeSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGFzc2VydCB0aGF0IHdlIGFyZSBhY3R1YWxseSBkZWFsaW5nIHdpdGggYSBieXRlcmFuZ2UgYW5kIGFyZSBhdCB0aGUgY29ycmVjdCBvZmZzZXRcbiAgICBpZiAoIXRleHQuc3RhcnRzV2l0aChzdGFydEJvdW5kYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0IGRvZXMgbm90IHN0YXJ0IHdpdGggYm91bmRhcnknKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYSBzdWJzdHJpbmcgZnJvbSB3aGVyZSB3ZSByZWFkIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgaW5uZXJUZXh0ID0gdGV4dC5zdWJzdHIoc3RhcnRCb3VuZGFyeS5sZW5ndGggKyAyKTtcblxuICAgIGlmIChpbm5lclRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSBkb3VibGUgbGluZWJyZWFrIHRoYXQgZGVub3RlcyB0aGUgZW5kIG9mIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gaW5uZXJUZXh0LmluZGV4T2YoQ1JMRkNSTEYpO1xuXG4gICAgLy8gcGFyc2UgdGhlIGhlYWRlcnMgdG8gZ2V0IHRoZSBjb250ZW50IHJhbmdlIHNpemVcbiAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VIZWFkZXJzKGlubmVyVGV4dC5zdWJzdHIoMCwgZW5kT2ZIZWFkZXJzKSk7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kLCB0b3RhbCB9ID0gcGFyc2VDb250ZW50UmFuZ2UoaGVhZGVyc1snY29udGVudC1yYW5nZSddKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBzbGljZSBhbmQgdGhlIG5leHQgb2Zmc2V0XG4gICAgY29uc3Qgc3RhcnRPZkRhdGEgPSBvZmZzZXQgKyBzdGFydEJvdW5kYXJ5Lmxlbmd0aCArIGVuZE9mSGVhZGVycyArIENSTEZDUkxGLmxlbmd0aDtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChlbmQsIDEwKSArIDEgLSBwYXJzZUludChzdGFydCwgMTApO1xuICAgIG91dC5wdXNoKHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBkYXRhOiByZXNwb25zZUFycmF5QnVmZmVyLnNsaWNlKHN0YXJ0T2ZEYXRhLCBzdGFydE9mRGF0YSArIGxlbmd0aCksXG4gICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgZmlsZVNpemU6IHRvdGFsLFxuICAgIH0pO1xuXG4gICAgb2Zmc2V0ID0gc3RhcnRPZkRhdGEgKyBsZW5ndGggKyA0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/httputils.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/remote.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/remote.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeFetchSource\": () => (/* binding */ makeFetchSource),\n/* harmony export */   \"makeHttpSource\": () => (/* binding */ makeHttpSource),\n/* harmony export */   \"makeRemoteSource\": () => (/* binding */ makeRemoteSource),\n/* harmony export */   \"makeXHRSource\": () => (/* binding */ makeXHRSource)\n/* harmony export */ });\n/* harmony import */ var _httputils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./httputils.js */ \"./node_modules/geotiff/dist-module/source/httputils.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockedsource.js */ \"./node_modules/geotiff/dist-module/source/blockedsource.js\");\n/* harmony import */ var _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/fetch.js */ \"./node_modules/geotiff/dist-module/source/client/fetch.js\");\n/* harmony import */ var _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/xhr.js */ \"./node_modules/geotiff/dist-module/source/client/xhr.js\");\n/* harmony import */ var _client_http_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/http.js */ \"./node_modules/geotiff/dist-module/source/client/http.js\");\n\n\n\n\n\n\n\n\nclass RemoteSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseByteRanges)(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__.BlockedSource(source, { blockSize, cacheSize });\n}\n\nfunction makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__.FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__.XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_http_js__WEBPACK_IMPORTED_MODULE_5__.HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nfunction makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvcmVtb3RlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBc0Y7QUFDekM7QUFDTTs7QUFFSDtBQUNKO0FBQ0U7O0FBRTlDLDJCQUEyQixzREFBVTtBQUNyQztBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsa0JBQWtCLGdCQUFnQixRQUFRLE9BQU8sR0FBRyxnQkFBZ0I7QUFDcEU7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsZUFBZSxFQUFFLCtEQUFnQjtBQUMvQztBQUNBLDJCQUEyQiw4REFBZTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxvQkFBb0IsRUFBRSxnRUFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLEdBQUcsZ0JBQWdCO0FBQ2xELE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLGNBQWMsUUFBUSxFQUFFLGdFQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUFhLFdBQVcsc0JBQXNCO0FBQzNEOztBQUVPLGdDQUFnQyxZQUFZLHVFQUF1RSxJQUFJO0FBQzlILHFCQUFxQix5REFBVztBQUNoQztBQUNBO0FBQ0E7O0FBRU8sOEJBQThCLFlBQVksMERBQTBELElBQUk7QUFDL0cscUJBQXFCLHFEQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFTywrQkFBK0IsWUFBWSwwREFBMEQsSUFBSTtBQUNoSCxxQkFBcUIsdURBQVU7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ08saUNBQWlDLHFDQUFxQyxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL3JlbW90ZS5qcz8xNjUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlQnl0ZVJhbmdlcywgcGFyc2VDb250ZW50UmFuZ2UsIHBhcnNlQ29udGVudFR5cGUgfSBmcm9tICcuL2h0dHB1dGlscy5qcyc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEJsb2NrZWRTb3VyY2UgfSBmcm9tICcuL2Jsb2NrZWRzb3VyY2UuanMnO1xuXG5pbXBvcnQgeyBGZXRjaENsaWVudCB9IGZyb20gJy4vY2xpZW50L2ZldGNoLmpzJztcbmltcG9ydCB7IFhIUkNsaWVudCB9IGZyb20gJy4vY2xpZW50L3hoci5qcyc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQvaHR0cC5qcyc7XG5cbmNsYXNzIFJlbW90ZVNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtCYXNlQ2xpZW50fSBjbGllbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnNcbiAgICogQHBhcmFtIHtudW1iZXJzfSBtYXhSYW5nZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd0Z1bGxGaWxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLm1heFJhbmdlcyA9IG1heFJhbmdlcztcbiAgICB0aGlzLmFsbG93RnVsbEZpbGUgPSBhbGxvd0Z1bGxGaWxlO1xuICAgIHRoaXMuX2ZpbGVTaXplID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NsaWNlW119IHNsaWNlc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwpIHtcbiAgICAvLyBpZiB3ZSBhbGxvdyBtdWx0aS1yYW5nZXMsIHNwbGl0IHRoZSBpbmNvbWluZyByZXF1ZXN0IGludG8gdGhhdCBtYW55IHN1Yi1yZXF1ZXN0c1xuICAgIC8vIGFuZCBqb2luIHRoZW0gYWZ0ZXJ3YXJkc1xuICAgIGlmICh0aGlzLm1heFJhbmdlcyA+PSBzbGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaFNsaWNlcyhzbGljZXMsIHNpZ25hbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1heFJhbmdlcyA+IDAgJiYgc2xpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFRPRE86IHNwbGl0IGludG8gbXVsdGlwbGUgbXVsdGktcmFuZ2UgcmVxdWVzdHNcblxuICAgICAgLy8gY29uc3Qgc3ViU2xpY2VzUmVxdWVzdHMgPSBbXTtcbiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2VzLmxlbmd0aDsgaSArPSB0aGlzLm1heFJhbmdlcykge1xuICAgICAgLy8gICBzdWJTbGljZXNSZXF1ZXN0cy5wdXNoKFxuICAgICAgLy8gICAgIHRoaXMuZmV0Y2hTbGljZXMoc2xpY2VzLnNsaWNlKGksIGkgKyB0aGlzLm1heFJhbmdlcyksIHNpZ25hbCksXG4gICAgICAvLyAgICk7XG4gICAgICAvLyB9XG4gICAgICAvLyByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKHN1YlNsaWNlc1JlcXVlc3RzKSkuZmxhdCgpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBtYWtlIGEgc2luZ2xlIHJlcXVlc3QgZm9yIGVhY2ggc2xpY2VcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzbGljZXMubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hTbGljZXMoc2xpY2VzLCBzaWduYWwpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtzbGljZXNcbiAgICAgICAgICAubWFwKCh7IG9mZnNldCwgbGVuZ3RoIH0pID0+IGAke29mZnNldH0tJHtvZmZzZXQgKyBsZW5ndGh9YClcbiAgICAgICAgICAuam9pbignLCcpXG4gICAgICAgIH1gLFxuICAgICAgfSxcbiAgICAgIHNpZ25hbCxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YS4nKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7XG4gICAgICBjb25zdCB7IHR5cGUsIHBhcmFtcyB9ID0gcGFyc2VDb250ZW50VHlwZShyZXNwb25zZS5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKTtcbiAgICAgIGlmICh0eXBlID09PSAnbXVsdGlwYXJ0L2J5dGVyYW5nZXMnKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVSYW5nZXMgPSBwYXJzZUJ5dGVSYW5nZXMoYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpLCBwYXJhbXMuYm91bmRhcnkpO1xuICAgICAgICB0aGlzLl9maWxlU2l6ZSA9IGJ5dGVSYW5nZXNbMF0uZmlsZVNpemUgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIGJ5dGVSYW5nZXM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgdG90YWwgfSA9IHBhcnNlQ29udGVudFJhbmdlKHJlc3BvbnNlLmdldEhlYWRlcignY29udGVudC1yYW5nZScpKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gdG90YWwgfHwgbnVsbDtcbiAgICAgIGNvbnN0IGZpcnN0ID0gW3tcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcbiAgICAgIH1dO1xuXG4gICAgICBpZiAoc2xpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gd2UgcmVxdWVzdGVkIG1vcmUgdGhhbiBvbmUgc2xpY2UsIGJ1dCBnb3Qgb25seSB0aGUgZmlyc3RcbiAgICAgICAgLy8gdW5mb3J0dW5hdGVseSwgc29tZSBIVFRQIFNlcnZlcnMgZG9uJ3Qgc3VwcG9ydCBtdWx0aS1yYW5nZXNcbiAgICAgICAgLy8gYW5kIHJldHVybiBvbnlsIHRoZSBmaXJzdFxuXG4gICAgICAgIC8vIGdldCB0aGUgcmVzdCBvZiB0aGUgc2xpY2VzIGFuZCBmZXRjaCB0aGVtIGl0ZXJhdGV0aXZlbHlcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoc2xpY2VzLnNsaWNlKDEpLm1hcCgoc2xpY2UpID0+IHRoaXMuZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSkpO1xuICAgICAgICByZXR1cm4gZmlyc3QuY29uY2F0KG90aGVycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5hbGxvd0Z1bGxGaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIHJlc3BvbmRlZCB3aXRoIGZ1bGwgZmlsZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgbGVuZ3RoOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICB9XTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpIHtcbiAgICBjb25zdCB7IG9mZnNldCwgbGVuZ3RoIH0gPSBzbGljZTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtvZmZzZXR9LSR7b2Zmc2V0ICsgbGVuZ3RofWAsXG4gICAgICB9LFxuICAgICAgc2lnbmFsLFxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgdGhlIHJlc3BvbnNlIHdhcyBva2F5IGFuZCBpZiB0aGUgc2VydmVyIGFjdHVhbGx5IHVuZGVyc3RhbmRzIHJhbmdlIHJlcXVlc3RzXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBkYXRhLicpO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIGNvbnN0IHsgdG90YWwgfSA9IHBhcnNlQ29udGVudFJhbmdlKHJlc3BvbnNlLmdldEhlYWRlcignY29udGVudC1yYW5nZScpKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gdG90YWwgfHwgbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmFsbG93RnVsbEZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZnVsbCBmaWxlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsZW5ndGg6IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlU2l6ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCB7IGJsb2NrU2l6ZSwgY2FjaGVTaXplIH0pIHtcbiAgaWYgKGJsb2NrU2l6ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9ja2VkU291cmNlKHNvdXJjZSwgeyBibG9ja1NpemUsIGNhY2hlU2l6ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGZXRjaFNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBjcmVkZW50aWFscywgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBGZXRjaENsaWVudCh1cmwsIGNyZWRlbnRpYWxzKTtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVhIUlNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IFhIUkNsaWVudCh1cmwpO1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSHR0cFNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IEh0dHBDbGllbnQodXJsKTtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlbW90ZVNvdXJjZSh1cmwsIHsgZm9yY2VYSFIgPSBmYWxzZSwgLi4uY2xpZW50T3B0aW9ucyB9ID0ge30pIHtcbiAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZm9yY2VYSFIpIHtcbiAgICByZXR1cm4gbWFrZUZldGNoU291cmNlKHVybCwgY2xpZW50T3B0aW9ucyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbWFrZVhIUlNvdXJjZSh1cmwsIGNsaWVudE9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBtYWtlSHR0cFNvdXJjZSh1cmwsIGNsaWVudE9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/remote.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/geotiff/dist-module/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbortError\": () => (/* binding */ AbortError),\n/* harmony export */   \"AggregateError\": () => (/* binding */ AggregateError),\n/* harmony export */   \"CustomAggregateError\": () => (/* binding */ CustomAggregateError),\n/* harmony export */   \"assign\": () => (/* binding */ assign),\n/* harmony export */   \"chunk\": () => (/* binding */ chunk),\n/* harmony export */   \"endsWith\": () => (/* binding */ endsWith),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"parseContentRange\": () => (/* binding */ parseContentRange),\n/* harmony export */   \"range\": () => (/* binding */ range),\n/* harmony export */   \"times\": () => (/* binding */ times),\n/* harmony export */   \"toArray\": () => (/* binding */ toArray),\n/* harmony export */   \"toArrayRecursively\": () => (/* binding */ toArrayRecursively),\n/* harmony export */   \"wait\": () => (/* binding */ wait),\n/* harmony export */   \"zip\": () => (/* binding */ zip)\n/* harmony export */ });\nfunction assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nfunction endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nfunction forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nfunction invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nfunction range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nfunction times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nfunction toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nfunction toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nfunction parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nasync function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nfunction zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nclass AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nclass CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nconst AggregateError = CustomAggregateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLFNBQVM7QUFDbkIsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLFVBQVUsU0FBUztBQUNuQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS91dGlscy5qcz9mYjRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2h1bmsoaXRlcmFibGUsIGxlbmd0aCkge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGNvbnN0IGxlbmd0aE9mSXRlcmFibGUgPSBpdGVyYWJsZS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoT2ZJdGVyYWJsZTsgaSArPSBsZW5ndGgpIHtcbiAgICBjb25zdCBjaHVua2VkID0gW107XG4gICAgZm9yIChsZXQgY2kgPSBpOyBjaSA8IGkgKyBsZW5ndGg7IGNpKyspIHtcbiAgICAgIGNodW5rZWQucHVzaChpdGVyYWJsZVtjaV0pO1xuICAgIH1cbiAgICByZXN1bHRzLnB1c2goY2h1bmtlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIGV4cGVjdGVkRW5kaW5nKSB7XG4gIGlmIChzdHJpbmcubGVuZ3RoIDwgZXhwZWN0ZWRFbmRpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFjdHVhbEVuZGluZyA9IHN0cmluZy5zdWJzdHIoc3RyaW5nLmxlbmd0aCAtIGV4cGVjdGVkRW5kaW5nLmxlbmd0aCk7XG4gIHJldHVybiBhY3R1YWxFbmRpbmcgPT09IGV4cGVjdGVkRW5kaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChpdGVyYWJsZSwgZnVuYykge1xuICBjb25zdCB7IGxlbmd0aCB9ID0gaXRlcmFibGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBmdW5jKGl0ZXJhYmxlW2ldLCBpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG9sZE9iaikge1xuICBjb25zdCBuZXdPYmogPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2xkT2JqKSB7XG4gICAgaWYgKG9sZE9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9sZE9ialtrZXldO1xuICAgICAgbmV3T2JqW3ZhbHVlXSA9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld09iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKG4pIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHJlc3VsdHMucHVzaChpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVzKG51bVRpbWVzLCBmdW5jKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UaW1lczsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGZ1bmMoaSkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShpdGVyYWJsZSkge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBpdGVyYWJsZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdHMucHVzaChpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5UmVjdXJzaXZlbHkoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiB0b0FycmF5KGlucHV0KS5tYXAodG9BcnJheVJlY3Vyc2l2ZWx5KTtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5cbi8vIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hY2FkZW1pYS1kZS1jb2RpZ28vcGFyc2UtY29udGVudC1yYW5nZS1oZWFkZXIvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRSYW5nZShoZWFkZXJWYWx1ZSkge1xuICBpZiAoIWhlYWRlclZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGhlYWRlclZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgY29uc3QgcGFyc2VJbnQgPSAobnVtYmVyKSA9PiBOdW1iZXIucGFyc2VJbnQobnVtYmVyLCAxMCk7XG5cbiAgLy8gQ2hlY2sgZm9yIHByZXNlbmNlIG9mIHVuaXRcbiAgbGV0IG1hdGNoZXMgPSBoZWFkZXJWYWx1ZS5tYXRjaCgvXihcXHcqKSAvKTtcbiAgY29uc3QgdW5pdCA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXTtcblxuICAvLyBjaGVjayBmb3Igc3RhcnQtZW5kL3NpemUgaGVhZGVyIGZvcm1hdFxuICBtYXRjaGVzID0gaGVhZGVyVmFsdWUubWF0Y2goLyhcXGQrKS0oXFxkKylcXC8oXFxkK3xcXCopLyk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXQsXG4gICAgICBmaXJzdDogcGFyc2VJbnQobWF0Y2hlc1sxXSksXG4gICAgICBsYXN0OiBwYXJzZUludChtYXRjaGVzWzJdKSxcbiAgICAgIGxlbmd0aDogbWF0Y2hlc1szXSA9PT0gJyonID8gbnVsbCA6IHBhcnNlSW50KG1hdGNoZXNbM10pLFxuICAgIH07XG4gIH1cblxuICAvLyBjaGVjayBmb3Igc2l6ZSBoZWFkZXIgZm9ybWF0XG4gIG1hdGNoZXMgPSBoZWFkZXJWYWx1ZS5tYXRjaCgvKFxcZCt8XFwqKS8pO1xuICBpZiAobWF0Y2hlcykge1xuICAgIHJldHVybiB7XG4gICAgICB1bml0LFxuICAgICAgZmlyc3Q6IG51bGwsXG4gICAgICBsYXN0OiBudWxsLFxuICAgICAgbGVuZ3RoOiBtYXRjaGVzWzFdID09PSAnKicgPyBudWxsIDogcGFyc2VJbnQobWF0Y2hlc1sxXSksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKlxuICogUHJvbWlzaWZpZWQgd3JhcHBlciBhcm91bmQgJ3NldFRpbWVvdXQnIHRvIGFsbG93ICdhd2FpdCdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXQobWlsbGlzZWNvbmRzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtaWxsaXNlY29uZHMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHppcChhLCBiKSB7XG4gIGNvbnN0IEEgPSBBcnJheS5pc0FycmF5KGEpID8gYSA6IEFycmF5LmZyb20oYSk7XG4gIGNvbnN0IEIgPSBBcnJheS5pc0FycmF5KGIpID8gYiA6IEFycmF5LmZyb20oYik7XG4gIHJldHVybiBBLm1hcCgoaywgaSkgPT4gW2ssIEJbaV1dKTtcbn1cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3JcbmV4cG9ydCBjbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAvLyBQYXNzIHJlbWFpbmluZyBhcmd1bWVudHMgKGluY2x1ZGluZyB2ZW5kb3Igc3BlY2lmaWMgb25lcykgdG8gcGFyZW50IGNvbnN0cnVjdG9yXG4gICAgc3VwZXIocGFyYW1zKTtcblxuICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEFib3J0RXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ3VzdG9tQWdncmVnYXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGVycm9ycywgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gJ0FnZ3JlZ2F0ZUVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQWdncmVnYXRlRXJyb3IgPSBDdXN0b21BZ2dyZWdhdGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/utils.js\n");

/***/ }),

/***/ "./node_modules/quick-lru/index.js":
/*!*****************************************!*\
  !*** ./node_modules/quick-lru/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ QuickLRU)\n/* harmony export */ });\nclass QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0IsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSixtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uL25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanM/MjZhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBRdWlja0xSVSBleHRlbmRzIE1hcCB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHRpZiAoIShvcHRpb25zLm1heFNpemUgJiYgb3B0aW9ucy5tYXhTaXplID4gMCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLm1heEFnZSA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5tYXhBZ2UgPT09IDApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BtYXhBZ2VgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBVc2UgcHJpdmF0ZSBjbGFzcyBmaWVsZHMgd2hlbiBFU0xpbnQgc3VwcG9ydHMgdGhlbS5cblx0XHR0aGlzLm1heFNpemUgPSBvcHRpb25zLm1heFNpemU7XG5cdFx0dGhpcy5tYXhBZ2UgPSBvcHRpb25zLm1heEFnZSB8fCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0dGhpcy5vbkV2aWN0aW9uID0gb3B0aW9ucy5vbkV2aWN0aW9uO1xuXHRcdHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLl9zaXplID0gMDtcblx0fVxuXG5cdC8vIFRPRE86IFVzZSBwcml2YXRlIGNsYXNzIG1ldGhvZHMgd2hlbiB0YXJnZXRpbmcgTm9kZS5qcyAxNi5cblx0X2VtaXRFdmljdGlvbnMoY2FjaGUpIHtcblx0XHRpZiAodHlwZW9mIHRoaXMub25FdmljdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgY2FjaGUpIHtcblx0XHRcdHRoaXMub25FdmljdGlvbihrZXksIGl0ZW0udmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdF9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSB7XG5cdFx0aWYgKHR5cGVvZiBpdGVtLmV4cGlyeSA9PT0gJ251bWJlcicgJiYgaXRlbS5leHBpcnkgPD0gRGF0ZS5ub3coKSkge1xuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLm9uRXZpY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhpcy5vbkV2aWN0aW9uKGtleSwgaXRlbS52YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdF9nZXRPckRlbGV0ZUlmRXhwaXJlZChrZXksIGl0ZW0pIHtcblx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSk7XG5cdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS52YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRfZ2V0SXRlbVZhbHVlKGtleSwgaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLmV4cGlyeSA/IHRoaXMuX2dldE9yRGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgOiBpdGVtLnZhbHVlO1xuXHR9XG5cblx0X3BlZWsoa2V5LCBjYWNoZSkge1xuXHRcdGNvbnN0IGl0ZW0gPSBjYWNoZS5nZXQoa2V5KTtcblxuXHRcdHJldHVybiB0aGlzLl9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKTtcblx0fVxuXG5cdF9zZXQoa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuXHRcdHRoaXMuX3NpemUrKztcblxuXHRcdGlmICh0aGlzLl9zaXplID49IHRoaXMubWF4U2l6ZSkge1xuXHRcdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdFx0XHR0aGlzLl9lbWl0RXZpY3Rpb25zKHRoaXMub2xkQ2FjaGUpO1xuXHRcdFx0dGhpcy5vbGRDYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0XHR0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuXHRcdH1cblx0fVxuXG5cdF9tb3ZlVG9SZWNlbnQoa2V5LCBpdGVtKSB7XG5cdFx0dGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KTtcblx0XHR0aGlzLl9zZXQoa2V5LCBpdGVtKTtcblx0fVxuXG5cdCogX2VudHJpZXNBc2NlbmRpbmcoKSB7XG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMub2xkQ2FjaGUpIHtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTtcblx0XHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0eWllbGQgaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTtcblx0XHRcdGlmIChkZWxldGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHR5aWVsZCBpdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGdldChrZXkpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG5cblx0XHRcdHJldHVybiB0aGlzLl9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7XG5cdFx0XHRpZiAodGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX21vdmVUb1JlY2VudChrZXksIGl0ZW0pO1xuXHRcdFx0XHRyZXR1cm4gaXRlbS52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRzZXQoa2V5LCB2YWx1ZSwge21heEFnZSA9IHRoaXMubWF4QWdlfSA9IHt9KSB7XG5cdFx0Y29uc3QgZXhwaXJ5ID1cblx0XHRcdHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInICYmIG1heEFnZSAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID9cblx0XHRcdFx0RGF0ZS5ub3coKSArIG1heEFnZSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0dGhpcy5jYWNoZS5zZXQoa2V5LCB7XG5cdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRleHBpcnlcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZXQoa2V5LCB7dmFsdWUsIGV4cGlyeX0pO1xuXHRcdH1cblx0fVxuXG5cdGhhcyhrZXkpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuICF0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB0aGlzLmNhY2hlLmdldChrZXkpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuICF0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB0aGlzLm9sZENhY2hlLmdldChrZXkpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRwZWVrKGtleSkge1xuXHRcdGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGVlayhrZXksIHRoaXMuY2FjaGUpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGVlayhrZXksIHRoaXMub2xkQ2FjaGUpO1xuXHRcdH1cblx0fVxuXG5cdGRlbGV0ZShrZXkpIHtcblx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcblx0XHRpZiAoZGVsZXRlZCkge1xuXHRcdFx0dGhpcy5fc2l6ZS0tO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpIHx8IGRlbGV0ZWQ7XG5cdH1cblxuXHRjbGVhcigpIHtcblx0XHR0aGlzLmNhY2hlLmNsZWFyKCk7XG5cdFx0dGhpcy5vbGRDYWNoZS5jbGVhcigpO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXHR9XG5cblx0cmVzaXplKG5ld1NpemUpIHtcblx0XHRpZiAoIShuZXdTaXplICYmIG5ld1NpemUgPiAwKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcblx0XHR9XG5cblx0XHRjb25zdCBpdGVtcyA9IFsuLi50aGlzLl9lbnRyaWVzQXNjZW5kaW5nKCldO1xuXHRcdGNvbnN0IHJlbW92ZUNvdW50ID0gaXRlbXMubGVuZ3RoIC0gbmV3U2l6ZTtcblx0XHRpZiAocmVtb3ZlQ291bnQgPCAwKSB7XG5cdFx0XHR0aGlzLmNhY2hlID0gbmV3IE1hcChpdGVtcyk7XG5cdFx0XHR0aGlzLm9sZENhY2hlID0gbmV3IE1hcCgpO1xuXHRcdFx0dGhpcy5fc2l6ZSA9IGl0ZW1zLmxlbmd0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHJlbW92ZUNvdW50ID4gMCkge1xuXHRcdFx0XHR0aGlzLl9lbWl0RXZpY3Rpb25zKGl0ZW1zLnNsaWNlKDAsIHJlbW92ZUNvdW50KSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKGl0ZW1zLnNsaWNlKHJlbW92ZUNvdW50KSk7XG5cdFx0XHR0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuXHRcdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdFx0fVxuXG5cdFx0dGhpcy5tYXhTaXplID0gbmV3U2l6ZTtcblx0fVxuXG5cdCoga2V5cygpIHtcblx0XHRmb3IgKGNvbnN0IFtrZXldIG9mIHRoaXMpIHtcblx0XHRcdHlpZWxkIGtleTtcblx0XHR9XG5cdH1cblxuXHQqIHZhbHVlcygpIHtcblx0XHRmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzKSB7XG5cdFx0XHR5aWVsZCB2YWx1ZTtcblx0XHR9XG5cdH1cblxuXHQqIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTtcblx0XHRcdGlmIChkZWxldGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMub2xkQ2FjaGUpIHtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTtcblx0XHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0KiBlbnRyaWVzRGVzY2VuZGluZygpIHtcblx0XHRsZXQgaXRlbXMgPSBbLi4udGhpcy5jYWNoZV07XG5cdFx0Zm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTtcblx0XHRcdGlmIChkZWxldGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aXRlbXMgPSBbLi4udGhpcy5vbGRDYWNoZV07XG5cdFx0Zm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdGlmIChkZWxldGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdCogZW50cmllc0FzY2VuZGluZygpIHtcblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9lbnRyaWVzQXNjZW5kaW5nKCkpIHtcblx0XHRcdHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcblx0XHR9XG5cdH1cblxuXHRnZXQgc2l6ZSgpIHtcblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHJldHVybiB0aGlzLm9sZENhY2hlLnNpemU7XG5cdFx0fVxuXG5cdFx0bGV0IG9sZENhY2hlU2l6ZSA9IDA7XG5cdFx0Zm9yIChjb25zdCBrZXkgb2YgdGhpcy5vbGRDYWNoZS5rZXlzKCkpIHtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHRvbGRDYWNoZVNpemUrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5taW4odGhpcy5fc2l6ZSArIG9sZENhY2hlU2l6ZSwgdGhpcy5tYXhTaXplKTtcblx0fVxuXG5cdGVudHJpZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW50cmllc0FzY2VuZGluZygpO1xuXHR9XG5cblx0Zm9yRWFjaChjYWxsYmFja0Z1bmN0aW9uLCB0aGlzQXJndW1lbnQgPSB0aGlzKSB7XG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5lbnRyaWVzQXNjZW5kaW5nKCkpIHtcblx0XHRcdGNhbGxiYWNrRnVuY3Rpb24uY2FsbCh0aGlzQXJndW1lbnQsIHZhbHVlLCBrZXksIHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoWy4uLnRoaXMuZW50cmllc0FzY2VuZGluZygpXSk7XG5cdH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/quick-lru/index.js\n");

/***/ })

}]);