/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_aics_web_3d_viewer"] = self["webpackChunk_aics_web_3d_viewer"] || []).push([["vendors-node_modules_geotiff_dist-module_compression_lerc_js"],{

/***/ "./node_modules/lerc/LercDecode.js":
/*!*****************************************!*\
  !*** ./node_modules/lerc/LercDecode.js ***!
  \*****************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;ï»¿/* jshint forin: false, bitwise: false */\n/*\nCopyright 2015-2021 Esri\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nA copy of the license and additional notices are located with the\nsource distribution at:\n\nhttp://github.com/Esri/lerc/\n\nContributors:  Johannes Schmid, (LERC v1)\n               Chayanika Khatua, (LERC v1)\n               Wenxue Ju (LERC v1, v2.x)\n*/\n\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\n\n/**\n * a module for decoding LERC blobs\n * @module Lerc\n */\n(function() {\n  //this decoder supports all lerc versions, each version has its own class (LercDecode and Lerc2Decode). \n  //the exported module handles format variation autoamtically.\n\n  //the original LercDecode for Version 1\n  var LercDecode = (function() {\n\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof.\n\n    var CntZImage = {};\n\n    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value\n\n    /**\n     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional\n     * information about it, such as the image's width and height.\n     *\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] Decoding options, containing any of the following properties:\n     * @config {number} [inputOffset = 0]\n     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.\n     * @config {Uint8Array} [encodedMask = null]\n     *        If specified, the decoder will not read mask information from the input and use the specified encoded\n     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.\n     * @config {number} [noDataValue = LercCode.defaultNoDataValue]\n     *        Pixel value to use for masked pixels.\n     * @config {ArrayBufferView|Array} [pixelType = Float32Array]\n     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to\n     *        provide an appropriate noDataValue if the default pixelType is overridden.\n     * @config {boolean} [returnMask = false]\n     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per\n     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the\n     *        input LERC data does not contain a mask, maskData will not be returned.\n     * @config {boolean} [returnEncodedMask = false]\n     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as\n     *        encodedMask.\n     * @config {boolean} [returnFileInfo = false]\n     *        If true, the return value will have a fileInfo property that contains metadata obtained from the\n     *        LERC headers and the decoding process.\n     * @config {boolean} [computeUsedBitDepths = false]\n     *        If true, the fileInfo property in the return value will contain the set of all block bit depths\n     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.\n     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}\n     */\n    CntZImage.decode = function(input, options) {\n      options = options || {};\n\n      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);\n      var parsedData = parse(input, options.inputOffset || 0, skipMask);\n\n      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;\n\n      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,\n        options.encodedMaskData, noDataValue, options.returnMask);\n\n      var result = {\n        width: parsedData.width,\n        height: parsedData.height,\n        pixelData: uncompressedData.resultPixels,\n        minValue: uncompressedData.minValue,\n        maxValue: parsedData.pixels.maxValue,\n        noDataValue: noDataValue\n      };\n\n      if (uncompressedData.resultMask) {\n        result.maskData = uncompressedData.resultMask;\n      }\n\n      if (options.returnEncodedMask && parsedData.mask) {\n        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;\n      }\n\n      if (options.returnFileInfo) {\n        result.fileInfo = formatFileInfo(parsedData);\n        if (options.computeUsedBitDepths) {\n          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);\n        }\n      }\n\n      return result;\n    };\n\n    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {\n      var blockIdx = 0;\n      var numX = data.pixels.numBlocksX;\n      var numY = data.pixels.numBlocksY;\n      var blockWidth = Math.floor(data.width / numX);\n      var blockHeight = Math.floor(data.height / numY);\n      var scale = 2 * data.maxZError;\n      var minValue = Number.MAX_VALUE, currentValue;\n      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);\n\n      var resultPixels, resultMask;\n      resultPixels = new TypedArrayClass(data.width * data.height);\n      if (storeDecodedMask && maskBitset) {\n        resultMask = new Uint8Array(data.width * data.height);\n      }\n      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);\n\n      var xx, yy;\n      for (var y = 0; y <= numY; y++) {\n        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);\n        if (thisBlockHeight === 0) {\n          continue;\n        }\n        for (var x = 0; x <= numX; x++) {\n          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);\n          if (thisBlockWidth === 0) {\n            continue;\n          }\n\n          var outPtr = y * data.width * blockHeight + x * blockWidth;\n          var outStride = data.width - thisBlockWidth;\n\n          var block = data.pixels.blocks[blockIdx];\n\n          var blockData, blockPtr, constValue;\n          if (block.encoding < 2) {\n            // block is either uncompressed or bit-stuffed (encodings 0 and 1)\n            if (block.encoding === 0) {\n              // block is uncompressed\n              blockData = block.rawData;\n            } else {\n              // block is bit-stuffed\n              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);\n              blockData = blockDataBuffer;\n            }\n            blockPtr = 0;\n          }\n          else if (block.encoding === 2) {\n            // block is all 0\n            constValue = 0;\n          }\n          else {\n            // block has constant value (encoding === 3)\n            constValue = block.offset;\n          }\n\n          var maskByte;\n          if (maskBitset) {\n            for (yy = 0; yy < thisBlockHeight; yy++) {\n              if (outPtr & 7) {\n                //\n                maskByte = maskBitset[outPtr >> 3];\n                maskByte <<= outPtr & 7;\n              }\n              for (xx = 0; xx < thisBlockWidth; xx++) {\n                if (!(outPtr & 7)) {\n                  // read next byte from mask\n                  maskByte = maskBitset[outPtr >> 3];\n                }\n                if (maskByte & 128) {\n                  // pixel data present\n                  if (resultMask) {\n                    resultMask[outPtr] = 1;\n                  }\n                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                } else {\n                  // pixel data not present\n                  if (resultMask) {\n                    resultMask[outPtr] = 0;\n                  }\n                  resultPixels[outPtr++] = noDataValue;\n                }\n                maskByte <<= 1;\n              }\n              outPtr += outStride;\n            }\n          } else {\n            // mask not present, simply copy block over\n            if (block.encoding < 2) {\n              // duplicating this code block for performance reasons\n              // blockData case:\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  currentValue = blockData[blockPtr++];\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                }\n                outPtr += outStride;\n              }\n            }\n            else {\n              // constValue case:\n              minValue = minValue > constValue ? constValue : minValue;\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  resultPixels[outPtr++] = constValue;\n                }\n                outPtr += outStride;\n              }\n            }\n          }\n          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {\n            throw \"Block and Mask do not match\";\n          }\n          blockIdx++;\n        }\n      }\n\n      return {\n        resultPixels: resultPixels,\n        resultMask: resultMask,\n        minValue: minValue\n      };\n    };\n\n    var formatFileInfo = function(data) {\n      return {\n        \"fileIdentifierString\": data.fileIdentifierString,\n        \"fileVersion\": data.fileVersion,\n        \"imageType\": data.imageType,\n        \"height\": data.height,\n        \"width\": data.width,\n        \"maxZError\": data.maxZError,\n        \"eofOffset\": data.eofOffset,\n        \"mask\": data.mask ? {\n          \"numBlocksX\": data.mask.numBlocksX,\n          \"numBlocksY\": data.mask.numBlocksY,\n          \"numBytes\": data.mask.numBytes,\n          \"maxValue\": data.mask.maxValue\n        } : null,\n        \"pixels\": {\n          \"numBlocksX\": data.pixels.numBlocksX,\n          \"numBlocksY\": data.pixels.numBlocksY,\n          \"numBytes\": data.pixels.numBytes,\n          \"maxValue\": data.pixels.maxValue,\n          \"noDataValue\": data.noDataValue\n        }\n      };\n    };\n\n    var computeUsedBitDepths = function(data) {\n      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;\n      var bitDepths = {};\n      for (var i = 0; i < numBlocks; i++) {\n        var block = data.pixels.blocks[i];\n        if (block.encoding === 0) {\n          bitDepths.float32 = true;\n        } else if (block.encoding === 1) {\n          bitDepths[block.bitsPerPixel] = true;\n        } else {\n          bitDepths[0] = true;\n        }\n      }\n\n      return Object.keys(bitDepths);\n    };\n\n    var parse = function(input, fp, skipMask) {\n      var data = {};\n\n      // File header\n      var fileIdView = new Uint8Array(input, fp, 10);\n      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      if (data.fileIdentifierString.trim() !== \"CntZImage\") {\n        throw \"Unexpected file identifier string: \" + data.fileIdentifierString;\n      }\n      fp += 10;\n      var view = new DataView(input, fp, 24);\n      data.fileVersion = view.getInt32(0, true);\n      data.imageType = view.getInt32(4, true);\n      data.height = view.getUint32(8, true);\n      data.width = view.getUint32(12, true);\n      data.maxZError = view.getFloat64(16, true);\n      fp += 24;\n\n      // Mask Header\n      if (!skipMask) {\n        view = new DataView(input, fp, 16);\n        data.mask = {};\n        data.mask.numBlocksY = view.getUint32(0, true);\n        data.mask.numBlocksX = view.getUint32(4, true);\n        data.mask.numBytes = view.getUint32(8, true);\n        data.mask.maxValue = view.getFloat32(12, true);\n        fp += 16;\n\n        // Mask Data\n        if (data.mask.numBytes > 0) {\n          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n          view = new DataView(input, fp, data.mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              var val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < data.mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n          data.mask.bitset = bitset;\n          fp += data.mask.numBytes;\n        }\n        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata\n          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n        }\n      }\n\n      // Pixel Header\n      view = new DataView(input, fp, 16);\n      data.pixels = {};\n      data.pixels.numBlocksY = view.getUint32(0, true);\n      data.pixels.numBlocksX = view.getUint32(4, true);\n      data.pixels.numBytes = view.getUint32(8, true);\n      data.pixels.maxValue = view.getFloat32(12, true);\n      fp += 16;\n\n      var numBlocksX = data.pixels.numBlocksX;\n      var numBlocksY = data.pixels.numBlocksY;\n      // the number of blocks specified in the header does not take into account the blocks at the end of\n      // each row/column with a special width/height that make the image complete in case the width is not\n      // evenly divisible by the number of blocks.\n      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);\n      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);\n      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);\n      var blockI = 0;\n      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {\n        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {\n\n          // Block\n          var size = 0;\n          var bytesLeft = input.byteLength - fp;\n          view = new DataView(input, fp, Math.min(10, bytesLeft));\n          var block = {};\n          data.pixels.blocks[blockI++] = block;\n          var headerByte = view.getUint8(0); size++;\n          block.encoding = headerByte & 63;\n          if (block.encoding > 3) {\n            throw \"Invalid block encoding (\" + block.encoding + \")\";\n          }\n          if (block.encoding === 2) {\n            fp++;\n            continue;\n          }\n          if ((headerByte !== 0) && (headerByte !== 2)) {\n            headerByte >>= 6;\n            block.offsetType = headerByte;\n            if (headerByte === 2) {\n              block.offset = view.getInt8(1); size++;\n            } else if (headerByte === 1) {\n              block.offset = view.getInt16(1, true); size += 2;\n            } else if (headerByte === 0) {\n              block.offset = view.getFloat32(1, true); size += 4;\n            } else {\n              throw \"Invalid block offset type\";\n            }\n\n            if (block.encoding === 1) {\n              headerByte = view.getUint8(size); size++;\n              block.bitsPerPixel = headerByte & 63;\n              headerByte >>= 6;\n              block.numValidPixelsType = headerByte;\n              if (headerByte === 2) {\n                block.numValidPixels = view.getUint8(size); size++;\n              } else if (headerByte === 1) {\n                block.numValidPixels = view.getUint16(size, true); size += 2;\n              } else if (headerByte === 0) {\n                block.numValidPixels = view.getUint32(size, true); size += 4;\n              } else {\n                throw \"Invalid valid pixel count type\";\n              }\n            }\n          }\n          fp += size;\n\n          if (block.encoding === 3) {\n            continue;\n          }\n\n          var arrayBuf, store8;\n          if (block.encoding === 0) {\n            var numPixels = (data.pixels.numBytes - 1) / 4;\n            if (numPixels !== Math.floor(numPixels)) {\n              throw \"uncompressed block has invalid length\";\n            }\n            arrayBuf = new ArrayBuffer(numPixels * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, numPixels * 4));\n            var rawData = new Float32Array(arrayBuf);\n            block.rawData = rawData;\n            fp += numPixels * 4;\n          } else if (block.encoding === 1) {\n            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);\n            var dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, dataBytes));\n            block.stuffedData = new Uint32Array(arrayBuf);\n            fp += dataBytes;\n          }\n        }\n      }\n      data.eofOffset = fp;\n      return data;\n    };\n\n    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {\n      var bitMask = (1 << bitsPerPixel) - 1;\n      var i = 0, o;\n      var bitsLeft = 0;\n      var n, buffer;\n      var nmax = Math.ceil((maxValue - offset) / scale);\n      // get rid of trailing bytes that are already part of next block\n      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n      src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n      for (o = 0; o < numPixels; o++) {\n        if (bitsLeft === 0) {\n          buffer = src[i++];\n          bitsLeft = 32;\n        }\n        if (bitsLeft >= bitsPerPixel) {\n          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n          bitsLeft -= bitsPerPixel;\n        } else {\n          var missingBits = (bitsPerPixel - bitsLeft);\n          n = ((buffer & bitMask) << missingBits) & bitMask;\n          buffer = src[i++];\n          bitsLeft = 32 - missingBits;\n          n += (buffer >>> bitsLeft);\n        }\n        //pixel values may exceed max due to quantization\n        dest[o] = n < nmax ? offset + n * scale : maxValue;\n      }\n      return dest;\n    };\n\n    return CntZImage;\n  })();\n\n  //version 2. Supports 2.1, 2.2, 2.3\n  var Lerc2Decode = (function() {\n    \"use strict\";\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof, following LercDecode.\n\n    /*****************************************\n    * private static class bitsutffer used by Lerc2Decode\n    *******************************************/\n    var BitStuffer = {\n      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.\n      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.\n      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits, nmax;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            dest[o] = lutArr[n];//offset + lutArr[n] * scale;\n          }\n        }\n        else {\n          nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n      },\n\n      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;\n        var buffer;\n        var dest = [];\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);//1st one\n        return dest;\n      },\n\n      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            dest[o] = lutArr[n];\n          }\n        }\n        else {\n          var nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              //no unsigned left shift\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n        return dest;\n      },\n\n      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;\n        var buffer;\n        var dest = [];\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);\n        return dest;\n      },\n\n      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          }\n          else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          dest[o] = n;\n        }\n        return dest;\n      },\n\n      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        //micro-optimizations\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          dest[o] = n;\n        }\n        return dest;\n      }\n    };\n\n    /*****************************************\n    *private static class used by Lerc2Decode\n    ******************************************/\n    var Lerc2Helpers = {\n      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant\n      computeChecksumFletcher32: function(input) {\n\n        var sum1 = 0xffff, sum2 = 0xffff;\n        var len = input.length;\n        var words = Math.floor(len / 2);\n        var i = 0;\n        while (words) {\n          var tlen = (words >= 359) ? 359 : words;\n          words -= tlen;\n          do {\n            sum1 += (input[i++] << 8);\n            sum2 += sum1 += input[i++];\n          } while (--tlen);\n\n          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n        }\n\n        // add the straggler byte if it exists\n        if (len & 1) {\n          sum2 += sum1 += (input[i] << 8);\n        }\n        // second reduction step to reduce sums to 16 bits\n        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n\n        return (sum2 << 16 | sum1) >>> 0;\n      },\n\n      readHeaderInfo: function(input, data) {\n        var ptr = data.ptr;\n        var fileIdView = new Uint8Array(input, ptr, 6);\n        var headerInfo = {};\n        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n        if (headerInfo.fileIdentifierString.lastIndexOf(\"Lerc2\", 0) !== 0) {\n          throw \"Unexpected file identifier string (expect Lerc2 ): \" + headerInfo.fileIdentifierString;\n        }\n        ptr += 6;\n        var view = new DataView(input, ptr, 8);\n        var fileVersion = view.getInt32(0, true);\n        headerInfo.fileVersion = fileVersion;\n        ptr += 4;\n        if (fileVersion >= 3) {\n          headerInfo.checksum = view.getUint32(4, true); //nrows\n          ptr += 4;\n        }\n\n        //keys start from here\n        view = new DataView(input, ptr, 12);\n        headerInfo.height = view.getUint32(0, true); //nrows\n        headerInfo.width = view.getUint32(4, true); //ncols\n        ptr += 8;\n        if (fileVersion >= 4) {\n          headerInfo.numDims = view.getUint32(8, true);\n          ptr += 4;\n        }\n        else {\n          headerInfo.numDims = 1;\n        }\n\n        view = new DataView(input, ptr, 40);\n        headerInfo.numValidPixel = view.getUint32(0, true);\n        headerInfo.microBlockSize = view.getInt32(4, true);\n        headerInfo.blobSize = view.getInt32(8, true);\n        headerInfo.imageType = view.getInt32(12, true);\n\n        headerInfo.maxZError = view.getFloat64(16, true);\n        headerInfo.zMin = view.getFloat64(24, true);\n        headerInfo.zMax = view.getFloat64(32, true);\n        ptr += 40;\n        data.headerInfo = headerInfo;\n        data.ptr = ptr;\n\n        var checksum, keyLength;\n        if (fileVersion >= 3) {\n          keyLength = fileVersion >= 4 ? 52 : 48;\n          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));\n          if (checksum !== headerInfo.checksum) {\n            throw \"Checksum failed.\";\n          }\n        }\n        return true;\n      },\n\n      checkMinMaxRanges: function(input, data) {\n        var headerInfo = data.headerInfo;\n        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);\n        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);\n        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);\n        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);\n        data.ptr += (2 * rangeBytes);\n        var i, equal = true;\n        for (i = 0; i < headerInfo.numDims; i++) {\n          if (minValues[i] !== maxValues[i]) {\n            equal = false;\n            break;\n          }\n        }\n        headerInfo.minValues = minValues;\n        headerInfo.maxValues = maxValues;\n        return equal;\n      },\n\n      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {\n        var rawData;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        return rawData;\n      },\n\n      readMask: function(input, data) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var numValidPixel = headerInfo.numValidPixel;\n\n        var view = new DataView(input, ptr, 4);\n        var mask = {};\n        mask.numBytes = view.getUint32(0, true);\n        ptr += 4;\n\n        // Mask Data\n        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {\n          throw (\"invalid mask\");\n        }\n        var bitset, resultMask;\n        if (numValidPixel === 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          mask.bitset = bitset;\n          resultMask = new Uint8Array(numPixels);\n          data.pixels.resultMask = resultMask;\n          ptr += mask.numBytes;\n        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {\n        else if (mask.numBytes > 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          view = new DataView(input, ptr, mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0, val = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n\n          resultMask = new Uint8Array(numPixels);\n          var mb = 0, k = 0;\n\n          for (k = 0; k < numPixels; k++) {\n            if (k & 7) {\n              mb = bitset[k >> 3];\n              mb <<= k & 7;\n            }\n            else {\n              mb = bitset[k >> 3];\n            }\n            if (mb & 128) {\n              resultMask[k] = 1;\n            }\n          }\n          data.pixels.resultMask = resultMask;\n\n          mask.bitset = bitset;\n          ptr += mask.numBytes;\n        }\n        data.ptr = ptr;\n        data.mask = mask;\n        return true;\n      },\n\n      readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var imageType = headerInfo.imageType;\n        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;\n        //data.pixels.numBytes = numBytes;\n        var rawData;\n        var mask = data.pixels.resultMask;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        if (rawData.length === numPixels * numDims) {\n          if (useBSQForOutputDim) {\n            data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);\n          }\n          else {\n            data.pixels.resultPixels = rawData;\n          }\n        }\n        else  //mask\n        {\n          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);\n          var z = 0, k = 0, i = 0, nStart = 0;\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k;\n                  for (i = 0; i < numDims; i++, nStart+=numPixels) {\n                    data.pixels.resultPixels[nStart] = rawData[z++];\n                  }\n                }\n              }\n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n                  for (i = 0; i < numDims; i++) {\n                    data.pixels.resultPixels[nStart + i] = rawData[z++];\n                  }\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                data.pixels.resultPixels[k] = rawData[z++];\n              }\n            }\n          }\n        }\n        ptr += numBytes;\n        data.ptr = ptr;       //return data;\n        return true;\n      },\n\n      readHuffmanTree: function(input, data) {\n        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n        * reading code table\n        *************************/\n        var view = new DataView(input, data.ptr, 16);\n        data.ptr += 16;\n        var version = view.getInt32(0, true);\n        if (version < 2) {\n          throw \"unsupported Huffman version\";\n        }\n        var size = view.getInt32(4, true);\n        var i0 = view.getInt32(8, true);\n        var i1 = view.getInt32(12, true);\n        if (i0 >= i1) {\n          return false;\n        }\n        var blockDataBuffer = new Uint32Array(i1 - i0);\n        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);\n        var codeTable = []; //size\n        var i, j, k, len;\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };\n        }\n\n        var dataBytes = input.byteLength - data.ptr;\n        var dataWords = Math.ceil(dataBytes / 4);\n        var arrayBuf = new ArrayBuffer(dataWords * 4);\n        var store8 = new Uint8Array(arrayBuf);\n        store8.set(new Uint8Array(input, data.ptr, dataBytes));\n        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4\n        var bitPos = 0, word, srcPtr = 0;\n        word = stuffedData[0];\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            codeTable[j].second = (word << bitPos) >>> (32 - len);\n\n            if (32 - bitPos >= len) {\n              bitPos += len;\n              if (bitPos === 32) {\n                bitPos = 0;\n                srcPtr++;\n                word = stuffedData[srcPtr];\n              }\n            }\n            else {\n              bitPos += len - 32;\n              srcPtr++;\n              word = stuffedData[srcPtr];\n              codeTable[j].second |= word >>> (32 - bitPos);\n            }\n          }\n        }\n\n        //finished reading code table\n\n        /* ************************\n        * building lut\n        *************************/\n        var numBitsLUT = 0, numBitsLUTQick = 0;\n        var tree = new TreeNode();\n        for (i = 0; i < codeTable.length; i++) {\n          if (codeTable[i] !== undefined) {\n            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);\n          }\n        }\n        if (numBitsLUT >= BITS_MAX) {\n          numBitsLUTQick = BITS_MAX;\n        }\n        else {\n          numBitsLUTQick = numBitsLUT;\n        }\n        // for debugging purpose\n        // if (numBitsLUT >= 30) {\n        //   console.log(\"WARning, large NUM LUT BITS IS \" + numBitsLUT);\n        // }\n        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            entry = [len, j];\n            if (len <= numBitsLUTQick) {\n              code = codeTable[j].second << (numBitsLUTQick - len);\n              numEntries = 1 << (numBitsLUTQick - len);\n              for (k = 0; k < numEntries; k++) {\n                decodeLut[code | k] = entry;\n              }\n            }\n            else {\n              //build tree\n              code = codeTable[j].second;\n              node = tree;\n              for (jj = len - 1; jj >= 0; jj--) {\n                currentBit = code >>> jj & 1; //no left shift as length could be 30,31\n                if (currentBit) {\n                  if (!node.right) {\n                    node.right = new TreeNode();\n                  }\n                  node = node.right;\n                }\n                else {\n                  if (!node.left) {\n                    node.left = new TreeNode();\n                  }\n                  node = node.left;\n                }\n                if (jj === 0 && !node.val) {\n                  node.val = entry[1];\n                }\n              }\n            }\n          }\n        }\n        return {\n          decodeLut: decodeLut,\n          numBitsLUTQick: numBitsLUTQick,\n          numBitsLUT: numBitsLUT,\n          tree: tree,\n          stuffedData: stuffedData,\n          srcPtr: srcPtr,\n          bitPos: bitPos\n        };\n      },\n\n      readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var height = data.headerInfo.height;\n        var width = data.headerInfo.width;\n        var numPixels = width * height;\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n        * reading huffman structure info\n        *************************/\n        var huffmanInfo = this.readHuffmanTree(input, data);\n        var decodeLut = huffmanInfo.decodeLut;\n        var tree = huffmanInfo.tree;\n        //stuffedData includes huffman headers\n        var stuffedData = huffmanInfo.stuffedData;\n        var srcPtr = huffmanInfo.srcPtr;\n        var bitPos = huffmanInfo.bitPos;\n        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;\n        var numBitsLUT = huffmanInfo.numBitsLUT;\n        var offset = data.headerInfo.imageType === 0 ? 128 : 0;\n        /*************************\n        *  decode\n        ***************************/\n        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;\n        var i, j, k, ii;\n        var prevVal = 0;\n        if (bitPos > 0) {\n          srcPtr++;\n          bitPos = 0;\n        }\n        var word = stuffedData[srcPtr];\n        var deltaEncode = data.encodeMode === 1;\n        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);\n        var resultPixels = resultPixelsAllDim;\n        var iDim;\n        // TODO: reevaluate the need to keep inlined decoding code as IE support is phasing out\n        if (numDims < 2 || deltaEncode) {\n          for (iDim = 0; iDim < numDims; iDim++) {\n            if (numDims > 1) {\n              //get the mem block of current dimension\n              resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);\n              prevVal = 0;\n            }\n            if (data.headerInfo.numValidPixel === width * height) { //all valid\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                  }\n                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n    \n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n    \n                  delta = val - offset;\n                  if (deltaEncode) {\n                    if (j > 0) {\n                      delta += prevVal;    // use overflow\n                    }\n                    else if (i > 0) {\n                      delta += resultPixels[k - width];\n                    }\n                    else {\n                      delta += prevVal;\n                    }\n                    delta &= 0xFF; //overflow\n                    resultPixels[k] = delta;//overflow\n                    prevVal = delta;\n                  }\n                  else {\n                    resultPixels[k] = delta;\n                  }\n                }\n              }\n            }\n            else { //not all valid, use mask\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  if (mask[k]) {\n                    val = 0;\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUTQick) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                    {\n                      val = decodeLut[valTmpQuick][1];\n                      bitPos += decodeLut[valTmpQuick][0];\n                    }\n                    else {\n                      valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                      if (32 - bitPos < numBitsLUT) {\n                        valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                        valTmpQuick = valTmp;// >>> deltaBits;\n                      }\n                      node = tree;\n                      for (ii = 0; ii < numBitsLUT; ii++) {\n                        currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                        node = currentBit ? node.right : node.left;\n                        if (!(node.left || node.right)) {\n                          val = node.val;\n                          bitPos = bitPos + ii + 1;\n                          break;\n                        }\n                      }\n                    }\n    \n                    if (bitPos >= 32) {\n                      bitPos -= 32;\n                      srcPtr++;\n                      word = stuffedData[srcPtr];\n                    }\n    \n                    delta = val - offset;\n                    if (deltaEncode) {\n                      if (j > 0 && mask[k - 1]) {\n                        delta += prevVal;    // use overflow\n                      }\n                      else if (i > 0 && mask[k - width]) {\n                        delta += resultPixels[k - width];\n                      }\n                      else {\n                        delta += prevVal;\n                      }\n    \n                      delta &= 0xFF; //overflow\n                      resultPixels[k] = delta;//overflow\n                      prevVal = delta;\n                    }\n                    else {\n                      resultPixels[k] = delta;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        else {\n          for (k = 0, i = 0; i < height; i++) {\n            for (j = 0; j < width; j++) {\n              k = i * width + j;\n              if (!mask || mask[k]) {\n                for (iDim = 0; iDim < numDims; iDim++, k+=numPixels) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;\n                  }\n                  if (decodeLut[valTmpQuick])\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n\n                  delta = val - offset;\n                  resultPixels[k] = delta;\n                }\n              }\n            }\n          }\n        }\n        data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);\n        data.pixels.resultPixels = resultPixelsAllDim;\n        //swap for BIP layout\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {\n        {\n          //bitstuff encoding is 3\n          var headerInfo = data.headerInfo;\n          var fileVersion = headerInfo.fileVersion;\n          //var block = {};\n          var blockPtr = 0;\n          var viewByteLength = ((input.byteLength - data.ptr) >= 5) ? 5 : (input.byteLength - data.ptr);\n          var view = new DataView(input, data.ptr, viewByteLength);\n          var headerByte = view.getUint8(0);\n          blockPtr++;\n          var bits67 = headerByte >> 6;\n          var n = (bits67 === 0) ? 4 : 3 - bits67;\n          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit\n          var numBits = headerByte & 31;\n          var numElements = 0;\n          if (n === 1) {\n            numElements = view.getUint8(blockPtr); blockPtr++;\n          } else if (n === 2) {\n            numElements = view.getUint16(blockPtr, true); blockPtr += 2;\n          } else if (n === 4) {\n            numElements = view.getUint32(blockPtr, true); blockPtr += 4;\n          } else {\n            throw \"Invalid valid pixel count type\";\n          }\n          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff\n          //offset = offset || 0;\n          var scale = 2 * headerInfo.maxZError;\n          var stuffedData, arrayBuf, store8, dataBytes, dataWords;\n          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;\n          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;\n          if (doLut) {\n            data.counter.lut++;\n            lutBytes = view.getUint8(blockPtr);\n            lutBitsPerElement = numBits;\n            blockPtr++;\n            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n\n            data.ptr += blockPtr;\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n\n            lutData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n\n            bitsPerPixel = 0;\n            while ((lutBytes - 1) >>> bitsPerPixel) {\n              bitsPerPixel++;\n            }\n            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n            stuffedData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n            if (fileVersion >= 3) {\n              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            else {\n              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            //lutArr.unshift(0);\n            if (fileVersion >= 3) {\n              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);\n              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n            else {\n              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n          }\n          else {\n            //console.debug(\"bitstuffer\");\n            data.counter.bitstuffer++;\n            bitsPerPixel = numBits;\n            data.ptr += blockPtr;\n            if (bitsPerPixel > 0) {\n              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n              dataWords = Math.ceil(dataBytes / 4);\n              arrayBuf = new ArrayBuffer(dataWords * 4);\n              store8 = new Uint8Array(arrayBuf);\n              store8.set(new Uint8Array(input, data.ptr, dataBytes));\n              stuffedData = new Uint32Array(arrayBuf);\n              data.ptr += dataBytes;\n              if (fileVersion >= 3) {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n              else {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n            }\n          }\n        }\n\n      },\n\n      readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var width = headerInfo.width;\n        var height = headerInfo.height;\n        var numPixels = width * height;\n        var microBlockSize = headerInfo.microBlockSize;\n        var imageType = headerInfo.imageType;\n        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);\n        var numBlocksX = Math.ceil(width / microBlockSize);\n        var numBlocksY = Math.ceil(height / microBlockSize);\n        data.pixels.numBlocksY = numBlocksY;\n        data.pixels.numBlocksX = numBlocksX;\n        data.pixels.ptr = 0;\n        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;\n        var view, block, arrayBuf, store8, rawData;\n        var blockEncoding;\n        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);\n        var lastBlockHeight = (height % microBlockSize) || microBlockSize;\n        var lastBlockWidth = (width % microBlockSize) || microBlockSize;\n        var offsetType, offset;\n        var numDims = headerInfo.numDims, iDim;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        var fileVersion = headerInfo.fileVersion;\n        var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;\n        var isDiffEncoding;\n        var zMax = headerInfo.zMax;\n        //var resultPixelsAllDim = resultPixels;\n        var resultPixelsPrevDim;\n        for (blockY = 0; blockY < numBlocksY; blockY++) {\n          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;\n          for (blockX = 0; blockX < numBlocksX; blockX++) {\n            //console.debug(\"y\" + blockY + \" x\" + blockX);\n            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;\n\n            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n            outStride = width - thisBlockWidth;\n\n            for (iDim = 0; iDim < numDims; iDim++) {\n              if (numDims > 1) {\n                resultPixelsPrevDim = resultPixels;\n                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);\n                zMax = headerInfo.maxValues[iDim];\n              } else {\n                resultPixelsPrevDim = null;\n              }\n              bytesLeft = input.byteLength - data.ptr;\n              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));\n              block = {};\n              blockPtr = 0;\n              headerByte = view.getUint8(0);\n              blockPtr++;\n              isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;\n              bits67 = (headerByte >> 6) & 0xFF;\n              testCode = (headerByte >> 2) & fileVersionCheckNum;    // use bits 2345 for integrity check\n              if (testCode !== (((blockX * microBlockSize) >> 3) & fileVersionCheckNum)) {\n                throw \"integrity issue\";\n              }\n\n              if (isDiffEncoding && iDim === 0) {\n                throw \"integrity issue\";\n              }\n\n              blockEncoding = headerByte & 3;\n              if (blockEncoding > 3) {\n                data.ptr += blockPtr;\n                throw \"Invalid block encoding (\" + blockEncoding + \")\";\n              }\n              else if (blockEncoding === 2) { //constant 0\n                if (isDiffEncoding) {\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        }\n                        outPtr++;\n                      }\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        outPtr++;\n                      }\n                    }\n                  }\n                }\n                data.counter.constant++;\n                data.ptr += blockPtr;\n                continue;\n              }\n              else if (blockEncoding === 0) {  //uncompressed\n                if (isDiffEncoding) {\n                  // doesn't make sense, should not happen\n                  throw \"integrity issue\";\n                }\n                data.counter.uncompressed++;\n                data.ptr += blockPtr;\n                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;\n                bytesleft = input.byteLength - data.ptr;\n                numBytes = numBytes < bytesleft ? numBytes : bytesleft;\n                //bit alignment\n                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));\n                store8 = new Uint8Array(arrayBuf);\n                store8.set(new Uint8Array(input, data.ptr, numBytes));\n                rawData = new OutPixelTypeArray(arrayBuf);\n                z = 0;\n                if (mask) {\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      if (mask[outPtr]) {\n                        resultPixels[outPtr] = rawData[z++];\n                      }\n                      outPtr++;\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                else {//all valid\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      resultPixels[outPtr++] = rawData[z++];\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                data.ptr += z * dataTypeSize;\n              }\n              else { //1 or 3\n                offsetType = Lerc2Helpers.getDataTypeUsed((isDiffEncoding && imageType < 6) ? 4 : imageType, bits67);\n                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);\n                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);\n                if (blockEncoding === 3) //constant offset value\n                {\n                  data.ptr += blockPtr;\n                  data.counter.constantoffset++;\n                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.\n                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n                else { //bitstuff encoding is 3\n                  data.ptr += blockPtr;\n                  //heavy lifting\n                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);\n                  blockPtr = 0;\n                  // duplicate code to favor performance, diff encoding is for multidimension only\n                  if (isDiffEncoding) {\n                    if (mask) {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          if (mask[outPtr]) {\n                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          }\n                          outPtr++;\n                        }\n                        outPtr += outStride;\n                      }\n                    }\n                    else {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          outPtr++;\n                        }\n                        outPtr += outStride;\n                      }\n                    }\n                  }\n                  else if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        //swap for BIP: it's always easier for clients to handle BSQ so we keep existing logic and introduce a swap here to minimze changes\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      /*****************\n      *  private methods (helper methods)\n      *****************/\n\n      formatFileInfo: function(data) {\n        return {\n          \"fileIdentifierString\": data.headerInfo.fileIdentifierString,\n          \"fileVersion\": data.headerInfo.fileVersion,\n          \"imageType\": data.headerInfo.imageType,\n          \"height\": data.headerInfo.height,\n          \"width\": data.headerInfo.width,\n          \"numValidPixel\": data.headerInfo.numValidPixel,\n          \"microBlockSize\": data.headerInfo.microBlockSize,\n          \"blobSize\": data.headerInfo.blobSize,\n          \"maxZError\": data.headerInfo.maxZError,\n          \"pixelType\": Lerc2Helpers.getPixelType(data.headerInfo.imageType),\n          \"eofOffset\": data.eofOffset,\n          \"mask\": data.mask ? {\n            \"numBytes\": data.mask.numBytes\n          } : null,\n          \"pixels\": {\n            \"numBlocksX\": data.pixels.numBlocksX,\n            \"numBlocksY\": data.pixels.numBlocksY,\n            //\"numBytes\": data.pixels.numBytes,\n            \"maxValue\": data.headerInfo.zMax,\n            \"minValue\": data.headerInfo.zMin,\n            \"noDataValue\": data.noDataValue\n          }\n        };\n      },\n\n      constructConstantSurface: function(data, useBSQForOutputDim) {\n        var val = data.headerInfo.zMax;\n        var valMin = data.headerInfo.zMin;\n        var maxValues = data.headerInfo.maxValues;\n        var numDims = data.headerInfo.numDims;\n        var numPixels = data.headerInfo.height * data.headerInfo.width;\n        var i = 0, k = 0, nStart = 0;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        if (mask) {\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n                for (k = 0; k < numPixels; k++) {\n                  if (mask[k]) {\n                    resultPixels[nStart + k] = val;\n                  }\n                }\n              }  \n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n                  for (i = 0; i < numDims; i++) {\n                    resultPixels[nStart + numDims] = maxValues[i];\n                  }\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                resultPixels[k] = val;\n              }\n            }\n          }\n        }\n        else {\n          if (numDims > 1 && valMin !== val) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n                for (k = 0; k < numPixels; k++) {\n                  resultPixels[nStart + k] = val;\n                }\n              }\n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                nStart = k * numDims;\n                for (i = 0; i < numDims; i++) {\n                  resultPixels[nStart + i] = maxValues[i];\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels * numDims; k++) {\n              resultPixels[k] = val;\n            }\n          }\n        }\n        return;\n      },\n\n      getDataTypeArray: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = Int8Array;\n            break;\n          case 1: //byte\n            tp = Uint8Array;\n            break;\n          case 2: //short\n            tp = Int16Array;\n            break;\n          case 3: //ushort\n            tp = Uint16Array;\n            break;\n          case 4:\n            tp = Int32Array;\n            break;\n          case 5:\n            tp = Uint32Array;\n            break;\n          case 6:\n            tp = Float32Array;\n            break;\n          case 7:\n            tp = Float64Array;\n            break;\n          default:\n            tp = Float32Array;\n        }\n        return tp;\n      },\n\n      getPixelType: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = \"S8\";\n            break;\n          case 1: //byte\n            tp = \"U8\";\n            break;\n          case 2: //short\n            tp = \"S16\";\n            break;\n          case 3: //ushort\n            tp = \"U16\";\n            break;\n          case 4:\n            tp = \"S32\";\n            break;\n          case 5:\n            tp = \"U32\";\n            break;\n          case 6:\n            tp = \"F32\";\n            break;\n          case 7:\n            tp = \"F64\";\n            break;\n          default:\n            tp = \"F32\";\n        }\n        return tp;\n      },\n\n      isValidPixelValue: function(t, val) {\n        if (val == null) {\n          return false;\n        }\n        var isValid;\n        switch (t) {\n          case 0: //char\n            isValid = val >= -128 && val <= 127;\n            break;\n          case 1: //byte  (unsigned char)\n            isValid = val >= 0 && val <= 255;\n            break;\n          case 2: //short\n            isValid = val >= -32768 && val <= 32767;\n            break;\n          case 3: //ushort\n            isValid = val >= 0 && val <= 65536;\n            break;\n          case 4: //int 32\n            isValid = val >= -2147483648 && val <= 2147483647;\n            break;\n          case 5: //uinit 32\n            isValid = val >= 0 && val <= 4294967296;\n            break;\n          case 6:\n            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;\n            break;\n          case 7:\n            isValid = val >= -1.7976931348623157e+308 && val <= 1.7976931348623157e+308;\n            break;\n          default:\n            isValid = false;\n        }\n        return isValid;\n      },\n\n      getDataTypeSize: function(t) {\n        var s = 0;\n        switch (t) {\n          case 0: //ubyte\n          case 1: //byte\n            s = 1;\n            break;\n          case 2: //short\n          case 3: //ushort\n            s = 2;\n            break;\n          case 4:\n          case 5:\n          case 6:\n            s = 4;\n            break;\n          case 7:\n            s = 8;\n            break;\n          default:\n            s = t;\n        }\n        return s;\n      },\n\n      getDataTypeUsed: function(dt, tc) {\n        var t = dt;\n        switch (dt) {\n          case 2: //short\n          case 4: //long\n            t = dt - tc;\n            break;\n          case 3: //ushort\n          case 5: //ulong\n            t = dt - 2 * tc;\n            break;\n          case 6: //float\n            if (0 === tc) {\n              t = dt;\n            }\n            else if (1 === tc) {\n              t = 2;\n            }\n            else {\n              t = 1;//byte\n            }\n            break;\n          case 7: //double\n            if (0 === tc) {\n              t = dt;\n            }\n            else {\n              t = dt - 2 * tc + 1;\n            }\n            break;\n          default:\n            t = dt;\n            break;\n        }\n        return t;\n      },\n\n      getOnePixel: function(block, blockPtr, offsetType, view) {\n        var temp = 0;\n        switch (offsetType) {\n          case 0: //char\n            temp = view.getInt8(blockPtr);\n            break;\n          case 1: //byte\n            temp = view.getUint8(blockPtr);\n            break;\n          case 2:\n            temp = view.getInt16(blockPtr, true);\n            break;\n          case 3:\n            temp = view.getUint16(blockPtr, true);\n            break;\n          case 4:\n            temp = view.getInt32(blockPtr, true);\n            break;\n          case 5:\n            temp = view.getUInt32(blockPtr, true);\n            break;\n          case 6:\n            temp = view.getFloat32(blockPtr, true);\n            break;\n          case 7:\n            temp = view.getFloat64(blockPtr, true);\n            break;\n          default:\n            throw (\"the decoder does not understand this pixel type\");\n        }\n        return temp;\n      },\n\n      swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {\n        var i = 0, j = 0, iDim = 0, temp = 0, swap = pixels;\n        if (numDims > 1) {\n          swap = new OutPixelTypeArray(numPixels * numDims);\n          if (inputIsBIP) {\n            for (i=0; i<numPixels; i++) {\n              temp = i;\n              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[temp] = pixels[j++];\n              }\n            }  \n          }\n          else {\n            for (i=0; i<numPixels; i++) {\n              temp = i;\n              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[j++] = pixels[temp];\n              }\n            }\n          }\n        }\n        return swap;\n      }\n    };\n\n    /***************************************************\n    *private class for a tree node. Huffman code is in Lerc2Helpers\n    ****************************************************/\n    var TreeNode = function(val, left, right) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    };\n\n    var Lerc2Decode = {\n      /*\n      * ********removed options compared to LERC1. We can bring some of them back if needed.\n       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type\n       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.\n       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.\n       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,\n       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.\n       *       We can add it back later if their's a clear requirement.\n       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)\n       * removed computeUsedBitDepths.\n       *\n       *\n       * response changes compared to LERC1\n       * 1. encodedMaskData is not available\n       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)\n       * 3. maskData is always available\n      */\n      /*****************\n      *  public properties\n      ******************/\n      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable\n\n      /*****************\n      *  public methods\n      *****************/\n\n      /**\n       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.\n       *\n       * @param {ArrayBuffer} input The LERC input byte stream\n       * @param {object} [options] options Decoding options\n       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position\n       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process\n       * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n       */\n      decode: function(/*byte array*/ input, /*object*/ options) {\n        //currently there's a bug in the sparse array, so please do not set to false\n        options = options || {};\n        var noDataValue = options.noDataValue;\n\n        //initialize\n        var i = 0, data = {};\n        data.ptr = options.inputOffset || 0;\n        data.pixels = {};\n\n        // File header\n        if (!Lerc2Helpers.readHeaderInfo(input, data)) {\n          return;\n        }\n\n        var headerInfo = data.headerInfo;\n        var fileVersion = headerInfo.fileVersion;\n        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);\n\n        // version check\n        if (fileVersion > 5) {\n          throw \"unsupported lerc version 2.\" + fileVersion;\n        }\n\n        // Mask Header\n        Lerc2Helpers.readMask(input, data);\n        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {\n          data.pixels.resultMask = options.maskData;\n        }\n\n        var numPixels = headerInfo.width * headerInfo.height;\n        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);\n\n        data.counter = {\n          onesweep: 0,\n          uncompressed: 0,\n          lut: 0,\n          bitstuffer: 0,\n          constant: 0,\n          constantoffset: 0\n        };\n        var useBSQForOutputDim = !options.returnPixelInterleavedDims;\n        if (headerInfo.numValidPixel !== 0) {\n          //not tested\n          if (headerInfo.zMax === headerInfo.zMin) //constant surface\n          {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          }\n          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          }\n          else {\n            var view = new DataView(input, data.ptr, 2);\n            var bReadDataOneSweep = view.getUint8(0);\n            data.ptr++;\n            if (bReadDataOneSweep) {\n              //console.debug(\"OneSweep\");\n              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);\n            }\n            else {\n              //lerc2.1: //bitstuffing + lut\n              //lerc2.2: //bitstuffing + lut + huffman\n              //lerc2.3: new bitstuffer\n              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {\n                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman\n                var flagHuffman = view.getUint8(1);\n                data.ptr++;\n                data.encodeMode = flagHuffman;\n                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {\n                  throw \"Invalid Huffman flag \" + flagHuffman;\n                }\n                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman\n                  //console.log(\"Huffman\");\n                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n                else {\n                  //console.log(\"Tiles\");\n                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n              }\n              else { //lerc2.x non-8 bit data\n                //console.log(\"Tiles\");\n                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n              }\n            }\n          }\n        }\n\n        data.eofOffset = data.ptr;\n        var diff;\n        if (options.inputOffset) {\n          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect eof: dataptr \" + data.ptr + \" offset \" + options.inputOffset + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;\n          }\n        }\n        else {\n          diff = data.headerInfo.blobSize - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect first band eof: dataptr \" + data.ptr + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = data.headerInfo.blobSize;\n          }\n        }\n\n        var result = {\n          width: headerInfo.width,\n          height: headerInfo.height,\n          pixelData: data.pixels.resultPixels,\n          minValue: headerInfo.zMin,\n          maxValue: headerInfo.zMax,\n          validPixelCount: headerInfo.numValidPixel,\n          dimCount: headerInfo.numDims,\n          dimStats: {\n            minValues: headerInfo.minValues,\n            maxValues: headerInfo.maxValues\n          },\n          maskData: data.pixels.resultMask\n          //noDataValue: noDataValue\n        };\n\n        //we should remove this if there's no existing client\n        //optional noDataValue processing, it's user's responsiblity\n        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {\n          var mask = data.pixels.resultMask;\n          for (i = 0; i < numPixels; i++) {\n            if (!mask[i]) {\n              result.pixelData[i] = noDataValue;\n            }\n          }\n          result.noDataValue = noDataValue;\n        }\n        data.noDataValue = noDataValue;\n        if (options.returnFileInfo) {\n          result.fileInfo = Lerc2Helpers.formatFileInfo(data);\n        }\n        return result;\n      },\n\n      getBandCount: function(/*byte array*/ input) {\n        var count = 0;\n        var i = 0;\n        var temp = {};\n        temp.ptr = 0;\n        temp.pixels = {};\n        while (i < input.byteLength - 58) {\n          Lerc2Helpers.readHeaderInfo(input, temp);\n          i += temp.headerInfo.blobSize;\n          count++;\n          temp.ptr = i;\n        }\n        return count;\n      }\n    };\n\n    return Lerc2Decode;\n  })();\n\n  var isPlatformLittleEndian = (function() {\n    var a = new ArrayBuffer(4);\n    var b = new Uint8Array(a);\n    var c = new Uint32Array(a);\n    c[0] = 1;\n    return b[0] === 1;\n  })();\n\n  var Lerc = {\n    /************wrapper**********************************************/\n    /**\n     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.\n     *\n     * @alias module:Lerc\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] The decoding options below are optional.\n     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.\n     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.\n     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.\n     * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n     * @returns {{width, height, pixels, pixelType, mask, statistics}}\n       * @property {number} width Width of decoded image.\n       * @property {number} height Height of decoded image.\n       * @property {array} pixels [band1, band2, â¦] Each band is a typed array of width*height.\n       * @property {string} pixelType The type of pixels represented in the output.\n       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.\n       * @property {array} statistics [statistics_band1, statistics_band2, â¦] Each element is a statistics object representing min and max values\n    **/\n    decode: function(encodedData, options) {\n      if (!isPlatformLittleEndian) {\n        throw \"Big endian system is not supported.\";\n      }\n      options = options || {};\n      var inputOffset = options.inputOffset || 0;\n      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);\n      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      var lerc, majorVersion;\n      if (fileIdentifierString.trim() === \"CntZImage\") {\n        lerc = LercDecode;\n        majorVersion = 1;\n      }\n      else if (fileIdentifierString.substring(0, 5) === \"Lerc2\") {\n        lerc = Lerc2Decode;\n        majorVersion = 2;\n      }\n      else {\n        throw \"Unexpected file identifier string: \" + fileIdentifierString;\n      }\n\n      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;\n      var decodedPixelBlock = {\n        width: 0,\n        height: 0,\n        pixels: [],\n        pixelType: options.pixelType,\n        mask: null,\n        statistics: []\n      };\n      var uniqueBandMaskCount = 0;\n\n      while (inputOffset < eof) {\n        var result = lerc.decode(encodedData, {\n          inputOffset: inputOffset,//for both lerc1 and lerc2\n          encodedMaskData: encodedMaskData,//lerc1 only\n          maskData: maskData,//lerc2 only\n          returnMask: iPlane === 0 ? true : false,//lerc1 only\n          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only\n          returnFileInfo: true,//for both lerc1 and lerc2\n          returnPixelInterleavedDims: options.returnPixelInterleavedDims,//for ndim lerc2 only\n          pixelType: options.pixelType || null,//lerc1 only\n          noDataValue: options.noDataValue || null//lerc1 only\n        });\n\n        inputOffset = result.fileInfo.eofOffset;\n        maskData = result.maskData;//lerc2\n        if (iPlane === 0) {\n          encodedMaskData = result.encodedMaskData;//lerc1\n          decodedPixelBlock.width = result.width;\n          decodedPixelBlock.height = result.height;\n          decodedPixelBlock.dimCount = result.dimCount || 1;\n          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;\n          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;\n          decodedPixelBlock.mask = maskData;\n        }\n        if (majorVersion > 1) {\n          if (maskData) {\n            bandMasks.push(maskData);\n          }\n          if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {\n            uniqueBandMaskCount++;\n          }\n        }\n\n        iPlane++;\n        decodedPixelBlock.pixels.push(result.pixelData);\n        decodedPixelBlock.statistics.push({\n          minValue: result.minValue,\n          maxValue: result.maxValue,\n          noDataValue: result.noDataValue,\n          dimStats: result.dimStats\n        });\n      }\n      var i, j, numPixels;\n      if (majorVersion > 1 && uniqueBandMaskCount > 1) {\n        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;\n        decodedPixelBlock.bandMasks = bandMasks;\n        maskData = new Uint8Array(numPixels);\n        maskData.set(bandMasks[0]);\n        for (i = 1; i < bandMasks.length; i++) {\n          bandMask = bandMasks[i];\n          for (j = 0; j < numPixels; j++) {\n            maskData[j] = maskData[j] & bandMask[j];\n          }\n        }\n        decodedPixelBlock.maskData = maskData;\n      }\n\n      return decodedPixelBlock;\n    }\n  };\n\n  if (true) {/* jshint ignore:line */\n    //amd loaders such as dojo and requireJS\n    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Lerc; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));/* jshint ignore:line */\n  }\n  else {}\n\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVyYy9MZXJjRGVjb2RlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZGQUE2Rjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRCw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRCw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFLGFBQWEsY0FBYztBQUFBLGtHQUFDLENBQUM7QUFDNUM7QUFDQSxPQUFPLEVBUUo7O0FBRUgsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvbGVyYy9MZXJjRGVjb2RlLmpzPzc1NTgiXSwic291cmNlc0NvbnRlbnQiOlsi77u/LyoganNoaW50IGZvcmluOiBmYWxzZSwgYml0d2lzZTogZmFsc2UgKi9cbi8qXG5Db3B5cmlnaHQgMjAxNS0yMDIxIEVzcmlcblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuQSBjb3B5IG9mIHRoZSBsaWNlbnNlIGFuZCBhZGRpdGlvbmFsIG5vdGljZXMgYXJlIGxvY2F0ZWQgd2l0aCB0aGVcbnNvdXJjZSBkaXN0cmlidXRpb24gYXQ6XG5cbmh0dHA6Ly9naXRodWIuY29tL0VzcmkvbGVyYy9cblxuQ29udHJpYnV0b3JzOiAgSm9oYW5uZXMgU2NobWlkLCAoTEVSQyB2MSlcbiAgICAgICAgICAgICAgIENoYXlhbmlrYSBLaGF0dWEsIChMRVJDIHYxKVxuICAgICAgICAgICAgICAgV2VueHVlIEp1IChMRVJDIHYxLCB2Mi54KVxuKi9cblxuLyogQ29weXJpZ2h0IDIwMTUtMjAyMSBFc3JpLiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAgQHByZXNlcnZlICovXG5cbi8qKlxuICogYSBtb2R1bGUgZm9yIGRlY29kaW5nIExFUkMgYmxvYnNcbiAqIEBtb2R1bGUgTGVyY1xuICovXG4oZnVuY3Rpb24oKSB7XG4gIC8vdGhpcyBkZWNvZGVyIHN1cHBvcnRzIGFsbCBsZXJjIHZlcnNpb25zLCBlYWNoIHZlcnNpb24gaGFzIGl0cyBvd24gY2xhc3MgKExlcmNEZWNvZGUgYW5kIExlcmMyRGVjb2RlKS4gXG4gIC8vdGhlIGV4cG9ydGVkIG1vZHVsZSBoYW5kbGVzIGZvcm1hdCB2YXJpYXRpb24gYXV0b2FtdGljYWxseS5cblxuICAvL3RoZSBvcmlnaW5hbCBMZXJjRGVjb2RlIGZvciBWZXJzaW9uIDFcbiAgdmFyIExlcmNEZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBOb3RlOiBjdXJyZW50bHksIHRoaXMgbW9kdWxlIG9ubHkgaGFzIGFuIGltcGxlbWVudGF0aW9uIGZvciBkZWNvZGluZyBMRVJDIGRhdGEsIG5vdCBlbmNvZGluZy4gVGhlIG5hbWUgb2ZcbiAgICAvLyB0aGUgY2xhc3Mgd2FzIGNob3NlbiB0byBiZSBmdXR1cmUgcHJvb2YuXG5cbiAgICB2YXIgQ250WkltYWdlID0ge307XG5cbiAgICBDbnRaSW1hZ2UuZGVmYXVsdE5vRGF0YVZhbHVlID0gLTMuNDAyNzk5OTM4NzkwMTQ4NGUrMzg7IC8vIHNtYWxsZXN0IEZsb2F0MzIgdmFsdWVcblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIExFUkMgYnl0ZSBzdHJlYW0gYW5kIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBhbmQgc29tZSByZXF1aXJlZCBhbmQgb3B0aW9uYWxcbiAgICAgKiBpbmZvcm1hdGlvbiBhYm91dCBpdCwgc3VjaCBhcyB0aGUgaW1hZ2UncyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gaW5wdXQgVGhlIExFUkMgaW5wdXQgYnl0ZSBzdHJlYW1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIERlY29kaW5nIG9wdGlvbnMsIGNvbnRhaW5pbmcgYW55IG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAY29uZmlnIHtudW1iZXJ9IFtpbnB1dE9mZnNldCA9IDBdXG4gICAgICogICAgICAgIFNraXAgdGhlIGZpcnN0IGlucHV0T2Zmc2V0IGJ5dGVzIG9mIHRoZSBpbnB1dCBieXRlIHN0cmVhbS4gQSB2YWxpZCBMRVJDIGZpbGUgaXMgZXhwZWN0ZWQgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgKiBAY29uZmlnIHtVaW50OEFycmF5fSBbZW5jb2RlZE1hc2sgPSBudWxsXVxuICAgICAqICAgICAgICBJZiBzcGVjaWZpZWQsIHRoZSBkZWNvZGVyIHdpbGwgbm90IHJlYWQgbWFzayBpbmZvcm1hdGlvbiBmcm9tIHRoZSBpbnB1dCBhbmQgdXNlIHRoZSBzcGVjaWZpZWQgZW5jb2RlZFxuICAgICAqICAgICAgICBtYXNrIGRhdGEgaW5zdGVhZC4gTWFzayBoZWFkZXIvZGF0YSBtdXN0IG5vdCBiZSBwcmVzZW50IGluIHRoZSBMRVJDIGJ5dGUgc3RyZWFtIGluIHRoaXMgY2FzZS5cbiAgICAgKiBAY29uZmlnIHtudW1iZXJ9IFtub0RhdGFWYWx1ZSA9IExlcmNDb2RlLmRlZmF1bHROb0RhdGFWYWx1ZV1cbiAgICAgKiAgICAgICAgUGl4ZWwgdmFsdWUgdG8gdXNlIGZvciBtYXNrZWQgcGl4ZWxzLlxuICAgICAqIEBjb25maWcge0FycmF5QnVmZmVyVmlld3xBcnJheX0gW3BpeGVsVHlwZSA9IEZsb2F0MzJBcnJheV1cbiAgICAgKiAgICAgICAgVGhlIGRlc2lyZWQgdHlwZSBvZiB0aGUgcGl4ZWxEYXRhIGFycmF5IGluIHRoZSByZXR1cm4gdmFsdWUuIE5vdGUgdGhhdCBpdCBpcyB0aGUgY2FsbGVyJ3MgcmVzcG9uc2liaWxpdHkgdG9cbiAgICAgKiAgICAgICAgcHJvdmlkZSBhbiBhcHByb3ByaWF0ZSBub0RhdGFWYWx1ZSBpZiB0aGUgZGVmYXVsdCBwaXhlbFR5cGUgaXMgb3ZlcnJpZGRlbi5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbcmV0dXJuTWFzayA9IGZhbHNlXVxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgY29udGFpbiBhIG1hc2tEYXRhIHByb3BlcnR5IG9mIHR5cGUgVWludDhBcnJheSB3aGljaCBoYXMgb25lIGVsZW1lbnQgcGVyXG4gICAgICogICAgICAgIHBpeGVsLCB0aGUgdmFsdWUgb2Ygd2hpY2ggaXMgMSBvciAwIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoYXQgcGl4ZWwncyBkYXRhIGlzIHByZXNlbnQgb3IgbWFza2VkLiBJZiB0aGVcbiAgICAgKiAgICAgICAgaW5wdXQgTEVSQyBkYXRhIGRvZXMgbm90IGNvbnRhaW4gYSBtYXNrLCBtYXNrRGF0YSB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbcmV0dXJuRW5jb2RlZE1hc2sgPSBmYWxzZV1cbiAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGNvbnRhaW4gYSBlbmNvZGVkTWFza0RhdGEgcHJvcGVydHksIHdoaWNoIGNhbiBiZSBwYXNzZWQgaW50byBlbmNvZGUoKSBhc1xuICAgICAqICAgICAgICBlbmNvZGVkTWFzay5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbcmV0dXJuRmlsZUluZm8gPSBmYWxzZV1cbiAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgYSBmaWxlSW5mbyBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIG1ldGFkYXRhIG9idGFpbmVkIGZyb20gdGhlXG4gICAgICogICAgICAgIExFUkMgaGVhZGVycyBhbmQgdGhlIGRlY29kaW5nIHByb2Nlc3MuXG4gICAgICogQGNvbmZpZyB7Ym9vbGVhbn0gW2NvbXB1dGVVc2VkQml0RGVwdGhzID0gZmFsc2VdXG4gICAgICogICAgICAgIElmIHRydWUsIHRoZSBmaWxlSW5mbyBwcm9wZXJ0eSBpbiB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgY29udGFpbiB0aGUgc2V0IG9mIGFsbCBibG9jayBiaXQgZGVwdGhzXG4gICAgICogICAgICAgIGVuY291bnRlcmVkIGR1cmluZyBkZWNvZGluZy4gV2lsbCBvbmx5IGhhdmUgYW4gZWZmZWN0IGlmIHJldHVybkZpbGVJbmZvIG9wdGlvbiBpcyB0cnVlLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGgsIGhlaWdodCwgcGl4ZWxEYXRhLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIG5vRGF0YVZhbHVlLCBtYXNrRGF0YSwgZW5jb2RlZE1hc2tEYXRhLCBmaWxlSW5mb319XG4gICAgICovXG4gICAgQ250WkltYWdlLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIHNraXBNYXNrID0gb3B0aW9ucy5lbmNvZGVkTWFza0RhdGEgfHwgKG9wdGlvbnMuZW5jb2RlZE1hc2tEYXRhID09PSBudWxsKTtcbiAgICAgIHZhciBwYXJzZWREYXRhID0gcGFyc2UoaW5wdXQsIG9wdGlvbnMuaW5wdXRPZmZzZXQgfHwgMCwgc2tpcE1hc2spO1xuXG4gICAgICB2YXIgbm9EYXRhVmFsdWUgPSAob3B0aW9ucy5ub0RhdGFWYWx1ZSAhPT0gbnVsbCkgPyBvcHRpb25zLm5vRGF0YVZhbHVlIDogQ250WkltYWdlLmRlZmF1bHROb0RhdGFWYWx1ZTtcblxuICAgICAgdmFyIHVuY29tcHJlc3NlZERhdGEgPSB1bmNvbXByZXNzUGl4ZWxWYWx1ZXMocGFyc2VkRGF0YSwgb3B0aW9ucy5waXhlbFR5cGUgfHwgRmxvYXQzMkFycmF5LFxuICAgICAgICBvcHRpb25zLmVuY29kZWRNYXNrRGF0YSwgbm9EYXRhVmFsdWUsIG9wdGlvbnMucmV0dXJuTWFzayk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHdpZHRoOiBwYXJzZWREYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlZERhdGEuaGVpZ2h0LFxuICAgICAgICBwaXhlbERhdGE6IHVuY29tcHJlc3NlZERhdGEucmVzdWx0UGl4ZWxzLFxuICAgICAgICBtaW5WYWx1ZTogdW5jb21wcmVzc2VkRGF0YS5taW5WYWx1ZSxcbiAgICAgICAgbWF4VmFsdWU6IHBhcnNlZERhdGEucGl4ZWxzLm1heFZhbHVlLFxuICAgICAgICBub0RhdGFWYWx1ZTogbm9EYXRhVmFsdWVcbiAgICAgIH07XG5cbiAgICAgIGlmICh1bmNvbXByZXNzZWREYXRhLnJlc3VsdE1hc2spIHtcbiAgICAgICAgcmVzdWx0Lm1hc2tEYXRhID0gdW5jb21wcmVzc2VkRGF0YS5yZXN1bHRNYXNrO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5FbmNvZGVkTWFzayAmJiBwYXJzZWREYXRhLm1hc2spIHtcbiAgICAgICAgcmVzdWx0LmVuY29kZWRNYXNrRGF0YSA9IHBhcnNlZERhdGEubWFzay5iaXRzZXQgPyBwYXJzZWREYXRhLm1hc2suYml0c2V0IDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuRmlsZUluZm8pIHtcbiAgICAgICAgcmVzdWx0LmZpbGVJbmZvID0gZm9ybWF0RmlsZUluZm8ocGFyc2VkRGF0YSk7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbXB1dGVVc2VkQml0RGVwdGhzKSB7XG4gICAgICAgICAgcmVzdWx0LmZpbGVJbmZvLmJpdERlcHRocyA9IGNvbXB1dGVVc2VkQml0RGVwdGhzKHBhcnNlZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciB1bmNvbXByZXNzUGl4ZWxWYWx1ZXMgPSBmdW5jdGlvbihkYXRhLCBUeXBlZEFycmF5Q2xhc3MsIG1hc2tCaXRzZXQsIG5vRGF0YVZhbHVlLCBzdG9yZURlY29kZWRNYXNrKSB7XG4gICAgICB2YXIgYmxvY2tJZHggPSAwO1xuICAgICAgdmFyIG51bVggPSBkYXRhLnBpeGVscy5udW1CbG9ja3NYO1xuICAgICAgdmFyIG51bVkgPSBkYXRhLnBpeGVscy5udW1CbG9ja3NZO1xuICAgICAgdmFyIGJsb2NrV2lkdGggPSBNYXRoLmZsb29yKGRhdGEud2lkdGggLyBudW1YKTtcbiAgICAgIHZhciBibG9ja0hlaWdodCA9IE1hdGguZmxvb3IoZGF0YS5oZWlnaHQgLyBudW1ZKTtcbiAgICAgIHZhciBzY2FsZSA9IDIgKiBkYXRhLm1heFpFcnJvcjtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IE51bWJlci5NQVhfVkFMVUUsIGN1cnJlbnRWYWx1ZTtcbiAgICAgIG1hc2tCaXRzZXQgPSBtYXNrQml0c2V0IHx8ICgoZGF0YS5tYXNrKSA/IGRhdGEubWFzay5iaXRzZXQgOiBudWxsKTtcblxuICAgICAgdmFyIHJlc3VsdFBpeGVscywgcmVzdWx0TWFzaztcbiAgICAgIHJlc3VsdFBpeGVscyA9IG5ldyBUeXBlZEFycmF5Q2xhc3MoZGF0YS53aWR0aCAqIGRhdGEuaGVpZ2h0KTtcbiAgICAgIGlmIChzdG9yZURlY29kZWRNYXNrICYmIG1hc2tCaXRzZXQpIHtcbiAgICAgICAgcmVzdWx0TWFzayA9IG5ldyBVaW50OEFycmF5KGRhdGEud2lkdGggKiBkYXRhLmhlaWdodCk7XG4gICAgICB9XG4gICAgICB2YXIgYmxvY2tEYXRhQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShibG9ja1dpZHRoICogYmxvY2tIZWlnaHQpO1xuXG4gICAgICB2YXIgeHgsIHl5O1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPD0gbnVtWTsgeSsrKSB7XG4gICAgICAgIHZhciB0aGlzQmxvY2tIZWlnaHQgPSAoeSAhPT0gbnVtWSkgPyBibG9ja0hlaWdodCA6IChkYXRhLmhlaWdodCAlIG51bVkpO1xuICAgICAgICBpZiAodGhpc0Jsb2NrSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPD0gbnVtWDsgeCsrKSB7XG4gICAgICAgICAgdmFyIHRoaXNCbG9ja1dpZHRoID0gKHggIT09IG51bVgpID8gYmxvY2tXaWR0aCA6IChkYXRhLndpZHRoICUgbnVtWCk7XG4gICAgICAgICAgaWYgKHRoaXNCbG9ja1dpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3V0UHRyID0geSAqIGRhdGEud2lkdGggKiBibG9ja0hlaWdodCArIHggKiBibG9ja1dpZHRoO1xuICAgICAgICAgIHZhciBvdXRTdHJpZGUgPSBkYXRhLndpZHRoIC0gdGhpc0Jsb2NrV2lkdGg7XG5cbiAgICAgICAgICB2YXIgYmxvY2sgPSBkYXRhLnBpeGVscy5ibG9ja3NbYmxvY2tJZHhdO1xuXG4gICAgICAgICAgdmFyIGJsb2NrRGF0YSwgYmxvY2tQdHIsIGNvbnN0VmFsdWU7XG4gICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nIDwgMikge1xuICAgICAgICAgICAgLy8gYmxvY2sgaXMgZWl0aGVyIHVuY29tcHJlc3NlZCBvciBiaXQtc3R1ZmZlZCAoZW5jb2RpbmdzIDAgYW5kIDEpXG4gICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gYmxvY2sgaXMgdW5jb21wcmVzc2VkXG4gICAgICAgICAgICAgIGJsb2NrRGF0YSA9IGJsb2NrLnJhd0RhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBibG9jayBpcyBiaXQtc3R1ZmZlZFxuICAgICAgICAgICAgICB1bnN0dWZmKGJsb2NrLnN0dWZmZWREYXRhLCBibG9jay5iaXRzUGVyUGl4ZWwsIGJsb2NrLm51bVZhbGlkUGl4ZWxzLCBibG9jay5vZmZzZXQsIHNjYWxlLCBibG9ja0RhdGFCdWZmZXIsIGRhdGEucGl4ZWxzLm1heFZhbHVlKTtcbiAgICAgICAgICAgICAgYmxvY2tEYXRhID0gYmxvY2tEYXRhQnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2tQdHIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMikge1xuICAgICAgICAgICAgLy8gYmxvY2sgaXMgYWxsIDBcbiAgICAgICAgICAgIGNvbnN0VmFsdWUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJsb2NrIGhhcyBjb25zdGFudCB2YWx1ZSAoZW5jb2RpbmcgPT09IDMpXG4gICAgICAgICAgICBjb25zdFZhbHVlID0gYmxvY2sub2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXNrQnl0ZTtcbiAgICAgICAgICBpZiAobWFza0JpdHNldCkge1xuICAgICAgICAgICAgZm9yICh5eSA9IDA7IHl5IDwgdGhpc0Jsb2NrSGVpZ2h0OyB5eSsrKSB7XG4gICAgICAgICAgICAgIGlmIChvdXRQdHIgJiA3KSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBtYXNrQnl0ZSA9IG1hc2tCaXRzZXRbb3V0UHRyID4+IDNdO1xuICAgICAgICAgICAgICAgIG1hc2tCeXRlIDw8PSBvdXRQdHIgJiA3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoeHggPSAwOyB4eCA8IHRoaXNCbG9ja1dpZHRoOyB4eCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEob3V0UHRyICYgNykpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlYWQgbmV4dCBieXRlIGZyb20gbWFza1xuICAgICAgICAgICAgICAgICAgbWFza0J5dGUgPSBtYXNrQml0c2V0W291dFB0ciA+PiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tCeXRlICYgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAvLyBwaXhlbCBkYXRhIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hc2tbb3V0UHRyXSA9IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSAoYmxvY2suZW5jb2RpbmcgPCAyKSA/IGJsb2NrRGF0YVtibG9ja1B0cisrXSA6IGNvbnN0VmFsdWU7XG4gICAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IG1pblZhbHVlID4gY3VycmVudFZhbHVlID8gY3VycmVudFZhbHVlIDogbWluVmFsdWU7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBwaXhlbCBkYXRhIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0TWFzaykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXNrW291dFB0cl0gPSAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IG5vRGF0YVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXNrQnl0ZSA8PD0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXNrIG5vdCBwcmVzZW50LCBzaW1wbHkgY29weSBibG9jayBvdmVyXG4gICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPCAyKSB7XG4gICAgICAgICAgICAgIC8vIGR1cGxpY2F0aW5nIHRoaXMgY29kZSBibG9jayBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgICAgICAgICAgICAvLyBibG9ja0RhdGEgY2FzZTpcbiAgICAgICAgICAgICAgZm9yICh5eSA9IDA7IHl5IDwgdGhpc0Jsb2NrSGVpZ2h0OyB5eSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh4eCA9IDA7IHh4IDwgdGhpc0Jsb2NrV2lkdGg7IHh4KyspIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGJsb2NrRGF0YVtibG9ja1B0cisrXTtcbiAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gbWluVmFsdWUgPiBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgOiBtaW5WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjb25zdFZhbHVlIGNhc2U6XG4gICAgICAgICAgICAgIG1pblZhbHVlID0gbWluVmFsdWUgPiBjb25zdFZhbHVlID8gY29uc3RWYWx1ZSA6IG1pblZhbHVlO1xuICAgICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHh4ID0gMDsgeHggPCB0aGlzQmxvY2tXaWR0aDsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IGNvbnN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChibG9jay5lbmNvZGluZyA9PT0gMSkgJiYgKGJsb2NrUHRyICE9PSBibG9jay5udW1WYWxpZFBpeGVscykpIHtcbiAgICAgICAgICAgIHRocm93IFwiQmxvY2sgYW5kIE1hc2sgZG8gbm90IG1hdGNoXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJsb2NrSWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0UGl4ZWxzOiByZXN1bHRQaXhlbHMsXG4gICAgICAgIHJlc3VsdE1hc2s6IHJlc3VsdE1hc2ssXG4gICAgICAgIG1pblZhbHVlOiBtaW5WYWx1ZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGZvcm1hdEZpbGVJbmZvID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJmaWxlSWRlbnRpZmllclN0cmluZ1wiOiBkYXRhLmZpbGVJZGVudGlmaWVyU3RyaW5nLFxuICAgICAgICBcImZpbGVWZXJzaW9uXCI6IGRhdGEuZmlsZVZlcnNpb24sXG4gICAgICAgIFwiaW1hZ2VUeXBlXCI6IGRhdGEuaW1hZ2VUeXBlLFxuICAgICAgICBcImhlaWdodFwiOiBkYXRhLmhlaWdodCxcbiAgICAgICAgXCJ3aWR0aFwiOiBkYXRhLndpZHRoLFxuICAgICAgICBcIm1heFpFcnJvclwiOiBkYXRhLm1heFpFcnJvcixcbiAgICAgICAgXCJlb2ZPZmZzZXRcIjogZGF0YS5lb2ZPZmZzZXQsXG4gICAgICAgIFwibWFza1wiOiBkYXRhLm1hc2sgPyB7XG4gICAgICAgICAgXCJudW1CbG9ja3NYXCI6IGRhdGEubWFzay5udW1CbG9ja3NYLFxuICAgICAgICAgIFwibnVtQmxvY2tzWVwiOiBkYXRhLm1hc2subnVtQmxvY2tzWSxcbiAgICAgICAgICBcIm51bUJ5dGVzXCI6IGRhdGEubWFzay5udW1CeXRlcyxcbiAgICAgICAgICBcIm1heFZhbHVlXCI6IGRhdGEubWFzay5tYXhWYWx1ZVxuICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgXCJwaXhlbHNcIjoge1xuICAgICAgICAgIFwibnVtQmxvY2tzWFwiOiBkYXRhLnBpeGVscy5udW1CbG9ja3NYLFxuICAgICAgICAgIFwibnVtQmxvY2tzWVwiOiBkYXRhLnBpeGVscy5udW1CbG9ja3NZLFxuICAgICAgICAgIFwibnVtQnl0ZXNcIjogZGF0YS5waXhlbHMubnVtQnl0ZXMsXG4gICAgICAgICAgXCJtYXhWYWx1ZVwiOiBkYXRhLnBpeGVscy5tYXhWYWx1ZSxcbiAgICAgICAgICBcIm5vRGF0YVZhbHVlXCI6IGRhdGEubm9EYXRhVmFsdWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbXB1dGVVc2VkQml0RGVwdGhzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG51bUJsb2NrcyA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ggKiBkYXRhLnBpeGVscy5udW1CbG9ja3NZO1xuICAgICAgdmFyIGJpdERlcHRocyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBkYXRhLnBpeGVscy5ibG9ja3NbaV07XG4gICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAgIGJpdERlcHRocy5mbG9hdDMyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAgIGJpdERlcHRoc1tibG9jay5iaXRzUGVyUGl4ZWxdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiaXREZXB0aHNbMF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhiaXREZXB0aHMpO1xuICAgIH07XG5cbiAgICB2YXIgcGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgZnAsIHNraXBNYXNrKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICAvLyBGaWxlIGhlYWRlclxuICAgICAgdmFyIGZpbGVJZFZpZXcgPSBuZXcgVWludDhBcnJheShpbnB1dCwgZnAsIDEwKTtcbiAgICAgIGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGZpbGVJZFZpZXcpO1xuICAgICAgaWYgKGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmcudHJpbSgpICE9PSBcIkNudFpJbWFnZVwiKSB7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBmaWxlIGlkZW50aWZpZXIgc3RyaW5nOiBcIiArIGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmc7XG4gICAgICB9XG4gICAgICBmcCArPSAxMDtcbiAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBmcCwgMjQpO1xuICAgICAgZGF0YS5maWxlVmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICBkYXRhLmltYWdlVHlwZSA9IHZpZXcuZ2V0SW50MzIoNCwgdHJ1ZSk7XG4gICAgICBkYXRhLmhlaWdodCA9IHZpZXcuZ2V0VWludDMyKDgsIHRydWUpO1xuICAgICAgZGF0YS53aWR0aCA9IHZpZXcuZ2V0VWludDMyKDEyLCB0cnVlKTtcbiAgICAgIGRhdGEubWF4WkVycm9yID0gdmlldy5nZXRGbG9hdDY0KDE2LCB0cnVlKTtcbiAgICAgIGZwICs9IDI0O1xuXG4gICAgICAvLyBNYXNrIEhlYWRlclxuICAgICAgaWYgKCFza2lwTWFzaykge1xuICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBmcCwgMTYpO1xuICAgICAgICBkYXRhLm1hc2sgPSB7fTtcbiAgICAgICAgZGF0YS5tYXNrLm51bUJsb2Nrc1kgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgZGF0YS5tYXNrLm51bUJsb2Nrc1ggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTtcbiAgICAgICAgZGF0YS5tYXNrLm51bUJ5dGVzID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgIGRhdGEubWFzay5tYXhWYWx1ZSA9IHZpZXcuZ2V0RmxvYXQzMigxMiwgdHJ1ZSk7XG4gICAgICAgIGZwICs9IDE2O1xuXG4gICAgICAgIC8vIE1hc2sgRGF0YVxuICAgICAgICBpZiAoZGF0YS5tYXNrLm51bUJ5dGVzID4gMCkge1xuICAgICAgICAgIHZhciBiaXRzZXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoZGF0YS53aWR0aCAqIGRhdGEuaGVpZ2h0IC8gOCkpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCBkYXRhLm1hc2subnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBjbnQgPSB2aWV3LmdldEludDE2KDAsIHRydWUpO1xuICAgICAgICAgIHZhciBpcCA9IDIsIG9wID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY250ID4gMCkge1xuICAgICAgICAgICAgICB3aGlsZSAoY250LS0pIHsgYml0c2V0W29wKytdID0gdmlldy5nZXRVaW50OChpcCsrKTsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHZpZXcuZ2V0VWludDgoaXArKyk7XG4gICAgICAgICAgICAgIGNudCA9IC1jbnQ7XG4gICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2YWw7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNudCA9IHZpZXcuZ2V0SW50MTYoaXAsIHRydWUpO1xuICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICB9IHdoaWxlIChpcCA8IGRhdGEubWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgaWYgKChjbnQgIT09IC0zMjc2OCkgfHwgKG9wIDwgYml0c2V0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBlbmQgb2YgbWFzayBSTEUgZW5jb2RpbmdcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YS5tYXNrLmJpdHNldCA9IGJpdHNldDtcbiAgICAgICAgICBmcCArPSBkYXRhLm1hc2subnVtQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGRhdGEubWFzay5udW1CeXRlcyB8IGRhdGEubWFzay5udW1CbG9ja3NZIHwgZGF0YS5tYXNrLm1heFZhbHVlKSA9PT0gMCkgeyAgLy8gU3BlY2lhbCBjYXNlLCBhbGwgbm9kYXRhXG4gICAgICAgICAgZGF0YS5tYXNrLmJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChkYXRhLndpZHRoICogZGF0YS5oZWlnaHQgLyA4KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUGl4ZWwgSGVhZGVyXG4gICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBmcCwgMTYpO1xuICAgICAgZGF0YS5waXhlbHMgPSB7fTtcbiAgICAgIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1kgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTtcbiAgICAgIGRhdGEucGl4ZWxzLm51bUJ5dGVzID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICBkYXRhLnBpeGVscy5tYXhWYWx1ZSA9IHZpZXcuZ2V0RmxvYXQzMigxMiwgdHJ1ZSk7XG4gICAgICBmcCArPSAxNjtcblxuICAgICAgdmFyIG51bUJsb2Nrc1ggPSBkYXRhLnBpeGVscy5udW1CbG9ja3NYO1xuICAgICAgdmFyIG51bUJsb2Nrc1kgPSBkYXRhLnBpeGVscy5udW1CbG9ja3NZO1xuICAgICAgLy8gdGhlIG51bWJlciBvZiBibG9ja3Mgc3BlY2lmaWVkIGluIHRoZSBoZWFkZXIgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgdGhlIGJsb2NrcyBhdCB0aGUgZW5kIG9mXG4gICAgICAvLyBlYWNoIHJvdy9jb2x1bW4gd2l0aCBhIHNwZWNpYWwgd2lkdGgvaGVpZ2h0IHRoYXQgbWFrZSB0aGUgaW1hZ2UgY29tcGxldGUgaW4gY2FzZSB0aGUgd2lkdGggaXMgbm90XG4gICAgICAvLyBldmVubHkgZGl2aXNpYmxlIGJ5IHRoZSBudW1iZXIgb2YgYmxvY2tzLlxuICAgICAgdmFyIGFjdHVhbE51bUJsb2Nrc1ggPSBudW1CbG9ja3NYICsgKChkYXRhLndpZHRoICUgbnVtQmxvY2tzWCkgPiAwID8gMSA6IDApO1xuICAgICAgdmFyIGFjdHVhbE51bUJsb2Nrc1kgPSBudW1CbG9ja3NZICsgKChkYXRhLmhlaWdodCAlIG51bUJsb2Nrc1kpID4gMCA/IDEgOiAwKTtcbiAgICAgIGRhdGEucGl4ZWxzLmJsb2NrcyA9IG5ldyBBcnJheShhY3R1YWxOdW1CbG9ja3NYICogYWN0dWFsTnVtQmxvY2tzWSk7XG4gICAgICB2YXIgYmxvY2tJID0gMDtcbiAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGFjdHVhbE51bUJsb2Nrc1k7IGJsb2NrWSsrKSB7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IGFjdHVhbE51bUJsb2Nrc1g7IGJsb2NrWCsrKSB7XG5cbiAgICAgICAgICAvLyBCbG9ja1xuICAgICAgICAgIHZhciBzaXplID0gMDtcbiAgICAgICAgICB2YXIgYnl0ZXNMZWZ0ID0gaW5wdXQuYnl0ZUxlbmd0aCAtIGZwO1xuICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCBNYXRoLm1pbigxMCwgYnl0ZXNMZWZ0KSk7XG4gICAgICAgICAgdmFyIGJsb2NrID0ge307XG4gICAgICAgICAgZGF0YS5waXhlbHMuYmxvY2tzW2Jsb2NrSSsrXSA9IGJsb2NrO1xuICAgICAgICAgIHZhciBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OCgwKTsgc2l6ZSsrO1xuICAgICAgICAgIGJsb2NrLmVuY29kaW5nID0gaGVhZGVyQnl0ZSAmIDYzO1xuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA+IDMpIHtcbiAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBibG9jayBlbmNvZGluZyAoXCIgKyBibG9jay5lbmNvZGluZyArIFwiKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDIpIHtcbiAgICAgICAgICAgIGZwKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChoZWFkZXJCeXRlICE9PSAwKSAmJiAoaGVhZGVyQnl0ZSAhPT0gMikpIHtcbiAgICAgICAgICAgIGhlYWRlckJ5dGUgPj49IDY7XG4gICAgICAgICAgICBibG9jay5vZmZzZXRUeXBlID0gaGVhZGVyQnl0ZTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJCeXRlID09PSAyKSB7XG4gICAgICAgICAgICAgIGJsb2NrLm9mZnNldCA9IHZpZXcuZ2V0SW50OCgxKTsgc2l6ZSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAxKSB7XG4gICAgICAgICAgICAgIGJsb2NrLm9mZnNldCA9IHZpZXcuZ2V0SW50MTYoMSwgdHJ1ZSk7IHNpemUgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyQnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBibG9jay5vZmZzZXQgPSB2aWV3LmdldEZsb2F0MzIoMSwgdHJ1ZSk7IHNpemUgKz0gNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBibG9jayBvZmZzZXQgdHlwZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDEpIHtcbiAgICAgICAgICAgICAgaGVhZGVyQnl0ZSA9IHZpZXcuZ2V0VWludDgoc2l6ZSk7IHNpemUrKztcbiAgICAgICAgICAgICAgYmxvY2suYml0c1BlclBpeGVsID0gaGVhZGVyQnl0ZSAmIDYzO1xuICAgICAgICAgICAgICBoZWFkZXJCeXRlID4+PSA2O1xuICAgICAgICAgICAgICBibG9jay5udW1WYWxpZFBpeGVsc1R5cGUgPSBoZWFkZXJCeXRlO1xuICAgICAgICAgICAgICBpZiAoaGVhZGVyQnl0ZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzID0gdmlldy5nZXRVaW50OChzaXplKTsgc2l6ZSsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlckJ5dGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBibG9jay5udW1WYWxpZFBpeGVscyA9IHZpZXcuZ2V0VWludDE2KHNpemUsIHRydWUpOyBzaXplICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyQnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzID0gdmlldy5nZXRVaW50MzIoc2l6ZSwgdHJ1ZSk7IHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdmFsaWQgcGl4ZWwgY291bnQgdHlwZVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZwICs9IHNpemU7XG5cbiAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPT09IDMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhcnJheUJ1Ziwgc3RvcmU4O1xuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIG51bVBpeGVscyA9IChkYXRhLnBpeGVscy5udW1CeXRlcyAtIDEpIC8gNDtcbiAgICAgICAgICAgIGlmIChudW1QaXhlbHMgIT09IE1hdGguZmxvb3IobnVtUGl4ZWxzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBcInVuY29tcHJlc3NlZCBibG9jayBoYXMgaW52YWxpZCBsZW5ndGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKG51bVBpeGVscyAqIDQpO1xuICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZnAsIG51bVBpeGVscyAqIDQpKTtcbiAgICAgICAgICAgIHZhciByYXdEYXRhID0gbmV3IEZsb2F0MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBibG9jay5yYXdEYXRhID0gcmF3RGF0YTtcbiAgICAgICAgICAgIGZwICs9IG51bVBpeGVscyAqIDQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGRhdGFCeXRlcyA9IE1hdGguY2VpbChibG9jay5udW1WYWxpZFBpeGVscyAqIGJsb2NrLmJpdHNQZXJQaXhlbCAvIDgpO1xuICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IE1hdGguY2VpbChkYXRhQnl0ZXMgLyA0KTtcbiAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpO1xuICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZnAsIGRhdGFCeXRlcykpO1xuICAgICAgICAgICAgYmxvY2suc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgZnAgKz0gZGF0YUJ5dGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBmcDtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICB2YXIgdW5zdHVmZiA9IGZ1bmN0aW9uKHNyYywgYml0c1BlclBpeGVsLCBudW1QaXhlbHMsIG9mZnNldCwgc2NhbGUsIGRlc3QsIG1heFZhbHVlKSB7XG4gICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgdmFyIGJpdHNMZWZ0ID0gMDtcbiAgICAgIHZhciBuLCBidWZmZXI7XG4gICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgLy8gZ2V0IHJpZCBvZiB0cmFpbGluZyBieXRlcyB0aGF0IGFyZSBhbHJlYWR5IHBhcnQgb2YgbmV4dCBibG9ja1xuICAgICAgdmFyIG51bUludmFsaWRUYWlsQnl0ZXMgPSBzcmMubGVuZ3RoICogNCAtIE1hdGguY2VpbChiaXRzUGVyUGl4ZWwgKiBudW1QaXhlbHMgLyA4KTtcbiAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzO1xuXG4gICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgbiA9IChidWZmZXIgPj4+IChiaXRzTGVmdCAtIGJpdHNQZXJQaXhlbCkpICYgYml0TWFzaztcbiAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICAvL3BpeGVsIHZhbHVlcyBtYXkgZXhjZWVkIG1heCBkdWUgdG8gcXVhbnRpemF0aW9uXG4gICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfTtcblxuICAgIHJldHVybiBDbnRaSW1hZ2U7XG4gIH0pKCk7XG5cbiAgLy92ZXJzaW9uIDIuIFN1cHBvcnRzIDIuMSwgMi4yLCAyLjNcbiAgdmFyIExlcmMyRGVjb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIC8vIE5vdGU6IGN1cnJlbnRseSwgdGhpcyBtb2R1bGUgb25seSBoYXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIGRlY29kaW5nIExFUkMgZGF0YSwgbm90IGVuY29kaW5nLiBUaGUgbmFtZSBvZlxuICAgIC8vIHRoZSBjbGFzcyB3YXMgY2hvc2VuIHRvIGJlIGZ1dHVyZSBwcm9vZiwgZm9sbG93aW5nIExlcmNEZWNvZGUuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAqIHByaXZhdGUgc3RhdGljIGNsYXNzIGJpdHN1dGZmZXIgdXNlZCBieSBMZXJjMkRlY29kZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIEJpdFN0dWZmZXIgPSB7XG4gICAgICAvL21ldGhvZHMgZW5kaW5nIHdpdGggMiBhcmUgZm9yIHRoZSBuZXcgYnl0ZSBvcmRlciB1c2VkIGJ5IExlcmMyLjMgYW5kIGFib3ZlLlxuICAgICAgLy9vcmlnaW5hbFVuc3R1ZmYgaXMgdXNlZCB0byB1bnBhY2sgSHVmZm1hbiBjb2RlIHRhYmxlLiBjb2RlIGlzIGR1cGxpY2F0ZWQgdG8gdW5zdHVmZnggZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICB1bnN0dWZmOiBmdW5jdGlvbihzcmMsIGRlc3QsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBsdXRBcnIsIG9mZnNldCwgc2NhbGUsIG1heFZhbHVlKSB7XG4gICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG4gICAgICAgIHZhciBpID0gMCwgbztcbiAgICAgICAgdmFyIGJpdHNMZWZ0ID0gMDtcbiAgICAgICAgdmFyIG4sIGJ1ZmZlciwgbWlzc2luZ0JpdHMsIG5tYXg7XG5cbiAgICAgICAgLy8gZ2V0IHJpZCBvZiB0cmFpbGluZyBieXRlcyB0aGF0IGFyZSBhbHJlYWR5IHBhcnQgb2YgbmV4dCBibG9ja1xuICAgICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpO1xuICAgICAgICBzcmNbc3JjLmxlbmd0aCAtIDFdIDw8PSA4ICogbnVtSW52YWxpZFRhaWxCeXRlcztcbiAgICAgICAgaWYgKGx1dEFycikge1xuICAgICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3Rbb10gPSBsdXRBcnJbbl07Ly9vZmZzZXQgKyBsdXRBcnJbbl0gKiBzY2FsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgICBuID0gKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgICBuICs9IChidWZmZXIgPj4+IGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcGl4ZWwgdmFsdWVzIG1heSBleGNlZWQgbWF4IGR1ZSB0byBxdWFudGl6YXRpb25cbiAgICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5zdHVmZkxVVDogZnVuY3Rpb24oc3JjLCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvID0gMCwgbWlzc2luZ0JpdHMgPSAwLCBiaXRzTGVmdCA9IDAsIG4gPSAwO1xuICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICB2YXIgZGVzdCA9IFtdO1xuXG4gICAgICAgIC8vIGdldCByaWQgb2YgdHJhaWxpbmcgYnl0ZXMgdGhhdCBhcmUgYWxyZWFkeSBwYXJ0IG9mIG5leHQgYmxvY2tcbiAgICAgICAgdmFyIG51bUludmFsaWRUYWlsQnl0ZXMgPSBzcmMubGVuZ3RoICogNCAtIE1hdGguY2VpbChiaXRzUGVyUGl4ZWwgKiBudW1QaXhlbHMgLyA4KTtcbiAgICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7XG5cbiAgICAgICAgdmFyIG5tYXggPSBNYXRoLmNlaWwoKG1heFZhbHVlIC0gb2Zmc2V0KSAvIHNjYWxlKTtcbiAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2Rlc3QucHVzaChuKTtcbiAgICAgICAgICBkZXN0W29dID0gbiA8IG5tYXggPyBvZmZzZXQgKyBuICogc2NhbGUgOiBtYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0LnVuc2hpZnQob2Zmc2V0KTsvLzFzdCBvbmVcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9LFxuXG4gICAgICB1bnN0dWZmMjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgbHV0QXJyLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG87XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IDAsIGJpdFBvcyA9IDA7XG4gICAgICAgIHZhciBuLCBidWZmZXIsIG1pc3NpbmdCaXRzO1xuICAgICAgICBpZiAobHV0QXJyKSB7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICAgIGJpdFBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzaztcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3Rbb10gPSBsdXRBcnJbbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICAgIGJpdFBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIC8vbm8gdW5zaWduZWQgbGVmdCBzaGlmdFxuICAgICAgICAgICAgICBuID0gKChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrKTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsO1xuICAgICAgICAgICAgICBiaXRQb3MgKz0gYml0c1BlclBpeGVsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2s7Ly8oKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICAgIG4gfD0gKGJ1ZmZlciAmICgoMSA8PCBtaXNzaW5nQml0cykgLSAxKSkgPDwgKGJpdHNQZXJQaXhlbCAtIG1pc3NpbmdCaXRzKTtcbiAgICAgICAgICAgICAgYml0UG9zID0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3BpeGVsIHZhbHVlcyBtYXkgZXhjZWVkIG1heCBkdWUgdG8gcXVhbnRpemF0aW9uXG4gICAgICAgICAgICBkZXN0W29dID0gbiA8IG5tYXggPyBvZmZzZXQgKyBuICogc2NhbGUgOiBtYXhWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9LFxuXG4gICAgICB1bnN0dWZmTFVUMjogZnVuY3Rpb24oc3JjLCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvID0gMCwgbWlzc2luZ0JpdHMgPSAwLCBiaXRzTGVmdCA9IDAsIG4gPSAwLCBiaXRQb3MgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICB2YXIgZGVzdCA9IFtdO1xuICAgICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICAgIGJpdFBvcyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgIC8vbm8gdW5zaWduZWQgbGVmdCBzaGlmdFxuICAgICAgICAgICAgbiA9ICgoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzayk7XG4gICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICBiaXRQb3MgKz0gYml0c1BlclBpeGVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2s7Ly8oKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIG4gfD0gKGJ1ZmZlciAmICgoMSA8PCBtaXNzaW5nQml0cykgLSAxKSkgPDwgKGJpdHNQZXJQaXhlbCAtIG1pc3NpbmdCaXRzKTtcbiAgICAgICAgICAgIGJpdFBvcyA9IG1pc3NpbmdCaXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2Rlc3QucHVzaChuKTtcbiAgICAgICAgICBkZXN0W29dID0gbiA8IG5tYXggPyBvZmZzZXQgKyBuICogc2NhbGUgOiBtYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0LnVuc2hpZnQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9LFxuXG4gICAgICBvcmlnaW5hbFVuc3R1ZmY6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgICB2YXIgYml0c0xlZnQgPSAwO1xuICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0cztcblxuICAgICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrXG4gICAgICAgIHZhciBudW1JbnZhbGlkVGFpbEJ5dGVzID0gc3JjLmxlbmd0aCAqIDQgLSBNYXRoLmNlaWwoYml0c1BlclBpeGVsICogbnVtUGl4ZWxzIC8gOCk7XG4gICAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzO1xuXG4gICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXN0W29dID0gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIG9yaWdpbmFsVW5zdHVmZjI6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgICB2YXIgYml0c0xlZnQgPSAwLCBiaXRQb3MgPSAwO1xuICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0cztcbiAgICAgICAgLy9taWNyby1vcHRpbWl6YXRpb25zXG4gICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgLy9ubyB1bnNpZ25lZCBsZWZ0IHNoaWZ0XG4gICAgICAgICAgICBuID0gKChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrKTtcbiAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsvLygoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgYml0UG9zID0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3Rbb10gPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAqcHJpdmF0ZSBzdGF0aWMgY2xhc3MgdXNlZCBieSBMZXJjMkRlY29kZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgTGVyYzJIZWxwZXJzID0ge1xuICAgICAgSFVGRk1BTl9MVVRfQklUU19NQVg6IDEyLCAvL3VzZSAyXjEyIGx1dCwgdHJlYXQgaXQgbGlrZSBjb25zdGFudFxuICAgICAgY29tcHV0ZUNoZWNrc3VtRmxldGNoZXIzMjogZnVuY3Rpb24oaW5wdXQpIHtcblxuICAgICAgICB2YXIgc3VtMSA9IDB4ZmZmZiwgc3VtMiA9IDB4ZmZmZjtcbiAgICAgICAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHdvcmRzID0gTWF0aC5mbG9vcihsZW4gLyAyKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAod29yZHMpIHtcbiAgICAgICAgICB2YXIgdGxlbiA9ICh3b3JkcyA+PSAzNTkpID8gMzU5IDogd29yZHM7XG4gICAgICAgICAgd29yZHMgLT0gdGxlbjtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBzdW0xICs9IChpbnB1dFtpKytdIDw8IDgpO1xuICAgICAgICAgICAgc3VtMiArPSBzdW0xICs9IGlucHV0W2krK107XG4gICAgICAgICAgfSB3aGlsZSAoLS10bGVuKTtcblxuICAgICAgICAgIHN1bTEgPSAoc3VtMSAmIDB4ZmZmZikgKyAoc3VtMSA+Pj4gMTYpO1xuICAgICAgICAgIHN1bTIgPSAoc3VtMiAmIDB4ZmZmZikgKyAoc3VtMiA+Pj4gMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBzdHJhZ2dsZXIgYnl0ZSBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKGxlbiAmIDEpIHtcbiAgICAgICAgICBzdW0yICs9IHN1bTEgKz0gKGlucHV0W2ldIDw8IDgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlY29uZCByZWR1Y3Rpb24gc3RlcCB0byByZWR1Y2Ugc3VtcyB0byAxNiBiaXRzXG4gICAgICAgIHN1bTEgPSAoc3VtMSAmIDB4ZmZmZikgKyAoc3VtMSA+Pj4gMTYpO1xuICAgICAgICBzdW0yID0gKHN1bTIgJiAweGZmZmYpICsgKHN1bTIgPj4+IDE2KTtcblxuICAgICAgICByZXR1cm4gKHN1bTIgPDwgMTYgfCBzdW0xKSA+Pj4gMDtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWRIZWFkZXJJbmZvOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAgICAgICB2YXIgcHRyID0gZGF0YS5wdHI7XG4gICAgICAgIHZhciBmaWxlSWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgNik7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0ge307XG4gICAgICAgIGhlYWRlckluZm8uZmlsZUlkZW50aWZpZXJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGZpbGVJZFZpZXcpO1xuICAgICAgICBpZiAoaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZy5sYXN0SW5kZXhPZihcIkxlcmMyXCIsIDApICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmcgKGV4cGVjdCBMZXJjMiApOiBcIiArIGhlYWRlckluZm8uZmlsZUlkZW50aWZpZXJTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcHRyICs9IDY7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDgpO1xuICAgICAgICB2YXIgZmlsZVZlcnNpb24gPSB2aWV3LmdldEludDMyKDAsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uID0gZmlsZVZlcnNpb247XG4gICAgICAgIHB0ciArPSA0O1xuICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgIGhlYWRlckluZm8uY2hlY2tzdW0gPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTsgLy9ucm93c1xuICAgICAgICAgIHB0ciArPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9rZXlzIHN0YXJ0IGZyb20gaGVyZVxuICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDEyKTtcbiAgICAgICAgaGVhZGVySW5mby5oZWlnaHQgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTsgLy9ucm93c1xuICAgICAgICBoZWFkZXJJbmZvLndpZHRoID0gdmlldy5nZXRVaW50MzIoNCwgdHJ1ZSk7IC8vbmNvbHNcbiAgICAgICAgcHRyICs9IDg7XG4gICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSA0KSB7XG4gICAgICAgICAgaGVhZGVySW5mby5udW1EaW1zID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgICAgcHRyICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaGVhZGVySW5mby5udW1EaW1zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgNDApO1xuICAgICAgICBoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgPSB2aWV3LmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby5taWNyb0Jsb2NrU2l6ZSA9IHZpZXcuZ2V0SW50MzIoNCwgdHJ1ZSk7XG4gICAgICAgIGhlYWRlckluZm8uYmxvYlNpemUgPSB2aWV3LmdldEludDMyKDgsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLmltYWdlVHlwZSA9IHZpZXcuZ2V0SW50MzIoMTIsIHRydWUpO1xuXG4gICAgICAgIGhlYWRlckluZm8ubWF4WkVycm9yID0gdmlldy5nZXRGbG9hdDY0KDE2LCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby56TWluID0gdmlldy5nZXRGbG9hdDY0KDI0LCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby56TWF4ID0gdmlldy5nZXRGbG9hdDY0KDMyLCB0cnVlKTtcbiAgICAgICAgcHRyICs9IDQwO1xuICAgICAgICBkYXRhLmhlYWRlckluZm8gPSBoZWFkZXJJbmZvO1xuICAgICAgICBkYXRhLnB0ciA9IHB0cjtcblxuICAgICAgICB2YXIgY2hlY2tzdW0sIGtleUxlbmd0aDtcbiAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDMpIHtcbiAgICAgICAgICBrZXlMZW5ndGggPSBmaWxlVmVyc2lvbiA+PSA0ID8gNTIgOiA0ODtcbiAgICAgICAgICBjaGVja3N1bSA9IHRoaXMuY29tcHV0ZUNoZWNrc3VtRmxldGNoZXIzMihuZXcgVWludDhBcnJheShpbnB1dCwgcHRyIC0ga2V5TGVuZ3RoLCBoZWFkZXJJbmZvLmJsb2JTaXplIC0gMTQpKTtcbiAgICAgICAgICBpZiAoY2hlY2tzdW0gIT09IGhlYWRlckluZm8uY2hlY2tzdW0pIHtcbiAgICAgICAgICAgIHRocm93IFwiQ2hlY2tzdW0gZmFpbGVkLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrTWluTWF4UmFuZ2VzOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgdmFyIE91dFBpeGVsVHlwZUFycmF5ID0gdGhpcy5nZXREYXRhVHlwZUFycmF5KGhlYWRlckluZm8uaW1hZ2VUeXBlKTtcbiAgICAgICAgdmFyIHJhbmdlQnl0ZXMgPSBoZWFkZXJJbmZvLm51bURpbXMgKiB0aGlzLmdldERhdGFUeXBlU2l6ZShoZWFkZXJJbmZvLmltYWdlVHlwZSk7XG4gICAgICAgIHZhciBtaW5WYWx1ZXMgPSB0aGlzLnJlYWRTdWJBcnJheShpbnB1dCwgZGF0YS5wdHIsIE91dFBpeGVsVHlwZUFycmF5LCByYW5nZUJ5dGVzKTtcbiAgICAgICAgdmFyIG1heFZhbHVlcyA9IHRoaXMucmVhZFN1YkFycmF5KGlucHV0LCBkYXRhLnB0ciArIHJhbmdlQnl0ZXMsIE91dFBpeGVsVHlwZUFycmF5LCByYW5nZUJ5dGVzKTtcbiAgICAgICAgZGF0YS5wdHIgKz0gKDIgKiByYW5nZUJ5dGVzKTtcbiAgICAgICAgdmFyIGksIGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGhlYWRlckluZm8ubnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1pblZhbHVlc1tpXSAhPT0gbWF4VmFsdWVzW2ldKSB7XG4gICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhlYWRlckluZm8ubWluVmFsdWVzID0gbWluVmFsdWVzO1xuICAgICAgICBoZWFkZXJJbmZvLm1heFZhbHVlcyA9IG1heFZhbHVlcztcbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgICAgfSxcblxuICAgICAgcmVhZFN1YkFycmF5OiBmdW5jdGlvbihpbnB1dCwgcHRyLCBPdXRQaXhlbFR5cGVBcnJheSwgbnVtQnl0ZXMpIHtcbiAgICAgICAgdmFyIHJhd0RhdGE7XG4gICAgICAgIGlmIChPdXRQaXhlbFR5cGVBcnJheSA9PT0gVWludDhBcnJheSkge1xuICAgICAgICAgIHJhd0RhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCBudW1CeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKG51bUJ5dGVzKTtcbiAgICAgICAgICB2YXIgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIHB0ciwgbnVtQnl0ZXMpKTtcbiAgICAgICAgICByYXdEYXRhID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3RGF0YTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWRNYXNrOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAgICAgICB2YXIgcHRyID0gZGF0YS5wdHI7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICB2YXIgbnVtVmFsaWRQaXhlbCA9IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbDtcblxuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgcHRyLCA0KTtcbiAgICAgICAgdmFyIG1hc2sgPSB7fTtcbiAgICAgICAgbWFzay5udW1CeXRlcyA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBwdHIgKz0gNDtcblxuICAgICAgICAvLyBNYXNrIERhdGFcbiAgICAgICAgaWYgKCgwID09PSBudW1WYWxpZFBpeGVsIHx8IG51bVBpeGVscyA9PT0gbnVtVmFsaWRQaXhlbCkgJiYgMCAhPT0gbWFzay5udW1CeXRlcykge1xuICAgICAgICAgIHRocm93IChcImludmFsaWQgbWFza1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYml0c2V0LCByZXN1bHRNYXNrO1xuICAgICAgICBpZiAobnVtVmFsaWRQaXhlbCA9PT0gMCkge1xuICAgICAgICAgIGJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChudW1QaXhlbHMgLyA4KSk7XG4gICAgICAgICAgbWFzay5iaXRzZXQgPSBiaXRzZXQ7XG4gICAgICAgICAgcmVzdWx0TWFzayA9IG5ldyBVaW50OEFycmF5KG51bVBpeGVscyk7XG4gICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0TWFzayA9IHJlc3VsdE1hc2s7XG4gICAgICAgICAgcHRyICs9IG1hc2subnVtQnl0ZXM7XG4gICAgICAgIH0vLyA/Pz8/PyBlbHNlIGlmIChkYXRhLm1hc2subnVtQnl0ZXMgPiAwICYmIGRhdGEubWFzay5udW1CeXRlczwgZGF0YS5udW1WYWxpZFBpeGVsKSB7XG4gICAgICAgIGVsc2UgaWYgKG1hc2subnVtQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgYml0c2V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKG51bVBpeGVscyAvIDgpKTtcbiAgICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIG1hc2subnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBjbnQgPSB2aWV3LmdldEludDE2KDAsIHRydWUpO1xuICAgICAgICAgIHZhciBpcCA9IDIsIG9wID0gMCwgdmFsID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY250ID4gMCkge1xuICAgICAgICAgICAgICB3aGlsZSAoY250LS0pIHsgYml0c2V0W29wKytdID0gdmlldy5nZXRVaW50OChpcCsrKTsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsID0gdmlldy5nZXRVaW50OChpcCsrKTtcbiAgICAgICAgICAgICAgY250ID0gLWNudDtcbiAgICAgICAgICAgICAgd2hpbGUgKGNudC0tKSB7IGJpdHNldFtvcCsrXSA9IHZhbDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY250ID0gdmlldy5nZXRJbnQxNihpcCwgdHJ1ZSk7XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgIH0gd2hpbGUgKGlwIDwgbWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgaWYgKChjbnQgIT09IC0zMjc2OCkgfHwgKG9wIDwgYml0c2V0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBlbmQgb2YgbWFzayBSTEUgZW5jb2RpbmdcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTtcbiAgICAgICAgICB2YXIgbWIgPSAwLCBrID0gMDtcblxuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgaWYgKGsgJiA3KSB7XG4gICAgICAgICAgICAgIG1iID0gYml0c2V0W2sgPj4gM107XG4gICAgICAgICAgICAgIG1iIDw8PSBrICYgNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtYiA9IGJpdHNldFtrID4+IDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1iICYgMTI4KSB7XG4gICAgICAgICAgICAgIHJlc3VsdE1hc2tba10gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRNYXNrID0gcmVzdWx0TWFzaztcblxuICAgICAgICAgIG1hc2suYml0c2V0ID0gYml0c2V0O1xuICAgICAgICAgIHB0ciArPSBtYXNrLm51bUJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHRyID0gcHRyO1xuICAgICAgICBkYXRhLm1hc2sgPSBtYXNrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWREYXRhT25lU3dlZXA6IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICB2YXIgaW1hZ2VUeXBlID0gaGVhZGVySW5mby5pbWFnZVR5cGU7XG4gICAgICAgIHZhciBudW1CeXRlcyA9IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAqIExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUoaW1hZ2VUeXBlKSAqIG51bURpbXM7XG4gICAgICAgIC8vZGF0YS5waXhlbHMubnVtQnl0ZXMgPSBudW1CeXRlcztcbiAgICAgICAgdmFyIHJhd0RhdGE7XG4gICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgaWYgKE91dFBpeGVsVHlwZUFycmF5ID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgICAgcmF3RGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIG51bUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCBudW1CeXRlcykpO1xuICAgICAgICAgIHJhd0RhdGEgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYXdEYXRhLmxlbmd0aCA9PT0gbnVtUGl4ZWxzICogbnVtRGltcykge1xuICAgICAgICAgIGlmICh1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IExlcmMySGVscGVycy5zd2FwRGltZW5zaW9uT3JkZXIocmF3RGF0YSwgbnVtUGl4ZWxzLCBudW1EaW1zLCBPdXRQaXhlbFR5cGVBcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gcmF3RGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAgLy9tYXNrXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogbnVtRGltcyk7XG4gICAgICAgICAgdmFyIHogPSAwLCBrID0gMCwgaSA9IDAsIG5TdGFydCA9IDA7XG4gICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICBpZiAodXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICBuU3RhcnQgPSBrO1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bURpbXM7IGkrKywgblN0YXJ0Kz1udW1QaXhlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW25TdGFydF0gPSByYXdEYXRhW3orK107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHtcbiAgICAgICAgICAgICAgICAgIG5TdGFydCA9IGsgKiBudW1EaW1zO1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bURpbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHNbblN0YXJ0ICsgaV0gPSByYXdEYXRhW3orK107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW2tdID0gcmF3RGF0YVt6KytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB0ciArPSBudW1CeXRlcztcbiAgICAgICAgZGF0YS5wdHIgPSBwdHI7ICAgICAgIC8vcmV0dXJuIGRhdGE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgcmVhZEh1ZmZtYW5UcmVlOiBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICAgICAgICB2YXIgQklUU19NQVggPSB0aGlzLkhVRkZNQU5fTFVUX0JJVFNfTUFYOyAvLzggaXMgc2xvdyBmb3IgdGhlIGxhcmdlIHRlc3QgaW1hZ2VcbiAgICAgICAgLy92YXIgc2l6ZV9tYXggPSAxIDw8IEJJVFNfTUFYO1xuICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgKiByZWFkaW5nIGNvZGUgdGFibGVcbiAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCAxNik7XG4gICAgICAgIGRhdGEucHRyICs9IDE2O1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIGlmICh2ZXJzaW9uIDwgMikge1xuICAgICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgSHVmZm1hbiB2ZXJzaW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB2aWV3LmdldEludDMyKDQsIHRydWUpO1xuICAgICAgICB2YXIgaTAgPSB2aWV3LmdldEludDMyKDgsIHRydWUpO1xuICAgICAgICB2YXIgaTEgPSB2aWV3LmdldEludDMyKDEyLCB0cnVlKTtcbiAgICAgICAgaWYgKGkwID49IGkxKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoaTEgLSBpMCk7XG4gICAgICAgIExlcmMySGVscGVycy5kZWNvZGVCaXRzKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIpO1xuICAgICAgICB2YXIgY29kZVRhYmxlID0gW107IC8vc2l6ZVxuICAgICAgICB2YXIgaSwgaiwgaywgbGVuO1xuXG4gICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykge1xuICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmRcbiAgICAgICAgICBjb2RlVGFibGVbal0gPSB7IGZpcnN0OiBibG9ja0RhdGFCdWZmZXJbaSAtIGkwXSwgc2Vjb25kOiBudWxsIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YUJ5dGVzID0gaW5wdXQuYnl0ZUxlbmd0aCAtIGRhdGEucHRyO1xuICAgICAgICB2YXIgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcbiAgICAgICAgdmFyIHN0dWZmZWREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTsgLy9tdXN0IHN0YXJ0IGZyb20geCo0XG4gICAgICAgIHZhciBiaXRQb3MgPSAwLCB3b3JkLCBzcmNQdHIgPSAwO1xuICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbMF07XG4gICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykge1xuICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmRcbiAgICAgICAgICBsZW4gPSBjb2RlVGFibGVbal0uZmlyc3Q7XG4gICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGNvZGVUYWJsZVtqXS5zZWNvbmQgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBsZW4pO1xuXG4gICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBsZW47XG4gICAgICAgICAgICAgIGlmIChiaXRQb3MgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBsZW4gLSAzMjtcbiAgICAgICAgICAgICAgc3JjUHRyKys7XG4gICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICBjb2RlVGFibGVbal0uc2Vjb25kIHw9IHdvcmQgPj4+ICgzMiAtIGJpdFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9maW5pc2hlZCByZWFkaW5nIGNvZGUgdGFibGVcblxuICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgKiBidWlsZGluZyBsdXRcbiAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIG51bUJpdHNMVVQgPSAwLCBudW1CaXRzTFVUUWljayA9IDA7XG4gICAgICAgIHZhciB0cmVlID0gbmV3IFRyZWVOb2RlKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2RlVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY29kZVRhYmxlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG51bUJpdHNMVVQgPSBNYXRoLm1heChudW1CaXRzTFVULCBjb2RlVGFibGVbaV0uZmlyc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtQml0c0xVVCA+PSBCSVRTX01BWCkge1xuICAgICAgICAgIG51bUJpdHNMVVRRaWNrID0gQklUU19NQVg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbnVtQml0c0xVVFFpY2sgPSBudW1CaXRzTFVUO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBkZWJ1Z2dpbmcgcHVycG9zZVxuICAgICAgICAvLyBpZiAobnVtQml0c0xVVCA+PSAzMCkge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKFwiV0FSbmluZywgbGFyZ2UgTlVNIExVVCBCSVRTIElTIFwiICsgbnVtQml0c0xVVCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdmFyIGRlY29kZUx1dCA9IFtdLCBlbnRyeSwgY29kZSwgbnVtRW50cmllcywgamosIGN1cnJlbnRCaXQsIG5vZGU7XG4gICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykge1xuICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmRcbiAgICAgICAgICBsZW4gPSBjb2RlVGFibGVbal0uZmlyc3Q7XG4gICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW2xlbiwgal07XG4gICAgICAgICAgICBpZiAobGVuIDw9IG51bUJpdHNMVVRRaWNrKSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlVGFibGVbal0uc2Vjb25kIDw8IChudW1CaXRzTFVUUWljayAtIGxlbik7XG4gICAgICAgICAgICAgIG51bUVudHJpZXMgPSAxIDw8IChudW1CaXRzTFVUUWljayAtIGxlbik7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1FbnRyaWVzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVMdXRbY29kZSB8IGtdID0gZW50cnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvL2J1aWxkIHRyZWVcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGVUYWJsZVtqXS5zZWNvbmQ7XG4gICAgICAgICAgICAgIG5vZGUgPSB0cmVlO1xuICAgICAgICAgICAgICBmb3IgKGpqID0gbGVuIC0gMTsgamogPj0gMDsgamotLSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSBjb2RlID4+PiBqaiAmIDE7IC8vbm8gbGVmdCBzaGlmdCBhcyBsZW5ndGggY291bGQgYmUgMzAsMzFcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJpdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmlnaHQgPSBuZXcgVHJlZU5vZGUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IG5ldyBUcmVlTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpqID09PSAwICYmICFub2RlLnZhbCkge1xuICAgICAgICAgICAgICAgICAgbm9kZS52YWwgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWNvZGVMdXQ6IGRlY29kZUx1dCxcbiAgICAgICAgICBudW1CaXRzTFVUUWljazogbnVtQml0c0xVVFFpY2ssXG4gICAgICAgICAgbnVtQml0c0xVVDogbnVtQml0c0xVVCxcbiAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgIHN0dWZmZWREYXRhOiBzdHVmZmVkRGF0YSxcbiAgICAgICAgICBzcmNQdHI6IHNyY1B0cixcbiAgICAgICAgICBiaXRQb3M6IGJpdFBvc1xuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgcmVhZEh1ZmZtYW46IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSwgdXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgbnVtRGltcyA9IGhlYWRlckluZm8ubnVtRGltcztcbiAgICAgICAgdmFyIGhlaWdodCA9IGRhdGEuaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IGRhdGEuaGVhZGVySW5mby53aWR0aDtcbiAgICAgICAgdmFyIG51bVBpeGVscyA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAvL3ZhciBzaXplX21heCA9IDEgPDwgQklUU19NQVg7XG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAqIHJlYWRpbmcgaHVmZm1hbiBzdHJ1Y3R1cmUgaW5mb1xuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgaHVmZm1hbkluZm8gPSB0aGlzLnJlYWRIdWZmbWFuVHJlZShpbnB1dCwgZGF0YSk7XG4gICAgICAgIHZhciBkZWNvZGVMdXQgPSBodWZmbWFuSW5mby5kZWNvZGVMdXQ7XG4gICAgICAgIHZhciB0cmVlID0gaHVmZm1hbkluZm8udHJlZTtcbiAgICAgICAgLy9zdHVmZmVkRGF0YSBpbmNsdWRlcyBodWZmbWFuIGhlYWRlcnNcbiAgICAgICAgdmFyIHN0dWZmZWREYXRhID0gaHVmZm1hbkluZm8uc3R1ZmZlZERhdGE7XG4gICAgICAgIHZhciBzcmNQdHIgPSBodWZmbWFuSW5mby5zcmNQdHI7XG4gICAgICAgIHZhciBiaXRQb3MgPSBodWZmbWFuSW5mby5iaXRQb3M7XG4gICAgICAgIHZhciBudW1CaXRzTFVUUWljayA9IGh1ZmZtYW5JbmZvLm51bUJpdHNMVVRRaWNrO1xuICAgICAgICB2YXIgbnVtQml0c0xVVCA9IGh1ZmZtYW5JbmZvLm51bUJpdHNMVVQ7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlID09PSAwID8gMTI4IDogMDtcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgKiAgZGVjb2RlXG4gICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIG5vZGUsIHZhbCwgZGVsdGEsIG1hc2sgPSBkYXRhLnBpeGVscy5yZXN1bHRNYXNrLCB2YWxUbXAsIHZhbFRtcFF1aWNrLCBjdXJyZW50Qml0O1xuICAgICAgICB2YXIgaSwgaiwgaywgaWk7XG4gICAgICAgIHZhciBwcmV2VmFsID0gMDtcbiAgICAgICAgaWYgKGJpdFBvcyA+IDApIHtcbiAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICBiaXRQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgdmFyIGRlbHRhRW5jb2RlID0gZGF0YS5lbmNvZGVNb2RlID09PSAxO1xuICAgICAgICB2YXIgcmVzdWx0UGl4ZWxzQWxsRGltID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KG51bVBpeGVscyAqIG51bURpbXMpO1xuICAgICAgICB2YXIgcmVzdWx0UGl4ZWxzID0gcmVzdWx0UGl4ZWxzQWxsRGltO1xuICAgICAgICB2YXIgaURpbTtcbiAgICAgICAgLy8gVE9ETzogcmVldmFsdWF0ZSB0aGUgbmVlZCB0byBrZWVwIGlubGluZWQgZGVjb2RpbmcgY29kZSBhcyBJRSBzdXBwb3J0IGlzIHBoYXNpbmcgb3V0XG4gICAgICAgIGlmIChudW1EaW1zIDwgMiB8fCBkZWx0YUVuY29kZSkge1xuICAgICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyspIHtcbiAgICAgICAgICAgIGlmIChudW1EaW1zID4gMSkge1xuICAgICAgICAgICAgICAvL2dldCB0aGUgbWVtIGJsb2NrIG9mIGN1cnJlbnQgZGltZW5zaW9uXG4gICAgICAgICAgICAgIHJlc3VsdFBpeGVscyA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShyZXN1bHRQaXhlbHNBbGxEaW0uYnVmZmVyLCBudW1QaXhlbHMgKiBpRGltLCBudW1QaXhlbHMpO1xuICAgICAgICAgICAgICBwcmV2VmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCA9PT0gd2lkdGggKiBoZWlnaHQpIHsgLy9hbGwgdmFsaWRcbiAgICAgICAgICAgICAgZm9yIChrID0gMCwgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrLCBrKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUUWljayk7XG4gICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVFFpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUUWljaykpO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZUx1dFt2YWxUbXBRdWlja10pICAgIC8vIGlmIHRoZXJlLCBtb3ZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBiaXRzIGFuZCBkb25lXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGRlY29kZUx1dFt2YWxUbXBRdWlja11bMV07XG4gICAgICAgICAgICAgICAgICAgIGJpdFBvcyArPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzBdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVQpO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdHJlZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbnVtQml0c0xVVDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSB2YWxUbXAgPj4+IChudW1CaXRzTFVUIC0gaWkgLSAxKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRCaXQgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUubGVmdCB8fCBub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgPSBiaXRQb3MgKyBpaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3MgPj0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgYml0UG9zIC09IDMyO1xuICAgICAgICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICBkZWx0YSA9IHZhbCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGlmIChkZWx0YUVuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBwcmV2VmFsOyAgICAvLyB1c2Ugb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHJlc3VsdFBpeGVsc1trIC0gd2lkdGhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgJj0gMHhGRjsgLy9vdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTsvL292ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWwgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvL25vdCBhbGwgdmFsaWQsIHVzZSBtYXNrXG4gICAgICAgICAgICAgIGZvciAoayA9IDAsIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7IGorKywgaysrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUUWljayk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVRRaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUUWljaykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZUx1dFt2YWxUbXBRdWlja10pICAgIC8vIGlmIHRoZXJlLCBtb3ZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBiaXRzIGFuZCBkb25lXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgIGJpdFBvcyArPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVQpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDsvLyA+Pj4gZGVsdGFCaXRzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBudW1CaXRzTFVUOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qml0ID0gdmFsVG1wID4+PiAobnVtQml0c0xVVCAtIGlpIC0gMSkgJiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRCaXQgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZS5sZWZ0IHx8IG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5vZGUudmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgPSBiaXRQb3MgKyBpaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYml0UG9zID49IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYml0UG9zIC09IDMyO1xuICAgICAgICAgICAgICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gdmFsIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFFbmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDAgJiYgbWFza1trIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7ICAgIC8vIHVzZSBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID4gMCAmJiBtYXNrW2sgLSB3aWR0aF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHJlc3VsdFBpeGVsc1trIC0gd2lkdGhdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICY9IDB4RkY7IC8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTsvL292ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgICAgcHJldlZhbCA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAoayA9IDAsIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGsgPSBpICogd2lkdGggKyBqO1xuICAgICAgICAgICAgICBpZiAoIW1hc2sgfHwgbWFza1trXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyssIGsrPW51bVBpeGVscykge1xuICAgICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVRRaWNrKTtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wO1xuICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVFFpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUUWljaykpO1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkZWNvZGVMdXRbdmFsVG1wUXVpY2tdKVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzFdO1xuICAgICAgICAgICAgICAgICAgICBiaXRQb3MgKz0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVswXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXAgfD0gKChzdHVmZmVkRGF0YVtzcmNQdHIgKyAxXSkgPj4+ICg2NCAtIGJpdFBvcyAtIG51bUJpdHNMVVQpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWxUbXBRdWljayA9IHZhbFRtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdHJlZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbnVtQml0c0xVVDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSB2YWxUbXAgPj4+IChudW1CaXRzTFVUIC0gaWkgLSAxKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRCaXQgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUubGVmdCB8fCBub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgPSBiaXRQb3MgKyBpaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGJpdFBvcyA+PSAzMikge1xuICAgICAgICAgICAgICAgICAgICBiaXRQb3MgLT0gMzI7XG4gICAgICAgICAgICAgICAgICAgIHNyY1B0cisrO1xuICAgICAgICAgICAgICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZGVsdGEgPSB2YWwgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdHIgPSBkYXRhLnB0ciArIChzcmNQdHIgKyAxKSAqIDQgKyAoYml0UG9zID4gMCA/IDQgOiAwKTtcbiAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gcmVzdWx0UGl4ZWxzQWxsRGltO1xuICAgICAgICAvL3N3YXAgZm9yIEJJUCBsYXlvdXRcbiAgICAgICAgaWYgKG51bURpbXMgPiAxICYmICF1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBMZXJjMkhlbHBlcnMuc3dhcERpbWVuc2lvbk9yZGVyKHJlc3VsdFBpeGVsc0FsbERpbSwgbnVtUGl4ZWxzLCBudW1EaW1zLCBPdXRQaXhlbFR5cGVBcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRlY29kZUJpdHM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIsIG9mZnNldCwgaURpbSkge1xuICAgICAgICB7XG4gICAgICAgICAgLy9iaXRzdHVmZiBlbmNvZGluZyBpcyAzXG4gICAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgICAgdmFyIGZpbGVWZXJzaW9uID0gaGVhZGVySW5mby5maWxlVmVyc2lvbjtcbiAgICAgICAgICAvL3ZhciBibG9jayA9IHt9O1xuICAgICAgICAgIHZhciBibG9ja1B0ciA9IDA7XG4gICAgICAgICAgdmFyIHZpZXdCeXRlTGVuZ3RoID0gKChpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHIpID49IDUpID8gNSA6IChpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHIpO1xuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBkYXRhLnB0ciwgdmlld0J5dGVMZW5ndGgpO1xuICAgICAgICAgIHZhciBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICBibG9ja1B0cisrO1xuICAgICAgICAgIHZhciBiaXRzNjcgPSBoZWFkZXJCeXRlID4+IDY7XG4gICAgICAgICAgdmFyIG4gPSAoYml0czY3ID09PSAwKSA/IDQgOiAzIC0gYml0czY3O1xuICAgICAgICAgIHZhciBkb0x1dCA9IChoZWFkZXJCeXRlICYgMzIpID4gMCA/IHRydWUgOiBmYWxzZTsvLzV0aCBiaXRcbiAgICAgICAgICB2YXIgbnVtQml0cyA9IGhlYWRlckJ5dGUgJiAzMTtcbiAgICAgICAgICB2YXIgbnVtRWxlbWVudHMgPSAwO1xuICAgICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICBudW1FbGVtZW50cyA9IHZpZXcuZ2V0VWludDgoYmxvY2tQdHIpOyBibG9ja1B0cisrO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMikge1xuICAgICAgICAgICAgbnVtRWxlbWVudHMgPSB2aWV3LmdldFVpbnQxNihibG9ja1B0ciwgdHJ1ZSk7IGJsb2NrUHRyICs9IDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09PSA0KSB7XG4gICAgICAgICAgICBudW1FbGVtZW50cyA9IHZpZXcuZ2V0VWludDMyKGJsb2NrUHRyLCB0cnVlKTsgYmxvY2tQdHIgKz0gNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHZhbGlkIHBpeGVsIGNvdW50IHR5cGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9maXg6IGh1ZmZtYW4gY29kZXMgYXJlIGJpdCBzdHVmZmVkLCBidXQgbm90IGJvdW5kIGJ5IGRhdGEncyBtYXggdmFsdWUsIHNvIG5lZWQgdG8gdXNlIG9yaWdpbmFsVW5zdHVmZlxuICAgICAgICAgIC8vb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgICAgdmFyIHNjYWxlID0gMiAqIGhlYWRlckluZm8ubWF4WkVycm9yO1xuICAgICAgICAgIHZhciBzdHVmZmVkRGF0YSwgYXJyYXlCdWYsIHN0b3JlOCwgZGF0YUJ5dGVzLCBkYXRhV29yZHM7XG4gICAgICAgICAgdmFyIGx1dEFyciwgbHV0RGF0YSwgbHV0Qnl0ZXMsIGx1dEJpdHNQZXJFbGVtZW50LCBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgdmFyIHpNYXggPSBoZWFkZXJJbmZvLm51bURpbXMgPiAxID8gaGVhZGVySW5mby5tYXhWYWx1ZXNbaURpbV0gOiBoZWFkZXJJbmZvLnpNYXg7XG4gICAgICAgICAgaWYgKGRvTHV0KSB7XG4gICAgICAgICAgICBkYXRhLmNvdW50ZXIubHV0Kys7XG4gICAgICAgICAgICBsdXRCeXRlcyA9IHZpZXcuZ2V0VWludDgoYmxvY2tQdHIpO1xuICAgICAgICAgICAgbHV0Qml0c1BlckVsZW1lbnQgPSBudW1CaXRzO1xuICAgICAgICAgICAgYmxvY2tQdHIrKztcbiAgICAgICAgICAgIGRhdGFCeXRlcyA9IE1hdGguY2VpbCgobHV0Qnl0ZXMgLSAxKSAqIG51bUJpdHMgLyA4KTtcbiAgICAgICAgICAgIGRhdGFXb3JkcyA9IE1hdGguY2VpbChkYXRhQnl0ZXMgLyA0KTtcbiAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpO1xuICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuXG4gICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcblxuICAgICAgICAgICAgbHV0RGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBkYXRhLnB0ciArPSBkYXRhQnl0ZXM7XG5cbiAgICAgICAgICAgIGJpdHNQZXJQaXhlbCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKGx1dEJ5dGVzIC0gMSkgPj4+IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgICBiaXRzUGVyUGl4ZWwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFCeXRlcyA9IE1hdGguY2VpbChudW1FbGVtZW50cyAqIGJpdHNQZXJQaXhlbCAvIDgpO1xuICAgICAgICAgICAgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBkYXRhLnB0ciwgZGF0YUJ5dGVzKSk7XG4gICAgICAgICAgICBzdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBkYXRhLnB0ciArPSBkYXRhQnl0ZXM7XG4gICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgICAgICBsdXRBcnIgPSBCaXRTdHVmZmVyLnVuc3R1ZmZMVVQyKGx1dERhdGEsIG51bUJpdHMsIGx1dEJ5dGVzIC0gMSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbHV0QXJyID0gQml0U3R1ZmZlci51bnN0dWZmTFVUKGx1dERhdGEsIG51bUJpdHMsIGx1dEJ5dGVzIC0gMSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2x1dEFyci51bnNoaWZ0KDApO1xuICAgICAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDMpIHtcbiAgICAgICAgICAgICAgLy9CaXRTdHVmZmVyLnVuc3R1ZmYyKGJsb2NrLCBibG9ja0RhdGFCdWZmZXIsIGhlYWRlckluZm8uek1heCk7XG4gICAgICAgICAgICAgIEJpdFN0dWZmZXIudW5zdHVmZjIoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cywgbHV0QXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBCaXRTdHVmZmVyLnVuc3R1ZmYoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cywgbHV0QXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJiaXRzdHVmZmVyXCIpO1xuICAgICAgICAgICAgZGF0YS5jb3VudGVyLmJpdHN0dWZmZXIrKztcbiAgICAgICAgICAgIGJpdHNQZXJQaXhlbCA9IG51bUJpdHM7XG4gICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgIGlmIChiaXRzUGVyUGl4ZWwgPiAwKSB7XG4gICAgICAgICAgICAgIGRhdGFCeXRlcyA9IE1hdGguY2VpbChudW1FbGVtZW50cyAqIGJpdHNQZXJQaXhlbCAvIDgpO1xuICAgICAgICAgICAgICBkYXRhV29yZHMgPSBNYXRoLmNlaWwoZGF0YUJ5dGVzIC8gNCk7XG4gICAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpO1xuICAgICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcbiAgICAgICAgICAgICAgc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgICBkYXRhLnB0ciArPSBkYXRhQnl0ZXM7XG4gICAgICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBCaXRTdHVmZmVyLm9yaWdpbmFsVW5zdHVmZjIoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmMihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBmYWxzZSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgQml0U3R1ZmZlci5vcmlnaW5hbFVuc3R1ZmYoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmKHN0dWZmZWREYXRhLCBibG9ja0RhdGFCdWZmZXIsIGJpdHNQZXJQaXhlbCwgbnVtRWxlbWVudHMsIGZhbHNlLCBvZmZzZXQsIHNjYWxlLCB6TWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgcmVhZFRpbGVzOiBmdW5jdGlvbihpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgdmFyIHdpZHRoID0gaGVhZGVySW5mby53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIHZhciBtaWNyb0Jsb2NrU2l6ZSA9IGhlYWRlckluZm8ubWljcm9CbG9ja1NpemU7XG4gICAgICAgIHZhciBpbWFnZVR5cGUgPSBoZWFkZXJJbmZvLmltYWdlVHlwZTtcbiAgICAgICAgdmFyIGRhdGFUeXBlU2l6ZSA9IExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUoaW1hZ2VUeXBlKTtcbiAgICAgICAgdmFyIG51bUJsb2Nrc1ggPSBNYXRoLmNlaWwod2lkdGggLyBtaWNyb0Jsb2NrU2l6ZSk7XG4gICAgICAgIHZhciBudW1CbG9ja3NZID0gTWF0aC5jZWlsKGhlaWdodCAvIG1pY3JvQmxvY2tTaXplKTtcbiAgICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWSA9IG51bUJsb2Nrc1k7XG4gICAgICAgIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ggPSBudW1CbG9ja3NYO1xuICAgICAgICBkYXRhLnBpeGVscy5wdHIgPSAwO1xuICAgICAgICB2YXIgcm93ID0gMCwgY29sID0gMCwgYmxvY2tZID0gMCwgYmxvY2tYID0gMCwgdGhpc0Jsb2NrSGVpZ2h0ID0gMCwgdGhpc0Jsb2NrV2lkdGggPSAwLCBieXRlc0xlZnQgPSAwLCBoZWFkZXJCeXRlID0gMCwgYml0czY3ID0gMCwgdGVzdENvZGUgPSAwLCBvdXRQdHIgPSAwLCBvdXRTdHJpZGUgPSAwLCBudW1CeXRlcyA9IDAsIGJ5dGVzbGVmdCA9IDAsIHogPSAwLCBibG9ja1B0ciA9IDA7XG4gICAgICAgIHZhciB2aWV3LCBibG9jaywgYXJyYXlCdWYsIHN0b3JlOCwgcmF3RGF0YTtcbiAgICAgICAgdmFyIGJsb2NrRW5jb2Rpbmc7XG4gICAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobWljcm9CbG9ja1NpemUgKiBtaWNyb0Jsb2NrU2l6ZSk7XG4gICAgICAgIHZhciBsYXN0QmxvY2tIZWlnaHQgPSAoaGVpZ2h0ICUgbWljcm9CbG9ja1NpemUpIHx8IG1pY3JvQmxvY2tTaXplO1xuICAgICAgICB2YXIgbGFzdEJsb2NrV2lkdGggPSAod2lkdGggJSBtaWNyb0Jsb2NrU2l6ZSkgfHwgbWljcm9CbG9ja1NpemU7XG4gICAgICAgIHZhciBvZmZzZXRUeXBlLCBvZmZzZXQ7XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zLCBpRGltO1xuICAgICAgICB2YXIgbWFzayA9IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2s7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHM7XG4gICAgICAgIHZhciBmaWxlVmVyc2lvbiA9IGhlYWRlckluZm8uZmlsZVZlcnNpb247XG4gICAgICAgIHZhciBmaWxlVmVyc2lvbkNoZWNrTnVtID0gZmlsZVZlcnNpb24gPj0gNSA/IDE0IDogMTU7XG4gICAgICAgIHZhciBpc0RpZmZFbmNvZGluZztcbiAgICAgICAgdmFyIHpNYXggPSBoZWFkZXJJbmZvLnpNYXg7XG4gICAgICAgIC8vdmFyIHJlc3VsdFBpeGVsc0FsbERpbSA9IHJlc3VsdFBpeGVscztcbiAgICAgICAgdmFyIHJlc3VsdFBpeGVsc1ByZXZEaW07XG4gICAgICAgIGZvciAoYmxvY2tZID0gMDsgYmxvY2tZIDwgbnVtQmxvY2tzWTsgYmxvY2tZKyspIHtcbiAgICAgICAgICB0aGlzQmxvY2tIZWlnaHQgPSAoYmxvY2tZICE9PSBudW1CbG9ja3NZIC0gMSkgPyBtaWNyb0Jsb2NrU2l6ZSA6IGxhc3RCbG9ja0hlaWdodDtcbiAgICAgICAgICBmb3IgKGJsb2NrWCA9IDA7IGJsb2NrWCA8IG51bUJsb2Nrc1g7IGJsb2NrWCsrKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJ5XCIgKyBibG9ja1kgKyBcIiB4XCIgKyBibG9ja1gpO1xuICAgICAgICAgICAgdGhpc0Jsb2NrV2lkdGggPSAoYmxvY2tYICE9PSBudW1CbG9ja3NYIC0gMSkgPyBtaWNyb0Jsb2NrU2l6ZSA6IGxhc3RCbG9ja1dpZHRoO1xuXG4gICAgICAgICAgICBvdXRQdHIgPSBibG9ja1kgKiB3aWR0aCAqIG1pY3JvQmxvY2tTaXplICsgYmxvY2tYICogbWljcm9CbG9ja1NpemU7XG4gICAgICAgICAgICBvdXRTdHJpZGUgPSB3aWR0aCAtIHRoaXNCbG9ja1dpZHRoO1xuXG4gICAgICAgICAgICBmb3IgKGlEaW0gPSAwOyBpRGltIDwgbnVtRGltczsgaURpbSsrKSB7XG4gICAgICAgICAgICAgIGlmIChudW1EaW1zID4gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1ByZXZEaW0gPSByZXN1bHRQaXhlbHM7XG4gICAgICAgICAgICAgICAgb3V0UHRyID0gYmxvY2tZICogd2lkdGggKiBtaWNyb0Jsb2NrU2l6ZSArIGJsb2NrWCAqIG1pY3JvQmxvY2tTaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVscyA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMuYnVmZmVyLCBudW1QaXhlbHMgKiBpRGltICogZGF0YVR5cGVTaXplLCBudW1QaXhlbHMpO1xuICAgICAgICAgICAgICAgIHpNYXggPSBoZWFkZXJJbmZvLm1heFZhbHVlc1tpRGltXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNQcmV2RGltID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBieXRlc0xlZnQgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHI7XG4gICAgICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCBNYXRoLm1pbigxMCwgYnl0ZXNMZWZ0KSk7XG4gICAgICAgICAgICAgIGJsb2NrID0ge307XG4gICAgICAgICAgICAgIGJsb2NrUHRyID0gMDtcbiAgICAgICAgICAgICAgaGVhZGVyQnl0ZSA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICAgICAgICAgIGJsb2NrUHRyKys7XG4gICAgICAgICAgICAgIGlzRGlmZkVuY29kaW5nID0gaGVhZGVySW5mby5maWxlVmVyc2lvbiA+PSA1ID8gaGVhZGVyQnl0ZSAmIDQgOiAwO1xuICAgICAgICAgICAgICBiaXRzNjcgPSAoaGVhZGVyQnl0ZSA+PiA2KSAmIDB4RkY7XG4gICAgICAgICAgICAgIHRlc3RDb2RlID0gKGhlYWRlckJ5dGUgPj4gMikgJiBmaWxlVmVyc2lvbkNoZWNrTnVtOyAgICAvLyB1c2UgYml0cyAyMzQ1IGZvciBpbnRlZ3JpdHkgY2hlY2tcbiAgICAgICAgICAgICAgaWYgKHRlc3RDb2RlICE9PSAoKChibG9ja1ggKiBtaWNyb0Jsb2NrU2l6ZSkgPj4gMykgJiBmaWxlVmVyc2lvbkNoZWNrTnVtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaW50ZWdyaXR5IGlzc3VlXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNEaWZmRW5jb2RpbmcgJiYgaURpbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaW50ZWdyaXR5IGlzc3VlXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBibG9ja0VuY29kaW5nID0gaGVhZGVyQnl0ZSAmIDM7XG4gICAgICAgICAgICAgIGlmIChibG9ja0VuY29kaW5nID4gMykge1xuICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBibG9jayBlbmNvZGluZyAoXCIgKyBibG9ja0VuY29kaW5nICsgXCIpXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2tFbmNvZGluZyA9PT0gMikgeyAvL2NvbnN0YW50IDBcbiAgICAgICAgICAgICAgICBpZiAoaXNEaWZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gcmVzdWx0UGl4ZWxzUHJldkRpbVtvdXRQdHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gcmVzdWx0UGl4ZWxzUHJldkRpbVtvdXRQdHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEuY291bnRlci5jb25zdGFudCsrO1xuICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrRW5jb2RpbmcgPT09IDApIHsgIC8vdW5jb21wcmVzc2VkXG4gICAgICAgICAgICAgICAgaWYgKGlzRGlmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UsIHNob3VsZCBub3QgaGFwcGVuXG4gICAgICAgICAgICAgICAgICB0aHJvdyBcImludGVncml0eSBpc3N1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLmNvdW50ZXIudW5jb21wcmVzc2VkKys7XG4gICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgbnVtQnl0ZXMgPSB0aGlzQmxvY2tIZWlnaHQgKiB0aGlzQmxvY2tXaWR0aCAqIGRhdGFUeXBlU2l6ZTtcbiAgICAgICAgICAgICAgICBieXRlc2xlZnQgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZGF0YS5wdHI7XG4gICAgICAgICAgICAgICAgbnVtQnl0ZXMgPSBudW1CeXRlcyA8IGJ5dGVzbGVmdCA/IG51bUJ5dGVzIDogYnl0ZXNsZWZ0O1xuICAgICAgICAgICAgICAgIC8vYml0IGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKChudW1CeXRlcyAlIGRhdGFUeXBlU2l6ZSkgPT09IDAgPyBudW1CeXRlcyA6IChudW1CeXRlcyArIGRhdGFUeXBlU2l6ZSAtIG51bUJ5dGVzICUgZGF0YVR5cGVTaXplKSk7XG4gICAgICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBudW1CeXRlcykpO1xuICAgICAgICAgICAgICAgIHJhd0RhdGEgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgICAgIHogPSAwO1xuICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyXSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7Ly9hbGwgdmFsaWRcbiAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSByYXdEYXRhW3orK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0geiAqIGRhdGFUeXBlU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgLy8xIG9yIDNcbiAgICAgICAgICAgICAgICBvZmZzZXRUeXBlID0gTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlVXNlZCgoaXNEaWZmRW5jb2RpbmcgJiYgaW1hZ2VUeXBlIDwgNikgPyA0IDogaW1hZ2VUeXBlLCBiaXRzNjcpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IExlcmMySGVscGVycy5nZXRPbmVQaXhlbChibG9jaywgYmxvY2tQdHIsIG9mZnNldFR5cGUsIHZpZXcpO1xuICAgICAgICAgICAgICAgIGJsb2NrUHRyICs9IExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUob2Zmc2V0VHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrRW5jb2RpbmcgPT09IDMpIC8vY29uc3RhbnQgb2Zmc2V0IHZhbHVlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgICBkYXRhLmNvdW50ZXIuY29uc3RhbnRvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgIC8veW91IGNhbiBkZWxldGUgdGhlIGZvbGxvd2luZyByZXN1bHRNYXNrIGNhc2UgaW4gZmF2b3Igb2YgcGVyZm9ybWFuY2UgYmVjYXVzZSB2YWwgaXMgY29uc3RhbnQgYW5kIHVzZXJzIHVzZSBub2RhdGEgbWFzaywgb3RoZXJ3aXNlIG5vZGF0YXZhbHVlIHBvc3QgcHJvY2Vzc2luZyBoYW5kbGVzIGl0IHRvby5cbiAgICAgICAgICAgICAgICAgIC8vd2hpbGUgdGhlIGFib3ZlIHN0YXRlbWVudCBpcyB0cnVlLCB3ZSdyZSBub3QgZG9pbmcgaXQgYXMgd2Ugd2FudCB0byBrZWVwIGludmFsaWQgcGl4ZWwgdmFsdWUgYXQgMCByYXRoZXIgdGhhbiBhcmJpdHJhcnkgdmFsdWVzXG4gICAgICAgICAgICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tbb3V0UHRyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyXSA9IGlzRGlmZkVuY29kaW5nID8gTWF0aC5taW4oek1heCwgcmVzdWx0UGl4ZWxzUHJldkRpbVtvdXRQdHJdICsgb2Zmc2V0KSA6IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0cisrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gaXNEaWZmRW5jb2RpbmcgPyBNYXRoLm1pbih6TWF4LCByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl0gKyBvZmZzZXQpIDogb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vYml0c3R1ZmYgZW5jb2RpbmcgaXMgM1xuICAgICAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICAgICAgICAvL2hlYXZ5IGxpZnRpbmdcbiAgICAgICAgICAgICAgICAgIExlcmMySGVscGVycy5kZWNvZGVCaXRzKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIsIG9mZnNldCwgaURpbSk7XG4gICAgICAgICAgICAgICAgICBibG9ja1B0ciA9IDA7XG4gICAgICAgICAgICAgICAgICAvLyBkdXBsaWNhdGUgY29kZSB0byBmYXZvciBwZXJmb3JtYW5jZSwgZGlmZiBlbmNvZGluZyBpcyBmb3IgbXVsdGlkaW1lbnNpb24gb25seVxuICAgICAgICAgICAgICAgICAgaWYgKGlzRGlmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBibG9ja0RhdGFCdWZmZXJbYmxvY2tQdHIrK10gKyByZXN1bHRQaXhlbHNQcmV2RGltW291dFB0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gYmxvY2tEYXRhQnVmZmVyW2Jsb2NrUHRyKytdICsgcmVzdWx0UGl4ZWxzUHJldkRpbVtvdXRQdHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1tvdXRQdHJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gYmxvY2tEYXRhQnVmZmVyW2Jsb2NrUHRyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0UHRyKys7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXNCbG9ja0hlaWdodDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IGJsb2NrRGF0YUJ1ZmZlcltibG9ja1B0cisrXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3N3YXAgZm9yIEJJUDogaXQncyBhbHdheXMgZWFzaWVyIGZvciBjbGllbnRzIHRvIGhhbmRsZSBCU1Egc28gd2Uga2VlcCBleGlzdGluZyBsb2dpYyBhbmQgaW50cm9kdWNlIGEgc3dhcCBoZXJlIHRvIG1pbmltemUgY2hhbmdlc1xuICAgICAgICBpZiAobnVtRGltcyA+IDEgJiYgIXVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IExlcmMySGVscGVycy5zd2FwRGltZW5zaW9uT3JkZXIoZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzLCBudW1QaXhlbHMsIG51bURpbXMsIE91dFBpeGVsVHlwZUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICAqICBwcml2YXRlIG1ldGhvZHMgKGhlbHBlciBtZXRob2RzKVxuICAgICAgKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIGZvcm1hdEZpbGVJbmZvOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgXCJmaWxlSWRlbnRpZmllclN0cmluZ1wiOiBkYXRhLmhlYWRlckluZm8uZmlsZUlkZW50aWZpZXJTdHJpbmcsXG4gICAgICAgICAgXCJmaWxlVmVyc2lvblwiOiBkYXRhLmhlYWRlckluZm8uZmlsZVZlcnNpb24sXG4gICAgICAgICAgXCJpbWFnZVR5cGVcIjogZGF0YS5oZWFkZXJJbmZvLmltYWdlVHlwZSxcbiAgICAgICAgICBcImhlaWdodFwiOiBkYXRhLmhlYWRlckluZm8uaGVpZ2h0LFxuICAgICAgICAgIFwid2lkdGhcIjogZGF0YS5oZWFkZXJJbmZvLndpZHRoLFxuICAgICAgICAgIFwibnVtVmFsaWRQaXhlbFwiOiBkYXRhLmhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCxcbiAgICAgICAgICBcIm1pY3JvQmxvY2tTaXplXCI6IGRhdGEuaGVhZGVySW5mby5taWNyb0Jsb2NrU2l6ZSxcbiAgICAgICAgICBcImJsb2JTaXplXCI6IGRhdGEuaGVhZGVySW5mby5ibG9iU2l6ZSxcbiAgICAgICAgICBcIm1heFpFcnJvclwiOiBkYXRhLmhlYWRlckluZm8ubWF4WkVycm9yLFxuICAgICAgICAgIFwicGl4ZWxUeXBlXCI6IExlcmMySGVscGVycy5nZXRQaXhlbFR5cGUoZGF0YS5oZWFkZXJJbmZvLmltYWdlVHlwZSksXG4gICAgICAgICAgXCJlb2ZPZmZzZXRcIjogZGF0YS5lb2ZPZmZzZXQsXG4gICAgICAgICAgXCJtYXNrXCI6IGRhdGEubWFzayA/IHtcbiAgICAgICAgICAgIFwibnVtQnl0ZXNcIjogZGF0YS5tYXNrLm51bUJ5dGVzXG4gICAgICAgICAgfSA6IG51bGwsXG4gICAgICAgICAgXCJwaXhlbHNcIjoge1xuICAgICAgICAgICAgXCJudW1CbG9ja3NYXCI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1gsXG4gICAgICAgICAgICBcIm51bUJsb2Nrc1lcIjogZGF0YS5waXhlbHMubnVtQmxvY2tzWSxcbiAgICAgICAgICAgIC8vXCJudW1CeXRlc1wiOiBkYXRhLnBpeGVscy5udW1CeXRlcyxcbiAgICAgICAgICAgIFwibWF4VmFsdWVcIjogZGF0YS5oZWFkZXJJbmZvLnpNYXgsXG4gICAgICAgICAgICBcIm1pblZhbHVlXCI6IGRhdGEuaGVhZGVySW5mby56TWluLFxuICAgICAgICAgICAgXCJub0RhdGFWYWx1ZVwiOiBkYXRhLm5vRGF0YVZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgY29uc3RydWN0Q29uc3RhbnRTdXJmYWNlOiBmdW5jdGlvbihkYXRhLCB1c2VCU1FGb3JPdXRwdXREaW0pIHtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGEuaGVhZGVySW5mby56TWF4O1xuICAgICAgICB2YXIgdmFsTWluID0gZGF0YS5oZWFkZXJJbmZvLnpNaW47XG4gICAgICAgIHZhciBtYXhWYWx1ZXMgPSBkYXRhLmhlYWRlckluZm8ubWF4VmFsdWVzO1xuICAgICAgICB2YXIgbnVtRGltcyA9IGRhdGEuaGVhZGVySW5mby5udW1EaW1zO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gZGF0YS5oZWFkZXJJbmZvLmhlaWdodCAqIGRhdGEuaGVhZGVySW5mby53aWR0aDtcbiAgICAgICAgdmFyIGkgPSAwLCBrID0gMCwgblN0YXJ0ID0gMDtcbiAgICAgICAgdmFyIG1hc2sgPSBkYXRhLnBpeGVscy5yZXN1bHRNYXNrO1xuICAgICAgICB2YXIgcmVzdWx0UGl4ZWxzID0gZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzO1xuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgIGlmIChudW1EaW1zID4gMSkge1xuICAgICAgICAgICAgaWYgKHVzZUJTUUZvck91dHB1dERpbSkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgblN0YXJ0ID0gaSAqIG51bVBpeGVscztcbiAgICAgICAgICAgICAgICB2YWwgPSBtYXhWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbblN0YXJ0ICsga10gPSB2YWw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgblN0YXJ0ID0gayAqIG51bURpbXM7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tuU3RhcnQgKyBudW1EaW1zXSA9IG1heFZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1hc2tba10pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKG51bURpbXMgPiAxICYmIHZhbE1pbiAhPT0gdmFsKSB7XG4gICAgICAgICAgICBpZiAodXNlQlNRRm9yT3V0cHV0RGltKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuU3RhcnQgPSBpICogbnVtUGl4ZWxzO1xuICAgICAgICAgICAgICAgIHZhbCA9IG1heFZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tuU3RhcnQgKyBrXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBuU3RhcnQgPSBrICogbnVtRGltcztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbblN0YXJ0ICsgaV0gPSBtYXhWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVscyAqIG51bURpbXM7IGsrKykge1xuICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG5cbiAgICAgIGdldERhdGFUeXBlQXJyYXk6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHRwO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgdHAgPSBJbnQ4QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgdHAgPSBVaW50OEFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgICB0cCA9IEludDE2QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICB0cCA9IFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdHAgPSBJbnQzMkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdHAgPSBVaW50MzJBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHRwID0gRmxvYXQzMkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgdHAgPSBGbG9hdDY0QXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHAgPSBGbG9hdDMyQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRwO1xuICAgICAgfSxcblxuICAgICAgZ2V0UGl4ZWxUeXBlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciB0cDtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSAwOiAvL2NoYXJcbiAgICAgICAgICAgIHRwID0gXCJTOFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAvL2J5dGVcbiAgICAgICAgICAgIHRwID0gXCJVOFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgICB0cCA9IFwiUzE2XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICB0cCA9IFwiVTE2XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0cCA9IFwiUzMyXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0cCA9IFwiVTMyXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB0cCA9IFwiRjMyXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICB0cCA9IFwiRjY0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHAgPSBcIkYzMlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cDtcbiAgICAgIH0sXG5cbiAgICAgIGlzVmFsaWRQaXhlbFZhbHVlOiBmdW5jdGlvbih0LCB2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc1ZhbGlkO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMTI4ICYmIHZhbCA8PSAxMjc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZSAgKHVuc2lnbmVkIGNoYXIpXG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IDAgJiYgdmFsIDw9IDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogLy9zaG9ydFxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMzI3NjggJiYgdmFsIDw9IDMyNzY3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydFxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAwICYmIHZhbCA8PSA2NTUzNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDogLy9pbnQgMzJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gLTIxNDc0ODM2NDggJiYgdmFsIDw9IDIxNDc0ODM2NDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6IC8vdWluaXQgMzJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gMCAmJiB2YWwgPD0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gLTMuNDAyNzk5OTM4NzkwMTQ4NGUrMzggJiYgdmFsIDw9IDMuNDAyNzk5OTM4NzkwMTQ4NGUrMzg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IC0xLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCAmJiB2YWwgPD0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcblxuICAgICAgZ2V0RGF0YVR5cGVTaXplOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSAwOiAvL3VieXRlXG4gICAgICAgICAgY2FzZSAxOiAvL2J5dGVcbiAgICAgICAgICAgIHMgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydFxuICAgICAgICAgICAgcyA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHMgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcyA9IDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LFxuXG4gICAgICBnZXREYXRhVHlwZVVzZWQ6IGZ1bmN0aW9uKGR0LCB0Yykge1xuICAgICAgICB2YXIgdCA9IGR0O1xuICAgICAgICBzd2l0Y2ggKGR0KSB7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgY2FzZSA0OiAvL2xvbmdcbiAgICAgICAgICAgIHQgPSBkdCAtIHRjO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydFxuICAgICAgICAgIGNhc2UgNTogLy91bG9uZ1xuICAgICAgICAgICAgdCA9IGR0IC0gMiAqIHRjO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OiAvL2Zsb2F0XG4gICAgICAgICAgICBpZiAoMCA9PT0gdGMpIHtcbiAgICAgICAgICAgICAgdCA9IGR0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoMSA9PT0gdGMpIHtcbiAgICAgICAgICAgICAgdCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdCA9IDE7Ly9ieXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6IC8vZG91YmxlXG4gICAgICAgICAgICBpZiAoMCA9PT0gdGMpIHtcbiAgICAgICAgICAgICAgdCA9IGR0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHQgPSBkdCAtIDIgKiB0YyArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdCA9IGR0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuXG4gICAgICBnZXRPbmVQaXhlbDogZnVuY3Rpb24oYmxvY2ssIGJsb2NrUHRyLCBvZmZzZXRUeXBlLCB2aWV3KSB7XG4gICAgICAgIHZhciB0ZW1wID0gMDtcbiAgICAgICAgc3dpdGNoIChvZmZzZXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSAwOiAvL2NoYXJcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEludDgoYmxvY2tQdHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAvL2J5dGVcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldFVpbnQ4KGJsb2NrUHRyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEludDE2KGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldFVpbnQxNihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRJbnQzMihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRVSW50MzIoYmxvY2tQdHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0RmxvYXQzMihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRGbG9hdDY0KGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAoXCJ0aGUgZGVjb2RlciBkb2VzIG5vdCB1bmRlcnN0YW5kIHRoaXMgcGl4ZWwgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcDtcbiAgICAgIH0sXG5cbiAgICAgIHN3YXBEaW1lbnNpb25PcmRlcjogZnVuY3Rpb24ocGl4ZWxzLCBudW1QaXhlbHMsIG51bURpbXMsIE91dFBpeGVsVHlwZUFycmF5LCBpbnB1dElzQklQKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiA9IDAsIGlEaW0gPSAwLCB0ZW1wID0gMCwgc3dhcCA9IHBpeGVscztcbiAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgc3dhcCA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShudW1QaXhlbHMgKiBudW1EaW1zKTtcbiAgICAgICAgICBpZiAoaW5wdXRJc0JJUCkge1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8bnVtUGl4ZWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgdGVtcCA9IGk7XG4gICAgICAgICAgICAgIGZvciAoaURpbT0wOyBpRGltIDwgbnVtRGltczsgaURpbSsrLCB0ZW1wICs9IG51bVBpeGVscykge1xuICAgICAgICAgICAgICAgIHN3YXBbdGVtcF0gPSBwaXhlbHNbaisrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8bnVtUGl4ZWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgdGVtcCA9IGk7XG4gICAgICAgICAgICAgIGZvciAoaURpbT0wOyBpRGltIDwgbnVtRGltczsgaURpbSsrLCB0ZW1wICs9IG51bVBpeGVscykge1xuICAgICAgICAgICAgICAgIHN3YXBbaisrXSA9IHBpeGVsc1t0ZW1wXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3dhcDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICpwcml2YXRlIGNsYXNzIGZvciBhIHRyZWUgbm9kZS4gSHVmZm1hbiBjb2RlIGlzIGluIExlcmMySGVscGVyc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIFRyZWVOb2RlID0gZnVuY3Rpb24odmFsLCBsZWZ0LCByaWdodCkge1xuICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH07XG5cbiAgICB2YXIgTGVyYzJEZWNvZGUgPSB7XG4gICAgICAvKlxuICAgICAgKiAqKioqKioqKnJlbW92ZWQgb3B0aW9ucyBjb21wYXJlZCB0byBMRVJDMS4gV2UgY2FuIGJyaW5nIHNvbWUgb2YgdGhlbSBiYWNrIGlmIG5lZWRlZC5cbiAgICAgICAqIHJlbW92ZWQgcGl4ZWwgdHlwZS4gTEVSQzIgaXMgdHlwZWQgYW5kIGRvZXNuJ3QgcmVxdWlyZSB1c2VyIHRvIGdpdmUgcGl4ZWwgdHlwZVxuICAgICAgICogY2hhbmdlZCBlbmNvZGVkTWFza0RhdGEgdG8gbWFza0RhdGEuIExFUkMyICdzIGpzIHZlcnNpb24gbWFrZSBpdCBmYXN0ZXIgdG8gdXNlIG1hc2tEYXRhIGRpcmVjdGx5LlxuICAgICAgICogcmVtb3ZlZCByZXR1cm5NYXNrLiBtYXNrIGlzIHVzZWQgYnkgTEVSQzIgaW50ZXJuYWxseSBhbmQgaXMgY29zdCBmcmVlLiBJbiBjYXNlIG9mIHVzZXIgaW5wdXQgbWFzaywgaXQncyByZXR1cm5lZCBhcyB3ZWxsIGFuZCBoYXMgbmVnbGlibGUgY29zdC5cbiAgICAgICAqIHJlbW92ZWQgbm9kYXRhdmFsdWUuIEJlY2F1c2UgTEVSQzIgcGl4ZWxzIGFyZSB0eXBlZCwgbm9kYXRhdmFsdWUgd2lsbCBzYWNyaWZ5IGEgdXNlZnVsIHZhbHVlIGZvciBtYW55IHR5cGVzICg4Yml0LCAxNmJpdCkgZXRjLFxuICAgICAgICogICAgICAgdXNlciBoYXMgdG8gYmUga25vd2xlZGdhYmxlIGVub3VnaCBhYm91dCByYXN0ZXIgYW5kIHRoZWlyIGRhdGEgdG8gYXZvaWQgdXNhYmlsaXR5IGlzc3Vlcy4gc28gbm9kYXRhIHZhbHVlIGlzIHNpbXBseSByZW1vdmVkIG5vdy5cbiAgICAgICAqICAgICAgIFdlIGNhbiBhZGQgaXQgYmFjayBsYXRlciBpZiB0aGVpcidzIGEgY2xlYXIgcmVxdWlyZW1lbnQuXG4gICAgICAgKiByZW1vdmVkIGVuY29kZWRNYXNrLiBUaGlzIG9wdGlvbiB3YXMgbm90IGltcGxlbWVudGVkIGluIExlcmNEZWNvZGUuIEl0IGNhbiBiZSBkb25lIGFmdGVyIGRlY29kaW5nIChsZXNzIGVmZmljaWVudClcbiAgICAgICAqIHJlbW92ZWQgY29tcHV0ZVVzZWRCaXREZXB0aHMuXG4gICAgICAgKlxuICAgICAgICpcbiAgICAgICAqIHJlc3BvbnNlIGNoYW5nZXMgY29tcGFyZWQgdG8gTEVSQzFcbiAgICAgICAqIDEuIGVuY29kZWRNYXNrRGF0YSBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgKiAyLiBub0RhdGFWYWx1ZSBpcyBvcHRpb25hbCAocmV0dXJucyBvbmx5IGlmIHVzZXIncyBub0RhdGFWYWx1ZSBpcyB3aXRoIGluIHRoZSB2YWxpZCBkYXRhIHR5cGUgcmFuZ2UpXG4gICAgICAgKiAzLiBtYXNrRGF0YSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgICAqL1xuICAgICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICAqICBwdWJsaWMgcHJvcGVydGllc1xuICAgICAgKioqKioqKioqKioqKioqKioqL1xuICAgICAgLy9IVUZGTUFOX0xVVF9CSVRTX01BWDogMTIsIC8vdXNlIDJeMTIgbHV0LCBub3QgY29uZmlndXJhYmxlXG5cbiAgICAgIC8qKioqKioqKioqKioqKioqKlxuICAgICAgKiAgcHVibGljIG1ldGhvZHNcbiAgICAgICoqKioqKioqKioqKioqKioqL1xuXG4gICAgICAvKipcbiAgICAgICAqIERlY29kZSBhIExFUkMyIGJ5dGUgc3RyZWFtIGFuZCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgYW5kIG9wdGlvbmFsIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGlucHV0IFRoZSBMRVJDIGlucHV0IGJ5dGUgc3RyZWFtXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgRGVjb2Rpbmcgb3B0aW9uc1xuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmlucHV0T2Zmc2V0XSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgaW4gdGhlIGlucHV0IGJ5dGUgc3RyZWFtLiBBIHZhbGlkIExFUkMgZmlsZSBpcyBleHBlY3RlZCBhdCB0aGF0IHBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldHVybkZpbGVJbmZvXSBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBhIGZpbGVJbmZvIHByb3BlcnR5IHRoYXQgY29udGFpbnMgbWV0YWRhdGEgb2J0YWluZWQgZnJvbSB0aGUgTEVSQyBoZWFkZXJzIGFuZCB0aGUgZGVjb2RpbmcgcHJvY2Vzc1xuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXR1cm5QaXhlbEludGVybGVhdmVkRGltc10gIElmIHRydWUsIHJldHVybmVkIGRpbWVuc2lvbnMgYXJlIHBpeGVsLWludGVybGVhdmVkLCBhLmsuYSBbcDFfZGltMCwgcDFfZGltMSwgcDFfZGltbiwgcDJfZGltMC4uLl0sIGRlZmF1bHQgaXMgW3AxX2RpbTAsIHAyX2RpbTAsIC4uLiwgcDFfZGltMSwgcDJfZGltMS4uLl1cbiAgICAgICAqL1xuICAgICAgZGVjb2RlOiBmdW5jdGlvbigvKmJ5dGUgYXJyYXkqLyBpbnB1dCwgLypvYmplY3QqLyBvcHRpb25zKSB7XG4gICAgICAgIC8vY3VycmVudGx5IHRoZXJlJ3MgYSBidWcgaW4gdGhlIHNwYXJzZSBhcnJheSwgc28gcGxlYXNlIGRvIG5vdCBzZXQgdG8gZmFsc2VcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBub0RhdGFWYWx1ZSA9IG9wdGlvbnMubm9EYXRhVmFsdWU7XG5cbiAgICAgICAgLy9pbml0aWFsaXplXG4gICAgICAgIHZhciBpID0gMCwgZGF0YSA9IHt9O1xuICAgICAgICBkYXRhLnB0ciA9IG9wdGlvbnMuaW5wdXRPZmZzZXQgfHwgMDtcbiAgICAgICAgZGF0YS5waXhlbHMgPSB7fTtcblxuICAgICAgICAvLyBGaWxlIGhlYWRlclxuICAgICAgICBpZiAoIUxlcmMySGVscGVycy5yZWFkSGVhZGVySW5mbyhpbnB1dCwgZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVhZGVySW5mbyA9IGRhdGEuaGVhZGVySW5mbztcbiAgICAgICAgdmFyIGZpbGVWZXJzaW9uID0gaGVhZGVySW5mby5maWxlVmVyc2lvbjtcbiAgICAgICAgdmFyIE91dFBpeGVsVHlwZUFycmF5ID0gTGVyYzJIZWxwZXJzLmdldERhdGFUeXBlQXJyYXkoaGVhZGVySW5mby5pbWFnZVR5cGUpO1xuXG4gICAgICAgIC8vIHZlcnNpb24gY2hlY2tcbiAgICAgICAgaWYgKGZpbGVWZXJzaW9uID4gNSkge1xuICAgICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgbGVyYyB2ZXJzaW9uIDIuXCIgKyBmaWxlVmVyc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hc2sgSGVhZGVyXG4gICAgICAgIExlcmMySGVscGVycy5yZWFkTWFzayhpbnB1dCwgZGF0YSk7XG4gICAgICAgIGlmIChoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgIT09IGhlYWRlckluZm8ud2lkdGggKiBoZWFkZXJJbmZvLmhlaWdodCAmJiAhZGF0YS5waXhlbHMucmVzdWx0TWFzaykge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdE1hc2sgPSBvcHRpb25zLm1hc2tEYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG51bVBpeGVscyA9IGhlYWRlckluZm8ud2lkdGggKiBoZWFkZXJJbmZvLmhlaWdodDtcbiAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KG51bVBpeGVscyAqIGhlYWRlckluZm8ubnVtRGltcyk7XG5cbiAgICAgICAgZGF0YS5jb3VudGVyID0ge1xuICAgICAgICAgIG9uZXN3ZWVwOiAwLFxuICAgICAgICAgIHVuY29tcHJlc3NlZDogMCxcbiAgICAgICAgICBsdXQ6IDAsXG4gICAgICAgICAgYml0c3R1ZmZlcjogMCxcbiAgICAgICAgICBjb25zdGFudDogMCxcbiAgICAgICAgICBjb25zdGFudG9mZnNldDogMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdXNlQlNRRm9yT3V0cHV0RGltID0gIW9wdGlvbnMucmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXM7XG4gICAgICAgIGlmIChoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgIT09IDApIHtcbiAgICAgICAgICAvL25vdCB0ZXN0ZWRcbiAgICAgICAgICBpZiAoaGVhZGVySW5mby56TWF4ID09PSBoZWFkZXJJbmZvLnpNaW4pIC8vY29uc3RhbnQgc3VyZmFjZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIExlcmMySGVscGVycy5jb25zdHJ1Y3RDb25zdGFudFN1cmZhY2UoZGF0YSwgdXNlQlNRRm9yT3V0cHV0RGltKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZmlsZVZlcnNpb24gPj0gNCAmJiBMZXJjMkhlbHBlcnMuY2hlY2tNaW5NYXhSYW5nZXMoaW5wdXQsIGRhdGEpKSB7XG4gICAgICAgICAgICBMZXJjMkhlbHBlcnMuY29uc3RydWN0Q29uc3RhbnRTdXJmYWNlKGRhdGEsIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCAyKTtcbiAgICAgICAgICAgIHZhciBiUmVhZERhdGFPbmVTd2VlcCA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICAgICAgICBkYXRhLnB0cisrO1xuICAgICAgICAgICAgaWYgKGJSZWFkRGF0YU9uZVN3ZWVwKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcIk9uZVN3ZWVwXCIpO1xuICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZERhdGFPbmVTd2VlcChpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy9sZXJjMi4xOiAvL2JpdHN0dWZmaW5nICsgbHV0XG4gICAgICAgICAgICAgIC8vbGVyYzIuMjogLy9iaXRzdHVmZmluZyArIGx1dCArIGh1ZmZtYW5cbiAgICAgICAgICAgICAgLy9sZXJjMi4zOiBuZXcgYml0c3R1ZmZlclxuICAgICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPiAxICYmIGhlYWRlckluZm8uaW1hZ2VUeXBlIDw9IDEgJiYgTWF0aC5hYnMoaGVhZGVySW5mby5tYXhaRXJyb3IgLSAwLjUpIDwgMC4wMDAwMSkge1xuICAgICAgICAgICAgICAgIC8vdGhpcyBpcyAyLnggcGx1cyA4IGJpdCAodW5zaWduZWQgYW5kIHNpZ25lZCkgZGF0YSwgcG9zc2libGl0eSBvZiBIdWZmbWFuXG4gICAgICAgICAgICAgICAgdmFyIGZsYWdIdWZmbWFuID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgICAgICAgICAgICBkYXRhLnB0cisrO1xuICAgICAgICAgICAgICAgIGRhdGEuZW5jb2RlTW9kZSA9IGZsYWdIdWZmbWFuO1xuICAgICAgICAgICAgICAgIGlmIChmbGFnSHVmZm1hbiA+IDIgfHwgKGZpbGVWZXJzaW9uIDwgNCAmJiBmbGFnSHVmZm1hbiA+IDEpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgSHVmZm1hbiBmbGFnIFwiICsgZmxhZ0h1ZmZtYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFnSHVmZm1hbikgey8vMSAtIGRlbHRhIEh1ZmZtYW4sIDIgLSBIdWZmbWFuXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSHVmZm1hblwiKTtcbiAgICAgICAgICAgICAgICAgIExlcmMySGVscGVycy5yZWFkSHVmZm1hbihpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRpbGVzXCIpO1xuICAgICAgICAgICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRUaWxlcyhpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAvL2xlcmMyLnggbm9uLTggYml0IGRhdGFcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVGlsZXNcIik7XG4gICAgICAgICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRUaWxlcyhpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXksIHVzZUJTUUZvck91dHB1dERpbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmVvZk9mZnNldCA9IGRhdGEucHRyO1xuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRPZmZzZXQpIHtcbiAgICAgICAgICBkaWZmID0gZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplICsgb3B0aW9ucy5pbnB1dE9mZnNldCAtIGRhdGEucHRyO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+PSAxKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJpbmNvcnJlY3QgZW9mOiBkYXRhcHRyIFwiICsgZGF0YS5wdHIgKyBcIiBvZmZzZXQgXCIgKyBvcHRpb25zLmlucHV0T2Zmc2V0ICsgXCIgYmxvYnNpemUgXCIgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyBcIiBkaWZmOiBcIiArIGRpZmYpO1xuICAgICAgICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBvcHRpb25zLmlucHV0T2Zmc2V0ICsgZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkaWZmID0gZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplIC0gZGF0YS5wdHI7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID49IDEpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImluY29ycmVjdCBmaXJzdCBiYW5kIGVvZjogZGF0YXB0ciBcIiArIGRhdGEucHRyICsgXCIgYmxvYnNpemUgXCIgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyBcIiBkaWZmOiBcIiArIGRpZmYpO1xuICAgICAgICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBkYXRhLmhlYWRlckluZm8uYmxvYlNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICB3aWR0aDogaGVhZGVySW5mby53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlYWRlckluZm8uaGVpZ2h0LFxuICAgICAgICAgIHBpeGVsRGF0YTogZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzLFxuICAgICAgICAgIG1pblZhbHVlOiBoZWFkZXJJbmZvLnpNaW4sXG4gICAgICAgICAgbWF4VmFsdWU6IGhlYWRlckluZm8uek1heCxcbiAgICAgICAgICB2YWxpZFBpeGVsQ291bnQ6IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCxcbiAgICAgICAgICBkaW1Db3VudDogaGVhZGVySW5mby5udW1EaW1zLFxuICAgICAgICAgIGRpbVN0YXRzOiB7XG4gICAgICAgICAgICBtaW5WYWx1ZXM6IGhlYWRlckluZm8ubWluVmFsdWVzLFxuICAgICAgICAgICAgbWF4VmFsdWVzOiBoZWFkZXJJbmZvLm1heFZhbHVlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFza0RhdGE6IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2tcbiAgICAgICAgICAvL25vRGF0YVZhbHVlOiBub0RhdGFWYWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vd2Ugc2hvdWxkIHJlbW92ZSB0aGlzIGlmIHRoZXJlJ3Mgbm8gZXhpc3RpbmcgY2xpZW50XG4gICAgICAgIC8vb3B0aW9uYWwgbm9EYXRhVmFsdWUgcHJvY2Vzc2luZywgaXQncyB1c2VyJ3MgcmVzcG9uc2libGl0eVxuICAgICAgICBpZiAoZGF0YS5waXhlbHMucmVzdWx0TWFzayAmJiBMZXJjMkhlbHBlcnMuaXNWYWxpZFBpeGVsVmFsdWUoaGVhZGVySW5mby5pbWFnZVR5cGUsIG5vRGF0YVZhbHVlKSkge1xuICAgICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUGl4ZWxzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbWFza1tpXSkge1xuICAgICAgICAgICAgICByZXN1bHQucGl4ZWxEYXRhW2ldID0gbm9EYXRhVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5ub0RhdGFWYWx1ZSA9IG5vRGF0YVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEubm9EYXRhVmFsdWUgPSBub0RhdGFWYWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmV0dXJuRmlsZUluZm8pIHtcbiAgICAgICAgICByZXN1bHQuZmlsZUluZm8gPSBMZXJjMkhlbHBlcnMuZm9ybWF0RmlsZUluZm8oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG5cbiAgICAgIGdldEJhbmRDb3VudDogZnVuY3Rpb24oLypieXRlIGFycmF5Ki8gaW5wdXQpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgICB0ZW1wLnB0ciA9IDA7XG4gICAgICAgIHRlbXAucGl4ZWxzID0ge307XG4gICAgICAgIHdoaWxlIChpIDwgaW5wdXQuYnl0ZUxlbmd0aCAtIDU4KSB7XG4gICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRIZWFkZXJJbmZvKGlucHV0LCB0ZW1wKTtcbiAgICAgICAgICBpICs9IHRlbXAuaGVhZGVySW5mby5ibG9iU2l6ZTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIHRlbXAucHRyID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBMZXJjMkRlY29kZTtcbiAgfSkoKTtcblxuICB2YXIgaXNQbGF0Zm9ybUxpdHRsZUVuZGlhbiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGEpO1xuICAgIHZhciBjID0gbmV3IFVpbnQzMkFycmF5KGEpO1xuICAgIGNbMF0gPSAxO1xuICAgIHJldHVybiBiWzBdID09PSAxO1xuICB9KSgpO1xuXG4gIHZhciBMZXJjID0ge1xuICAgIC8qKioqKioqKioqKip3cmFwcGVyKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgZm9yIGRlY29kaW5nIGJvdGggTEVSQzEgYW5kIExFUkMyIGJ5dGUgc3RyZWFtcyBjYXBhYmxlIG9mIGhhbmRsaW5nIG11bHRpYmFuZCBwaXhlbCBibG9ja3MgZm9yIHZhcmlvdXMgcGl4ZWwgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAYWxpYXMgbW9kdWxlOkxlcmNcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBpbnB1dCBUaGUgTEVSQyBpbnB1dCBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGRlY29kaW5nIG9wdGlvbnMgYmVsb3cgYXJlIG9wdGlvbmFsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbnB1dE9mZnNldF0gVGhlIG51bWJlciBvZiBieXRlcyB0byBza2lwIGluIHRoZSBpbnB1dCBieXRlIHN0cmVhbS4gQSB2YWxpZCBMZXJjIGZpbGUgaXMgZXhwZWN0ZWQgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGl4ZWxUeXBlXSAoTEVSQzEgb25seSkgRGVmYXVsdCB2YWx1ZSBpcyBGMzIuIFZhbGlkIHBpeGVsIHR5cGVzIGZvciBpbnB1dCBhcmUgVTgvUzgvUzE2L1UxNi9TMzIvVTMyL0YzMi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubm9EYXRhVmFsdWVdIChMRVJDMSBvbmx5KS4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSByZXR1cm5lZCBtYXNrIGluc3RlYWQgb2Ygc2V0dGluZyB0aGlzIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXNdIChuRGltIExFUkMyIG9ubHkpIElmIHRydWUsIHJldHVybmVkIGRpbWVuc2lvbnMgYXJlIHBpeGVsLWludGVybGVhdmVkLCBhLmsuYSBbcDFfZGltMCwgcDFfZGltMSwgcDFfZGltbiwgcDJfZGltMC4uLl0sIGRlZmF1bHQgaXMgW3AxX2RpbTAsIHAyX2RpbTAsIC4uLiwgcDFfZGltMSwgcDJfZGltMS4uLl1cbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoLCBoZWlnaHQsIHBpeGVscywgcGl4ZWxUeXBlLCBtYXNrLCBzdGF0aXN0aWNzfX1cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiBkZWNvZGVkIGltYWdlLlxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZGVjb2RlZCBpbWFnZS5cbiAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IHBpeGVscyBbYmFuZDEsIGJhbmQyLCDigKZdIEVhY2ggYmFuZCBpcyBhIHR5cGVkIGFycmF5IG9mIHdpZHRoKmhlaWdodC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwaXhlbFR5cGUgVGhlIHR5cGUgb2YgcGl4ZWxzIHJlcHJlc2VudGVkIGluIHRoZSBvdXRwdXQuXG4gICAgICAgKiBAcHJvcGVydHkge21hc2t9IG1hc2sgVHlwZWQgYXJyYXkgd2l0aCBhIHNpemUgb2Ygd2lkdGgqaGVpZ2h0LCBvciBudWxsIGlmIGFsbCBwaXhlbHMgYXJlIHZhbGlkLlxuICAgICAgICogQHByb3BlcnR5IHthcnJheX0gc3RhdGlzdGljcyBbc3RhdGlzdGljc19iYW5kMSwgc3RhdGlzdGljc19iYW5kMiwg4oCmXSBFYWNoIGVsZW1lbnQgaXMgYSBzdGF0aXN0aWNzIG9iamVjdCByZXByZXNlbnRpbmcgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgKiovXG4gICAgZGVjb2RlOiBmdW5jdGlvbihlbmNvZGVkRGF0YSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFpc1BsYXRmb3JtTGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIHRocm93IFwiQmlnIGVuZGlhbiBzeXN0ZW0gaXMgbm90IHN1cHBvcnRlZC5cIjtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIGlucHV0T2Zmc2V0ID0gb3B0aW9ucy5pbnB1dE9mZnNldCB8fCAwO1xuICAgICAgdmFyIGZpbGVJZFZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkRGF0YSwgaW5wdXRPZmZzZXQsIDEwKTtcbiAgICAgIHZhciBmaWxlSWRlbnRpZmllclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZmlsZUlkVmlldyk7XG4gICAgICB2YXIgbGVyYywgbWFqb3JWZXJzaW9uO1xuICAgICAgaWYgKGZpbGVJZGVudGlmaWVyU3RyaW5nLnRyaW0oKSA9PT0gXCJDbnRaSW1hZ2VcIikge1xuICAgICAgICBsZXJjID0gTGVyY0RlY29kZTtcbiAgICAgICAgbWFqb3JWZXJzaW9uID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZpbGVJZGVudGlmaWVyU3RyaW5nLnN1YnN0cmluZygwLCA1KSA9PT0gXCJMZXJjMlwiKSB7XG4gICAgICAgIGxlcmMgPSBMZXJjMkRlY29kZTtcbiAgICAgICAgbWFqb3JWZXJzaW9uID0gMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZmlsZSBpZGVudGlmaWVyIHN0cmluZzogXCIgKyBmaWxlSWRlbnRpZmllclN0cmluZztcbiAgICAgIH1cblxuICAgICAgdmFyIGlQbGFuZSA9IDAsIGVvZiA9IGVuY29kZWREYXRhLmJ5dGVMZW5ndGggLSAxMCwgZW5jb2RlZE1hc2tEYXRhLCBiYW5kTWFza3MgPSBbXSwgYmFuZE1hc2ssIG1hc2tEYXRhO1xuICAgICAgdmFyIGRlY29kZWRQaXhlbEJsb2NrID0ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBwaXhlbHM6IFtdLFxuICAgICAgICBwaXhlbFR5cGU6IG9wdGlvbnMucGl4ZWxUeXBlLFxuICAgICAgICBtYXNrOiBudWxsLFxuICAgICAgICBzdGF0aXN0aWNzOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciB1bmlxdWVCYW5kTWFza0NvdW50ID0gMDtcblxuICAgICAgd2hpbGUgKGlucHV0T2Zmc2V0IDwgZW9mKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBsZXJjLmRlY29kZShlbmNvZGVkRGF0YSwge1xuICAgICAgICAgIGlucHV0T2Zmc2V0OiBpbnB1dE9mZnNldCwvL2ZvciBib3RoIGxlcmMxIGFuZCBsZXJjMlxuICAgICAgICAgIGVuY29kZWRNYXNrRGF0YTogZW5jb2RlZE1hc2tEYXRhLC8vbGVyYzEgb25seVxuICAgICAgICAgIG1hc2tEYXRhOiBtYXNrRGF0YSwvL2xlcmMyIG9ubHlcbiAgICAgICAgICByZXR1cm5NYXNrOiBpUGxhbmUgPT09IDAgPyB0cnVlIDogZmFsc2UsLy9sZXJjMSBvbmx5XG4gICAgICAgICAgcmV0dXJuRW5jb2RlZE1hc2s6IGlQbGFuZSA9PT0gMCA/IHRydWUgOiBmYWxzZSwvL2xlcmMxIG9ubHlcbiAgICAgICAgICByZXR1cm5GaWxlSW5mbzogdHJ1ZSwvL2ZvciBib3RoIGxlcmMxIGFuZCBsZXJjMlxuICAgICAgICAgIHJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zOiBvcHRpb25zLnJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zLC8vZm9yIG5kaW0gbGVyYzIgb25seVxuICAgICAgICAgIHBpeGVsVHlwZTogb3B0aW9ucy5waXhlbFR5cGUgfHwgbnVsbCwvL2xlcmMxIG9ubHlcbiAgICAgICAgICBub0RhdGFWYWx1ZTogb3B0aW9ucy5ub0RhdGFWYWx1ZSB8fCBudWxsLy9sZXJjMSBvbmx5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlucHV0T2Zmc2V0ID0gcmVzdWx0LmZpbGVJbmZvLmVvZk9mZnNldDtcbiAgICAgICAgbWFza0RhdGEgPSByZXN1bHQubWFza0RhdGE7Ly9sZXJjMlxuICAgICAgICBpZiAoaVBsYW5lID09PSAwKSB7XG4gICAgICAgICAgZW5jb2RlZE1hc2tEYXRhID0gcmVzdWx0LmVuY29kZWRNYXNrRGF0YTsvL2xlcmMxXG4gICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2sud2lkdGggPSByZXN1bHQud2lkdGg7XG4gICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2suaGVpZ2h0ID0gcmVzdWx0LmhlaWdodDtcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5kaW1Db3VudCA9IHJlc3VsdC5kaW1Db3VudCB8fCAxO1xuICAgICAgICAgIC8vZGVjb2RlZFBpeGVsQmxvY2suZGltU3RhdHMgPSBkZWNvZGVkUGl4ZWxCbG9jay5kaW1TdGF0cztcbiAgICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5waXhlbFR5cGUgPSByZXN1bHQucGl4ZWxUeXBlIHx8IHJlc3VsdC5maWxlSW5mby5waXhlbFR5cGU7XG4gICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2subWFzayA9IG1hc2tEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYWpvclZlcnNpb24gPiAxKSB7XG4gICAgICAgICAgaWYgKG1hc2tEYXRhKSB7XG4gICAgICAgICAgICBiYW5kTWFza3MucHVzaChtYXNrRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuZmlsZUluZm8ubWFzayAmJiByZXN1bHQuZmlsZUluZm8ubWFzay5udW1CeXRlcyA+IDApIHtcbiAgICAgICAgICAgIHVuaXF1ZUJhbmRNYXNrQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpUGxhbmUrKztcbiAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2sucGl4ZWxzLnB1c2gocmVzdWx0LnBpeGVsRGF0YSk7XG4gICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLnN0YXRpc3RpY3MucHVzaCh7XG4gICAgICAgICAgbWluVmFsdWU6IHJlc3VsdC5taW5WYWx1ZSxcbiAgICAgICAgICBtYXhWYWx1ZTogcmVzdWx0Lm1heFZhbHVlLFxuICAgICAgICAgIG5vRGF0YVZhbHVlOiByZXN1bHQubm9EYXRhVmFsdWUsXG4gICAgICAgICAgZGltU3RhdHM6IHJlc3VsdC5kaW1TdGF0c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBpLCBqLCBudW1QaXhlbHM7XG4gICAgICBpZiAobWFqb3JWZXJzaW9uID4gMSAmJiB1bmlxdWVCYW5kTWFza0NvdW50ID4gMSkge1xuICAgICAgICBudW1QaXhlbHMgPSBkZWNvZGVkUGl4ZWxCbG9jay53aWR0aCAqIGRlY29kZWRQaXhlbEJsb2NrLmhlaWdodDtcbiAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2suYmFuZE1hc2tzID0gYmFuZE1hc2tzO1xuICAgICAgICBtYXNrRGF0YSA9IG5ldyBVaW50OEFycmF5KG51bVBpeGVscyk7XG4gICAgICAgIG1hc2tEYXRhLnNldChiYW5kTWFza3NbMF0pO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmFuZE1hc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYmFuZE1hc2sgPSBiYW5kTWFza3NbaV07XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG51bVBpeGVsczsgaisrKSB7XG4gICAgICAgICAgICBtYXNrRGF0YVtqXSA9IG1hc2tEYXRhW2pdICYgYmFuZE1hc2tbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLm1hc2tEYXRhID0gbWFza0RhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWNvZGVkUGl4ZWxCbG9jaztcbiAgICB9XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7LyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gICAgLy9hbWQgbG9hZGVycyBzdWNoIGFzIGRvam8gYW5kIHJlcXVpcmVKU1xuICAgIC8vaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvTW9kdWxlcy9Bc3luY2hyb25vdXNEZWZpbml0aW9uXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIExlcmM7IH0pOy8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgICAvL2NvbW1vbkpTIG1vZHVsZSAxLjAvMS4xLzEuMS4xIHN5c3RlbXMsIHN1Y2ggYXMgbm9kZUpTXG4gICAgLy9odHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Nb2R1bGVzXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMZXJjOy8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICB9XG4gIGVsc2Uge1xuICAgIC8vYXNzaWduIHRvIHRoaXMsIG1vc3QgbGlrZWx5IHdpbmRvd1xuICAgIHRoaXMuTGVyYyA9IExlcmM7XG4gIH1cblxufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lerc/LercDecode.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/lerc.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/lerc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LercDecoder)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var lerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lerc */ \"./node_modules/lerc/LercDecode.js\");\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basedecoder.js */ \"./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n\n\n\n\n\nclass LercDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n  constructor(fileDirectory) {\n    super();\n\n    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== 'undefined' ? fileDirectory.PlanarConfiguration : 1;\n    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== 'undefined' ? fileDirectory.SamplesPerPixel : 1;\n\n    this.addCompression = fileDirectory.LercParameters[_globals_js__WEBPACK_IMPORTED_MODULE_3__.LercParameters.AddCompression];\n  }\n\n  decodeBlock(buffer) {\n    switch (this.addCompression) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__.LercAddCompression.None:\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__.LercAddCompression.Deflate:\n        buffer = (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n        break;\n      default:\n        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);\n    }\n\n    const lercResult = lerc__WEBPACK_IMPORTED_MODULE_1__.decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });\n    const lercData = lercResult.pixels[0];\n    return lercData.buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9sZXJjLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStCO0FBQ1A7QUFDbUI7QUFDd0I7O0FBRXBELDBCQUEwQix1REFBVztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdURBQXVELHNFQUE2QjtBQUNwRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnRUFBdUI7QUFDbEM7QUFDQSxXQUFXLG1FQUEwQjtBQUNyQyxpQkFBaUIsNkNBQU8saUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQSxzRkFBc0Ysb0JBQW9CO0FBQzFHOztBQUVBLHVCQUF1Qix3Q0FBVyxXQUFXLDREQUE0RDtBQUN6RztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9sZXJjLmpzPzRlYjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5mbGF0ZSB9IGZyb20gJ3Bha28nO1xuaW1wb3J0IExlcmMgZnJvbSAnbGVyYyc7XG5pbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5pbXBvcnQgeyBMZXJjUGFyYW1ldGVycywgTGVyY0FkZENvbXByZXNzaW9uIH0gZnJvbSAnLi4vZ2xvYmFscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExlcmNEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIge1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9IHR5cGVvZiBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24gIT09ICd1bmRlZmluZWQnID8gZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uIDogMTtcbiAgICB0aGlzLnNhbXBsZXNQZXJQaXhlbCA9IHR5cGVvZiBmaWxlRGlyZWN0b3J5LlNhbXBsZXNQZXJQaXhlbCAhPT0gJ3VuZGVmaW5lZCcgPyBmaWxlRGlyZWN0b3J5LlNhbXBsZXNQZXJQaXhlbCA6IDE7XG5cbiAgICB0aGlzLmFkZENvbXByZXNzaW9uID0gZmlsZURpcmVjdG9yeS5MZXJjUGFyYW1ldGVyc1tMZXJjUGFyYW1ldGVycy5BZGRDb21wcmVzc2lvbl07XG4gIH1cblxuICBkZWNvZGVCbG9jayhidWZmZXIpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYWRkQ29tcHJlc3Npb24pIHtcbiAgICAgIGNhc2UgTGVyY0FkZENvbXByZXNzaW9uLk5vbmU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZXJjQWRkQ29tcHJlc3Npb24uRGVmbGF0ZTpcbiAgICAgICAgYnVmZmVyID0gaW5mbGF0ZShuZXcgVWludDhBcnJheShidWZmZXIpKS5idWZmZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBMRVJDIGFkZGl0aW9uYWwgY29tcHJlc3Npb24gbWV0aG9kIGlkZW50aWZpZXI6ICR7dGhpcy5hZGRDb21wcmVzc2lvbn1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsZXJjUmVzdWx0ID0gTGVyYy5kZWNvZGUoYnVmZmVyLCB7IHJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zOiB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEgfSk7XG4gICAgY29uc3QgbGVyY0RhdGEgPSBsZXJjUmVzdWx0LnBpeGVsc1swXTtcbiAgICByZXR1cm4gbGVyY0RhdGEuYnVmZmVyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/compression/lerc.js\n");

/***/ })

}]);